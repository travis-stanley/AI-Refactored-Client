// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Threads
{
	using System;
	using AIRefactored.AI.Combat;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Groups;
	using AIRefactored.AI.Missions;
	using AIRefactored.AI.Movement;
	using AIRefactored.AI.Optimization;
	using AIRefactored.AI.Perception;
	using AIRefactored.AI.Reactions;
	using AIRefactored.Core;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using UnityEngine;

	/// <summary>
	/// Real-time execution engine for AIRefactored bot logic.
	/// Controls subsystem tick order, validity checks, and tick-rate segmentation.
	/// Fully robust: never disables core logic due to subsystem failures—each subsystem falls back individually.
	/// </summary>
	public sealed class BotBrain : MonoBehaviour
	{
		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private BotOwner _bot;
		private Player _player;
		private BotComponentCache _cache;

		private CombatStateMachine _combat;
		private BotMovementController _movement;
		private BotPoseController _pose;
		private BotLookController _look;
		private BotTilt _tilt;
		private BotCornerScanner _corner;
		private BotGroupBehavior _groupBehavior;
		private BotJumpController _jump;
		private BotVisionSystem _vision;
		private BotHearingSystem _hearing;
		private BotPerceptionSystem _perception;
		private HearingDamageComponent _hearingDamage;
		private FlashGrenadeComponent _flashDetector;
		private BotFlashReactionComponent _flashReaction;
		private BotTacticalDeviceController _tactical;
		private BotMissionController _mission;
		private BotGroupSyncCoordinator _groupSync;
		private BotTeamLogic _teamLogic;
		private BotAsyncProcessor _asyncProcessor;
		private BotThreatEscalationMonitor _threatEscalationMonitor;

		private float _lastWarningTime;
		private float _nextPerceptionTick;
		private float _nextCombatTick;
		private float _nextLogicTick;

		private float PerceptionTickRate => FikaHeadlessDetector.IsHeadless ? 1f / 60f : 1f / 30f;
		private float CombatTickRate => FikaHeadlessDetector.IsHeadless ? 1f / 60f : 1f / 30f;
		private float LogicTickRate => FikaHeadlessDetector.IsHeadless ? 1f / 30f : 1f / 15f;

		/// <summary>
		/// Core runtime tick. All subsystems tick independently. Missing or broken subsystems trigger fallback, but never break the rest.
		/// </summary>
		public void Tick(float deltaTime)
		{
			try
			{
				if (!enabled) return;
				if (_bot == null || _player == null || _bot.IsDead) return;

				Player current = _bot.GetPlayer;
				if (current == null || current.HealthController == null || !current.HealthController.IsAlive)
					return;

				float now = Time.time;

				// Perception: fallback gracefully
				if (now >= _nextPerceptionTick)
				{
					TryTick(_vision, () => _vision.Tick(now), "Vision");
					TryTick(_hearing, () => _hearing.Tick(now), "Hearing");
					TryTick(_perception, () => _perception.Tick(deltaTime), "Perception");
					_nextPerceptionTick = now + PerceptionTickRate;
				}

				// Combat: fallback gracefully
				if (now >= _nextCombatTick)
				{
					TryTick(_combat, () => _combat.Tick(now), "Combat", fallback: () => FallbackCombat());
					TryTick(_cache?.Escalation, () => _cache.Escalation.Tick(now), "Escalation");
					TryTick(_flashReaction, () => _flashReaction.Tick(now), "FlashReaction");
					TryTick(_flashDetector, () => _flashDetector.Tick(now), "FlashDetector");
					TryTick(_groupSync, () => _groupSync.Tick(now), "GroupSync");
					TryTick(_teamLogic, () => _teamLogic.CoordinateMovement(), "TeamLogic");
					TryTick(_threatEscalationMonitor, () => _threatEscalationMonitor.Tick(now), "ThreatEscalation");
					_nextCombatTick = now + CombatTickRate;
				}

				// Logic: fallback gracefully
				if (now >= _nextLogicTick)
				{
					TryTick(_mission, () => _mission.Tick(now), "Mission", fallback: () => FallbackMission());
					TryTick(_hearingDamage, () => _hearingDamage.Tick(deltaTime), "HearingDamage");
					TryTick(_tactical, () => _tactical.Tick(), "Tactical");
					TryTick(_cache?.LootScanner, () => _cache.LootScanner.Tick(deltaTime), "LootScanner");
					TryTick(_cache?.DeadBodyScanner, () => _cache.DeadBodyScanner.Tick(now), "DeadBodyScanner");
					TryTick(_asyncProcessor, () => _asyncProcessor.Tick(now), "AsyncProcessor");
					_nextLogicTick = now + LogicTickRate;
				}

				// Movement: fallback to vanilla only if missing
				if (_movement != null)
					TryTick(_movement, () => _movement.Tick(deltaTime), "Movement");
				else
					TryMovementFallback(now);

				// Other systems: fallback gracefully
				TryTick(_jump, () => _jump.Tick(deltaTime), "Jump");
				TryTick(_pose, () => _pose.Tick(now), "Pose");
				TryTick(_look, () => _look.Tick(deltaTime), "Look");
				TryTick(_corner, () => _corner.Tick(now), "CornerScanner");
				TryTick(_tilt, () => _tilt.ManualUpdate(), "Tilt");
				TryTick(_groupBehavior, () => _groupBehavior.Tick(deltaTime), "GroupBehavior");
			}
			catch (Exception ex)
			{
				LogError("[BotBrain] Tick error: " + ex);
			}
		}

		/// <summary>
		/// Initializes the bot brain and all subsystems. Each subsystem that fails to wire triggers fallback for itself, but not for the rest.
		/// </summary>
		public void Initialize(BotOwner bot)
		{
			if (!GameWorldHandler.IsLocalHost())
			{
				LogWarn("[BotBrain] Initialization skipped: not authoritative host.");
				enabled = false;
				return;
			}

			if (bot == null)
			{
				LogError("[BotBrain] Initialization failed: null bot.");
				enabled = false;
				return;
			}

			Player player = bot.GetPlayer;
			if (player == null || !player.IsAI || player.IsYourPlayer || bot.IsDead || player.Profile?.Info == null)
			{
				LogWarn("[BotBrain] Initialization rejected: invalid or non-AI player.");
				enabled = false;
				return;
			}

			_bot = bot;
			_player = player;

			try
			{
				string profileId = player.Profile.Id;
				if (!BotRegistry.TryGetRefactoredOwner(profileId, out AIRefactoredBotOwner owner))
				{
					owner = new AIRefactoredBotOwner();
					owner.Initialize(bot);
					BotRegistry.RegisterOwner(profileId, owner);
				}

				_cache = BotComponentCacheRegistry.GetOrCreate(bot);
				_cache.SetOwner(owner);

				_combat = TryInit(() => _cache.Combat, "Combat");
				_movement = TryInit(() => _cache.Movement, "Movement");
				_pose = TryInit(() => _cache.PoseController, "PoseController");
				_look = TryInit(() => _cache.LookController, "LookController");
				_tilt = TryInit(() => _cache.Tilt, "Tilt");
				_groupBehavior = TryInit(() => _cache.GroupBehavior, "GroupBehavior");

				_corner = TryInit(() => new BotCornerScanner(bot, _cache), "CornerScanner");
				_jump = TryInit(() => new BotJumpController(bot, _cache), "Jump");

				_vision = TryInit(() => { var v = new BotVisionSystem(); v.Initialize(_cache); return v; }, "Vision");
				_hearing = TryInit(() => { var h = new BotHearingSystem(); h.Initialize(_cache); return h; }, "Hearing");
				_perception = TryInit(() => { var p = new BotPerceptionSystem(); p.Initialize(_cache); return p; }, "Perception");
				_flashReaction = TryInit(() => { var f = new BotFlashReactionComponent(); f.Initialize(_cache); return f; }, "FlashReaction");
				_flashDetector = TryInit(() => { var f = new FlashGrenadeComponent(); f.Initialize(_cache); return f; }, "FlashDetector");
				_hearingDamage = TryInit(() => new HearingDamageComponent(), "HearingDamage");
				_tactical = TryInit(() => _cache.Tactical, "Tactical");
				_mission = TryInit(() => new BotMissionController(bot, _cache), "Mission");
				_groupSync = TryInit(() => { var g = new BotGroupSyncCoordinator(); g.Initialize(bot); g.InjectLocalCache(_cache); return g; }, "GroupSync");
				_asyncProcessor = TryInit(() => { var a = new BotAsyncProcessor(); a.Initialize(bot, _cache); return a; }, "AsyncProcessor");
				_teamLogic = TryInit(() => new BotTeamLogic(bot), "TeamLogic");
				_threatEscalationMonitor = TryInit(() => { var t = new BotThreatEscalationMonitor(); t.Initialize(bot); return t; }, "ThreatEscalationMonitor");

				BotBrainGuardian.Enforce(_player.gameObject);
				enabled = true;

				LogDebug("[BotBrain] ✅ AI initialized for: " + (_player.Profile.Info.Nickname ?? "Unnamed"));
			}
			catch (Exception ex)
			{
				LogError("[BotBrain] Initialization failed: " + ex);
				enabled = true; // Do NOT disable the brain—rest will tick on!
			}
		}

		#region Helpers

		private static T TryInit<T>(Func<T> ctor, string name) where T : class
		{
			try { return ctor(); }
			catch (Exception ex)
			{
				LogWarn($"[BotBrain] Subsystem init failed: {name}: {ex}");
				return null;
			}
		}

		private static void TryTick(object obj, Action tick, string label, Action fallback = null)
		{
			try
			{
				if (obj != null) tick();
				else fallback?.Invoke();
			}
			catch (Exception ex)
			{
				LogWarn($"[BotBrain] {label} Tick failed: {ex}");
				fallback?.Invoke();
			}
		}

		private void TryMovementFallback(float now)
		{
			if (_bot != null && _bot.GetPlayer != null && now > _lastWarningTime + 1f)
			{
				LogWarn("[BotBrain] Movement subsystem missing — falling back to vanilla navigation for this bot.");
				_lastWarningTime = now;
				BotFallbackUtility.FallbackToEFTLogic(_bot);
			}
		}

		private void FallbackCombat()
		{
			LogWarn("[BotBrain] Combat subsystem missing — vanilla fallback not implemented for combat.");
		}

		private void FallbackMission()
		{
			LogWarn("[BotBrain] Mission subsystem missing — vanilla fallback not implemented for mission.");
		}

		private static void LogDebug(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogDebug(msg);
		}

		private static void LogWarn(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogWarning(msg);
		}

		private static void LogError(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogError(msg);
		}

		#endregion
	}
}
