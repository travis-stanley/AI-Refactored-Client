// <auto-generated>
//   AI-Refactored: WorldInitState.cs (Beyond Diamond – Bulletproof Lifecycle & Phase Tracker)
//   SYSTEMATICALLY MANAGED. All transitions bulletproofed. No invalid state or cascade. 
//   Fully SPT, FIKA headless/client, and vanilla compatible. MIT License.
// </auto-generated>

namespace AIRefactored.Bootstrap
{
    using System;

    /// <summary>
    /// Tracks and manages the phased lifecycle of world initialization.
    /// All transitions are bulletproof; no invalid state, no unhandled exceptions.
    /// Used to gate AI system boot/tick for total safety and atomic startup.
    /// </summary>
    public static class WorldInitState
    {
        #region Internal State

        private static WorldPhase _phase = WorldPhase.None;

        #endregion

        #region Properties

        /// <summary>
        /// Gets the current world initialization phase.
        /// </summary>
        public static WorldPhase Current => _phase;

        /// <summary>
        /// Returns true if the world has completed all initialization phases.
        /// </summary>
        public static bool IsInitialized => _phase == WorldPhase.PostInit;

        #endregion

        #region API

        /// <summary>
        /// Sets the current initialization phase. 
        /// Bulletproof: Logs and ignores invalid or backward transitions.
        /// </summary>
        /// <param name="phase">The phase to assign.</param>
        public static void SetPhase(WorldPhase phase)
        {
            if (phase < WorldPhase.None || phase > WorldPhase.PostInit)
            {
                Plugin.LoggerInstance.LogWarning("[WorldInitState] Invalid phase assignment attempt: " + phase);
                return;
            }

            // Prevent backward transitions unless explicitly Reset()
            if (phase < _phase && phase != WorldPhase.None)
            {
                Plugin.LoggerInstance.LogWarning("[WorldInitState] Ignored backward phase transition: " + _phase + " -> " + phase);
                return;
            }

            _phase = phase;
        }

        /// <summary>
        /// Returns true if the current world phase is equal to or beyond the specified phase.
        /// </summary>
        /// <param name="phase">The phase to compare against.</param>
        /// <returns>True if the current phase is equal or greater than the specified phase.</returns>
        public static bool IsInPhase(WorldPhase phase)
        {
            return _phase >= phase;
        }

        /// <summary>
        /// Resets the phase tracker to its default uninitialized state.
        /// </summary>
        public static void Reset()
        {
            _phase = WorldPhase.None;
        }

        #endregion
    }

    /// <summary>
    /// Represents the current stage in the world initialization lifecycle.
    /// Used to coordinate system boot timing and enforce safe init entry points.
    /// </summary>
    public enum WorldPhase
    {
        /// <summary>
        /// Startup has not begun.
        /// </summary>
        None = 0,

        /// <summary>
        /// Pre-initialization logic is running (before GameWorld detection).
        /// </summary>
        PreInit = 1,

        /// <summary>
        /// Awaiting GameWorld readiness or player presence.
        /// </summary>
        AwaitWorld = 2,

        /// <summary>
        /// GameWorld is ready and world systems may begin setup.
        /// </summary>
        WorldReady = 3,

        /// <summary>
        /// All systems are fully initialized and the game is in active runtime state.
        /// </summary>
        PostInit = 4
    }
}
