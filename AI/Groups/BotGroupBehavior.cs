// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Maintains passive squad cohesion when idle or patrolling:
    /// • Repels bots that are too close
    /// • Follows furthest idle mate if too far
    /// • Adds subtle jitter to mimic organic movement
    /// Bulletproof: All failures are isolated and fallback to vanilla AI for movement only.
    /// </summary>
    public sealed class BotGroupBehavior
    {
        #region Constants

        private const float MaxSpacing = 7.5f;
        private const float MinSpacing = 2.25f;
        private const float SpacingTolerance = 0.3f;
        private const float RepulseStrength = 1.25f;
        private const float JitterAmount = 0.1f;

        private static readonly float MinSpacingSqr = MinSpacing * MinSpacing;
        private static readonly float MaxSpacingSqr = MaxSpacing * MaxSpacing;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotsGroup _group;

        private Vector3 _lastMoveTarget;
        private bool _hasLastTarget;

        #endregion

        #region Properties

        /// <summary>
        /// Gets the active group sync coordinator for squad behavior.
        /// </summary>
        public BotGroupSyncCoordinator GroupSync { get; private set; }

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the group behavior system with the specified bot.
        /// </summary>
        /// <param name="componentCache">Bot component cache.</param>
        public void Initialize(BotComponentCache componentCache)
        {
            try
            {
                if (componentCache == null || componentCache.Bot == null)
                    throw new ArgumentException("[BotGroupBehavior] Invalid component cache.");

                _cache = componentCache;
                _bot = componentCache.Bot;
                _group = _bot.BotsGroup;

                GroupSync = new BotGroupSyncCoordinator();
                GroupSync.Initialize(_bot);
                GroupSync.InjectLocalCache(componentCache);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotGroupBehavior] Initialization failed: " + ex);
                _bot?.Mover?.GoToPoint(_bot.Position, true, 1.0f); // fallback to static point
            }
        }

        #endregion

        #region Tick Logic

        /// <summary>
        /// Executes squad cohesion and repulsion logic.
        /// </summary>
        /// <param name="deltaTime">Frame delta time.</param>
        public void Tick(float deltaTime)
        {
            try
            {
                if (!IsEligible() || _bot.Memory == null || _bot.Memory.GoalEnemy != null)
                    return;

                Vector3 myPos = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                Vector3 furthest = Vector3.zero;
                float maxDistSqr = MinSpacingSqr;
                bool hasFurthest = false;

                int memberCount = _group.MembersCount;
                for (int i = 0; i < memberCount; i++)
                {
                    BotOwner mate = _group.Member(i);
                    if (mate == null || mate == _bot || mate.IsDead || mate.Memory == null)
                        continue;

                    Vector3 offset = mate.Position - myPos;
                    float distSqr = offset.sqrMagnitude;

                    if (distSqr < MinSpacingSqr)
                    {
                        float push = MinSpacing - Mathf.Sqrt(distSqr);
                        repulsion += -offset.normalized * push;
                    }
                    else if (distSqr > MaxSpacingSqr && distSqr > maxDistSqr && mate.Memory.GoalEnemy == null)
                    {
                        maxDistSqr = distSqr;
                        furthest = mate.Position;
                        hasFurthest = true;
                    }
                }

                if (repulsion.sqrMagnitude > 0.01f)
                {
                    IssueMove(myPos + repulsion.normalized * RepulseStrength);
                    return;
                }

                if (hasFurthest)
                {
                    Vector3 dir = furthest - myPos;
                    if (dir.sqrMagnitude > 0.001f)
                    {
                        IssueMove(myPos + dir.normalized * MaxSpacing);
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotGroupBehavior] Tick failed: " + ex);
                _bot?.Mover?.GoToPoint(_bot.Position, true, 1.0f); // fallback to static point
            }
        }

        #endregion

        #region Helpers

        private bool IsEligible()
        {
            return _bot != null &&
                   _group != null &&
                   !_bot.IsDead &&
                   EFTPlayerUtil.IsValidBotOwner(_bot);
        }

        private void IssueMove(Vector3 target)
        {
            try
            {
                Vector3 jittered = target + UnityEngine.Random.insideUnitSphere * JitterAmount;
                jittered.y = target.y;

                if (!_hasLastTarget || Vector3.Distance(_lastMoveTarget, jittered) > SpacingTolerance)
                {
                    _lastMoveTarget = jittered;
                    _hasLastTarget = true;
                    BotMovementHelper.SmoothMoveTo(_bot, jittered, false);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[BotGroupBehavior] IssueMove failed: " + ex);
                _bot?.Mover?.GoToPoint(_bot.Position, true, 1.0f); // fallback to static point
            }
        }

        #endregion
    }
}
