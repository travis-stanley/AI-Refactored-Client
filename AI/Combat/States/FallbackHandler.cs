// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles suppression fallback, retreat routing, and cover movement during engagements.
    /// </summary>
    public sealed class FallbackHandler : IDisposable
    {
        #region Constants

        private const float MinArrivalDistance = 2.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _currentFallbackPath;

        private Vector3 _fallbackTarget;

        #endregion

        #region Constructor

        public FallbackHandler(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
            {
                Plugin.LoggerInstance.LogError("[FallbackHandler] Null Bot or cache during initialization.");
                throw new ArgumentException("FallbackHandler requires a valid cache with BotOwner.");
            }

            _cache = cache;
            _bot = cache.Bot;
            _fallbackTarget = _bot.Position;
            _currentFallbackPath = TempListPool.Rent<Vector3>();
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Gets the current fallback target position.
        /// </summary>
        public Vector3 GetFallbackPosition()
        {
            return _fallbackTarget;
        }

        /// <summary>
        /// Gets the fallback position, or the provided default if path is invalid.
        /// </summary>
        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos)
        {
            return HasValidFallbackPath() ? _fallbackTarget : defaultPos;
        }

        /// <summary>
        /// True if the fallback path is valid and nontrivial.
        /// </summary>
        public bool HasValidFallbackPath()
        {
            return _currentFallbackPath.Count >= 2 && IsVectorValid(_fallbackTarget);
        }

        /// <summary>
        /// Sets the fallback target, if valid.
        /// </summary>
        public void SetFallbackTarget(Vector3 target)
        {
            if (!IsVectorValid(target))
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Ignored fallback target with invalid vector.");
                return;
            }

            _fallbackTarget = target;
        }

        /// <summary>
        /// Sets the fallback path using a list of valid points.
        /// </summary>
        public void SetFallbackPath(List<Vector3> path)
        {
            if (path == null || path.Count < 2)
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Rejected fallback path: path too short.");
                return;
            }

            _currentFallbackPath.Clear();

            for (int i = 0; i < path.Count; i++)
            {
                Vector3 point = path[i];
                if (IsVectorValid(point))
                {
                    _currentFallbackPath.Add(point);
                }
            }

            if (_currentFallbackPath.Count >= 2)
            {
                _fallbackTarget = _currentFallbackPath[_currentFallbackPath.Count - 1];
            }
            else
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Final fallback path was invalid.");
            }
        }

        /// <summary>
        /// Returns true if fallback should be used right now.
        /// </summary>
        public bool ShallUseNow(float time)
        {
            return !_cache.IsFallbackMode &&
                   _bot != null &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        /// <summary>
        /// Determines if fallback should be triggered due to suppression.
        /// </summary>
        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            return _cache.Suppression != null &&
                   _cache.Suppression.IsSuppressed() &&
                   (now - lastStateChangeTime) >= minStateDuration;
        }

        /// <summary>
        /// Tick update: drives fallback movement and cover, triggers patrol on arrival.
        /// </summary>
        public void Tick(float time, Action<CombatState, float> forceState)
        {
            if (_cache.IsFallbackMode || _bot == null || !IsVectorValid(_fallbackTarget))
                return;

            Player player = _bot.GetPlayer;
            if (!EFTPlayerUtil.IsValid(player))
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Tick skipped: bot player invalid.");
                return;
            }

            if (_bot.Mover != null)
            {
                BotMovementHelper.SmoothMoveTo(_bot, _fallbackTarget);
                BotCoverHelper.TrySetStanceFromNearbyCover(_cache, _fallbackTarget);
            }
            else
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] BotMover missing. Fallback to EFT AI.");
                BotFallbackUtility.FallbackToEFTLogic(_bot);
                return;
            }

            if (Vector3.Distance(_bot.Position, _fallbackTarget) < MinArrivalDistance)
            {
                forceState?.Invoke(CombatState.Patrol, time);

                if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null)
                {
                    _bot.BotTalk.TrySay(EPhraseTrigger.NeedHelp);
                }
            }
        }

        /// <summary>
        /// Returns true if fallback state is still active.
        /// </summary>
        public bool IsActive()
        {
            return _bot != null &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        /// <summary>
        /// Cancels fallback and clears any cached path.
        /// </summary>
        public void Cancel()
        {
            _fallbackTarget = (_bot != null) ? _bot.Position : Vector3.zero;
            _currentFallbackPath.Clear();
        }

        /// <summary>
        /// Releases pooled resources.
        /// </summary>
        public void Dispose()
        {
            TempListPool.Return(_currentFallbackPath);
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Validates a Vector3 for fallback/AI purposes.
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) &&
                   !float.IsNaN(v.y) &&
                   !float.IsNaN(v.z) &&
                   v != Vector3.zero;
        }

        #endregion
    }
}
