// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Core
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Medical;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Perception;
    using AIRefactored.AI.Reactions;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Runtime container for all bot-specific AIRefactored logic systems.
    /// Managed via BotComponentCacheRegistry.
    /// Bulletproof: If any component fails, falls back to vanilla logic for that part only.
    /// </summary>
    public sealed class BotComponentCache
    {
        #region Static

        public static readonly BotComponentCache Empty = new BotComponentCache();
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private static readonly HashSet<string> InitializedBots = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        #endregion

        #region Fields

        private AIRefactoredBotOwner _owner;

        #endregion

        #region Core References

        public BotOwner Bot { get; internal set; }

        public AIRefactoredBotOwner AIRefactoredBotOwner => _owner;

        public BotMemoryClass Memory => Bot?.Memory;

        public string Nickname => Bot?.Profile?.Info?.Nickname ?? "Unknown";

        public Vector3 Position => Bot != null ? Bot.Position : Vector3.zero;

        #endregion

        #region Personality

        public BotPersonalityProfile PersonalityProfile { get; private set; } = new BotPersonalityProfile();

        #endregion

        #region Runtime Flags

        public bool IsBlinded { get; set; }
        public float BlindUntilTime { get; set; }
        public float LastFlashTime { get; set; }

        public float LastHeardTime { get; private set; } = -999f;
        public Vector3 LastHeardDirection { get; private set; }
        public bool HasHeardDirection { get; private set; }

        public bool IsFallbackMode { get; private set; }

        #endregion

        #region AI Subsystems

        public CombatStateMachine Combat { get; private set; }
        public BotMovementController Movement { get; private set; }
        public BotPoseController PoseController { get; private set; }
        public BotLookController LookController { get; private set; }
        public BotTilt Tilt { get; private set; }
        public BotTacticalDeviceController Tactical { get; private set; }
        public BotGroupBehavior GroupBehavior { get; private set; }
        public BotThreatSelector ThreatSelector { get; private set; }
        public BotTacticalMemory TacticalMemory { get; private set; }
        public BotLastShotTracker LastShotTracker { get; private set; }
        public BotGroupComms GroupComms { get; private set; }
        public BotSuppressionReactionComponent Suppression { get; private set; }
        public BotPanicHandler PanicHandler { get; private set; }
        public BotThreatEscalationMonitor Escalation { get; private set; }
        public BotInjurySystem InjurySystem { get; private set; }
        public BotDeadBodyScanner DeadBodyScanner { get; private set; }
        public BotLootScanner LootScanner { get; private set; }
        public BotLootDecisionSystem LootDecisionSystem { get; private set; }
        public BotOwnerPathfindingCache Pathing { get; private set; }
        public SquadPathCoordinator SquadPath { get; private set; }
        public BotDoorInteractionSystem DoorInteraction { get; private set; }
        public BotHealingBySomebody HealReceiver { get; private set; }
        public BotHealAnotherTarget SquadHealer { get; private set; }
        public FlashGrenadeComponent FlashGrenade { get; private set; }
        public HearingDamageComponent HearingDamage { get; private set; }
        public TrackedEnemyVisibility VisibilityTracker { get; set; }

        public BotGroupSyncCoordinator GroupSync => GroupBehavior?.GroupSync;
        public BotPanicHandler Panic => PanicHandler;

        #endregion

        #region Properties

        public bool IsReady =>
            Bot != null &&
            Movement != null &&
            Suppression != null &&
            PanicHandler != null &&
            Tactical != null &&
            FlashGrenade != null;

        #endregion

        #region Initialization

        public void Initialize(BotOwner bot)
        {
            if (bot == null)
            {
                Logger.LogError("[BotComponentCache] Initialize called with null bot.");
                BotFallbackUtility.FallbackToEFTLogic(bot);
                return;
            }

            string id = bot.Profile?.Id ?? "null";

            if (Bot != null || InitializedBots.Contains(id))
            {
                Logger.LogWarning("[BotComponentCache] Already initialized for bot: " + id);
                return;
            }

            InitializedBots.Add(id);
            Bot = bot;

            // All initialization wrapped per-subsystem: any part that fails disables only that part.
            WildSpawnType role = bot.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault;
            PersonalityProfile = BotRegistry.GetOrGenerate(id, PersonalityType.Balanced, role);
            Logger.LogDebug($"[BotComponentCache] Loaded personality for bot {id}: {PersonalityProfile.Personality}");

            try { Pathing = new BotOwnerPathfindingCache(); } catch (Exception ex) { LogAndFallback("Pathing", ex); Pathing = null; }
            try { TacticalMemory = new BotTacticalMemory(); TacticalMemory.Initialize(this); } catch (Exception ex) { LogAndFallback("TacticalMemory", ex); TacticalMemory = null; }
            try { Combat = new CombatStateMachine(); Combat.Initialize(this); } catch (Exception ex) { LogAndFallback("Combat", ex); Combat = null; }
            try { FlashGrenade = new FlashGrenadeComponent(); FlashGrenade.Initialize(this); } catch (Exception ex) { LogAndFallback("FlashGrenade", ex); FlashGrenade = null; }
            try { PanicHandler = new BotPanicHandler(); PanicHandler.Initialize(this); } catch (Exception ex) { LogAndFallback("PanicHandler", ex); PanicHandler = null; }
            try { Suppression = new BotSuppressionReactionComponent(); Suppression.Initialize(this); } catch (Exception ex) { LogAndFallback("Suppression", ex); Suppression = null; }
            try { Escalation = new BotThreatEscalationMonitor(); Escalation.Initialize(bot); } catch (Exception ex) { LogAndFallback("Escalation", ex); Escalation = null; }
            try { GroupBehavior = new BotGroupBehavior(); GroupBehavior.Initialize(this); } catch (Exception ex) { LogAndFallback("GroupBehavior", ex); GroupBehavior = null; }
            try { Movement = new BotMovementController(); Movement.Initialize(this); } catch (Exception ex) { LogAndFallback("Movement", ex); Movement = null; }
            try { LookController = new BotLookController(bot, this); } catch (Exception ex) { LogAndFallback("LookController", ex); LookController = null; }
            try { Tactical = new BotTacticalDeviceController(); Tactical.Initialize(this); } catch (Exception ex) { LogAndFallback("Tactical", ex); Tactical = null; }
            try { PoseController = new BotPoseController(bot, this); } catch (Exception ex) { LogAndFallback("PoseController", ex); PoseController = null; }
            try { Tilt = new BotTilt(bot); } catch (Exception ex) { LogAndFallback("Tilt", ex); Tilt = null; }
            try { HearingDamage = new HearingDamageComponent(); } catch (Exception ex) { LogAndFallback("HearingDamage", ex); HearingDamage = null; }
            try { SquadPath = new SquadPathCoordinator(); SquadPath.Initialize(this); } catch (Exception ex) { LogAndFallback("SquadPath", ex); SquadPath = null; }
            try { LootScanner = new BotLootScanner(); LootScanner.Initialize(this); } catch (Exception ex) { LogAndFallback("LootScanner", ex); LootScanner = null; }
            try { LootDecisionSystem = new BotLootDecisionSystem(); LootDecisionSystem.Initialize(this); } catch (Exception ex) { LogAndFallback("LootDecisionSystem", ex); LootDecisionSystem = null; }
            try { DeadBodyScanner = new BotDeadBodyScanner(); DeadBodyScanner.Initialize(this); } catch (Exception ex) { LogAndFallback("DeadBodyScanner", ex); DeadBodyScanner = null; }
            try { DoorInteraction = new BotDoorInteractionSystem(bot); } catch (Exception ex) { LogAndFallback("DoorInteraction", ex); DoorInteraction = null; }
            try { InjurySystem = new BotInjurySystem(this); } catch (Exception ex) { LogAndFallback("InjurySystem", ex); InjurySystem = null; }
            try { LastShotTracker = new BotLastShotTracker(); } catch (Exception ex) { LogAndFallback("LastShotTracker", ex); LastShotTracker = null; }
            try { GroupComms = new BotGroupComms(this); } catch (Exception ex) { LogAndFallback("GroupComms", ex); GroupComms = null; }
            try { SquadHealer = bot.HealAnotherTarget ?? new BotHealAnotherTarget(bot); } catch (Exception ex) { LogAndFallback("SquadHealer", ex); SquadHealer = null; }
            try { HealReceiver = bot.HealingBySomebody ?? new BotHealingBySomebody(bot); } catch (Exception ex) { LogAndFallback("HealReceiver", ex); HealReceiver = null; }

            Logger.LogDebug($"[BotComponentCache] ✅ Initialized for bot: {Nickname}");
        }

        private void LogAndFallback(string subsystem, Exception ex)
        {
            Logger.LogError($"[BotComponentCache] Subsystem {subsystem} failed: {ex}");
            BotFallbackUtility.FallbackToEFTLogic(Bot);
        }

        #endregion

        #region Fallback Entry

        public void EnterFallback()
        {
            IsFallbackMode = true;
            Logger.LogWarning($"[BotComponentCache] Entered fallback mode for bot: {Nickname}");
            BotFallbackUtility.FallbackToEFTLogic(Bot);
        }

        #endregion

        #region External Setters

        public void SetOwner(AIRefactoredBotOwner owner)
        {
            if (owner == null)
            {
                Logger.LogError("[BotComponentCache] SetOwner() called with null.");
                BotFallbackUtility.FallbackToEFTLogic(Bot);
                return;
            }

            _owner = owner;

            if (ThreatSelector == null)
            {
                try { ThreatSelector = new BotThreatSelector(this); }
                catch (Exception ex)
                {
                    Logger.LogError("[BotComponentCache] ThreatSelector failed: " + ex);
                    ThreatSelector = null;
                    BotFallbackUtility.FallbackToEFTLogic(Bot);
                }
            }
        }

        public void RegisterHeardSound(Vector3 source)
        {
            if (Bot == null)
            {
                Logger.LogWarning("[BotComponentCache] RegisterHeardSound failed — bot not assigned.");
                return;
            }

            LastHeardTime = Time.time;
            LastHeardDirection = source - Position;
            HasHeardDirection = true;

            Logger.LogDebug($"[BotComponentCache] Registered sound from: {source}");
        }

        #endregion
    }
}
