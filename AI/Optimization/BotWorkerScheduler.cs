// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Threading;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Central dispatcher for safely queuing Unity API calls from background threads.
    /// Schedules Unity-related tasks and defers spawns to prevent frame spikes.
    /// Manual Tick(float now) must be called every frame from host.
    /// </summary>
    public static class BotWorkScheduler
    {
        #region Constants

        private const int MaxSpawnsPerSecond = 5;
        private const int MaxSpawnQueueSize = 256;

        #endregion

        #region Fields

        private static readonly ConcurrentQueue<Action> MainThreadQueue = new ConcurrentQueue<Action>();
        private static readonly Queue<Action> SpawnQueue = new Queue<Action>(MaxSpawnQueueSize);
        private static readonly object SpawnLock = new object();

        private static int _queuedCount;
        private static int _executedCount;
        private static int _errorCount;

        private static ManualLogSource _logger;

        #endregion

        #region Public API

        /// <summary>
        /// Schedules a Unity-safe action to run on the next main thread tick.
        /// </summary>
        /// <param name="action">Action to invoke from the Unity thread.</param>
        public static void EnqueueToMainThread(Action action)
        {
            if (action == null || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            MainThreadQueue.Enqueue(action);
            Interlocked.Increment(ref _queuedCount);
            EnsureLogger().LogDebug("[BotWorkScheduler] Main thread task queued.");
        }

        /// <summary>
        /// Enqueues spawn logic for deferred throttling.
        /// </summary>
        /// <param name="action">Spawn or allocation action to invoke.</param>
        public static void EnqueueSpawnSmoothed(Action action)
        {
            if (action == null || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            lock (SpawnLock)
            {
                if (SpawnQueue.Count < MaxSpawnQueueSize)
                {
                    SpawnQueue.Enqueue(action);
                    EnsureLogger().LogDebug("[BotWorkScheduler] Spawn action queued.");
                }
                else
                {
                    EnsureLogger().LogWarning("[BotWorkScheduler] Spawn queue full. Task dropped.");
                }
            }
        }

        /// <summary>
        /// Ticks the scheduler. Call once per frame from world update.
        /// </summary>
        /// <param name="now">Current time from Time.time.</param>
        public static void Tick(float now)
        {
            if (!GameWorldHandler.IsLocalHost())
            {
                return;
            }

            ManualLogSource logger = EnsureLogger();

            while (MainThreadQueue.TryDequeue(out Action task))
            {
                try
                {
                    task();
                    Interlocked.Increment(ref _executedCount);
                }
                catch (Exception ex)
                {
                    Interlocked.Increment(ref _errorCount);
                    logger.LogWarning("[BotWorkScheduler] Task failed:\n" + ex);
                }
            }

            int allowed = Mathf.Max(1, Mathf.FloorToInt(MaxSpawnsPerSecond * Time.unscaledDeltaTime));
            int executed = 0;

            lock (SpawnLock)
            {
                while (executed < allowed && SpawnQueue.Count > 0)
                {
                    try
                    {
                        SpawnQueue.Dequeue().Invoke();
                        executed++;
                    }
                    catch (Exception ex)
                    {
                        logger.LogWarning("[BotWorkScheduler] Spawn failed:\n" + ex);
                    }
                }
            }
        }

        /// <summary>
        /// Returns internal scheduler stats for diagnostics.
        /// </summary>
        /// <returns>Formatted scheduler state.</returns>
        public static string GetStats()
        {
            return "[BotWorkScheduler] Queued=" + _queuedCount +
                   ", Executed=" + _executedCount +
                   ", Errors=" + _errorCount +
                   ", SpawnQueue=" + SpawnQueue.Count;
        }

        #endregion

        #region Internals

        private static ManualLogSource EnsureLogger()
        {
            if (_logger == null)
            {
                _logger = Plugin.LoggerInstance;
            }

            return _logger;
        }

        #endregion
    }
}
