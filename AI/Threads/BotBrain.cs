// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All failures are locally contained, never break other subsystems. No vanilla fallback is triggered.
//   No bot is ever marked as terminal or failed — all systems retry until successful.
//   Realism: ALL per-bot logic is driven, ticked, and coordinated by BotBrain only. No subsystems self-tick.
// </auto-generated>

namespace AIRefactored.AI.Threads
{
	using System;
	using AIRefactored.AI.Combat;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Groups;
	using AIRefactored.AI.Missions;
	using AIRefactored.AI.Movement;
	using AIRefactored.AI.Optimization;
	using AIRefactored.AI.Perception;
	using AIRefactored.AI.Reactions;
	using AIRefactored.Core;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using UnityEngine;

	/// <summary>
	/// Central per-bot AI tick controller. ALL bot subsystems ticked here and only here.
	/// No subsystem ever self-updates or runs coroutines/timers.
	/// </summary>
	public sealed class BotBrain : MonoBehaviour
	{
		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		// Core References
		private BotOwner _bot;
		private Player _player;
		private BotComponentCache _cache;

		// AI Subsystems
		private CombatStateMachine _combat;
		private BotMovementController _movement;
		private BotPoseController _pose;
		private BotLookController _look;
		private BotTilt _tilt;
		private BotCornerScanner _corner;
		private BotGroupBehavior _groupBehavior;
		private BotJumpController _jump;
		private BotVisionSystem _vision;
		private BotHearingSystem _hearing;
		private BotPerceptionSystem _perception;
		private HearingDamageComponent _hearingDamage;
		private FlashGrenadeComponent _flashDetector;
		private BotFlashReactionComponent _flashReaction;
		private BotTacticalDeviceController _tactical;
		private BotMissionController _mission;
		private BotGroupSyncCoordinator _groupSync;
		private BotTeamLogic _teamLogic;
		private BotAsyncProcessor _asyncProcessor;
		private BotThreatEscalationMonitor _threatEscalationMonitor;

		// Timers
		private float _nextPerceptionTick;
		private float _nextCombatTick;
		private float _nextLogicTick;

		// Centralized tick rates (adjustable, parity with your plan)
		private const float DefaultPerceptionHz = 30f;
		private const float DefaultCombatHz = 30f;
		private const float DefaultLogicHz = 10f;

		private float PerceptionTickRate => 1f / (FikaHeadlessDetector.IsHeadless ? 60f : DefaultPerceptionHz);
		private float CombatTickRate => 1f / (FikaHeadlessDetector.IsHeadless ? 60f : DefaultCombatHz);
		private float LogicTickRate => 1f / (FikaHeadlessDetector.IsHeadless ? 20f : DefaultLogicHz);

		#region Initialization

		/// <summary>
		/// Called once on bot spawn; wires all subsystems. Only ever called by injector/controller.
		/// </summary>
		public void Initialize(BotOwner bot)
		{
			if (!GameWorldHandler.IsLocalHost())
			{
				LogWarn("[BotBrain] Initialization skipped: not authoritative host.");
				enabled = false;
				return;
			}

			if (bot == null)
			{
				LogError("[BotBrain] Initialization failed: null bot.");
				enabled = false;
				return;
			}

			Player player = bot.GetPlayer;
			if (player == null || !player.IsAI || player.IsYourPlayer || bot.IsDead || player.Profile?.Info == null)
			{
				LogWarn("[BotBrain] Initialization rejected: invalid or non-AI player.");
				enabled = false;
				return;
			}

			_bot = bot;
			_player = player;

			try
			{
				_cache = BotComponentCacheRegistry.GetOrCreate(bot);
				if (_cache == null)
				{
					LogError("[BotBrain] Initialization failed: cache could not be created.");
					enabled = false;
					return;
				}

				var owner = _cache.AIRefactoredBotOwner;
				if (owner == null)
				{
					LogError("[BotBrain] Initialization failed: owner not wired in cache.");
					enabled = false;
					return;
				}

				_cache.SetOwner(owner);

				// Attach/resolve all subsystems from the cache, enforcing strict null safety.
				_combat = _cache.Combat ?? new CombatStateMachine();
				_movement = _cache.Movement ?? new BotMovementController();
				_pose = _cache.PoseController ?? new BotPoseController(bot, _cache);
				_look = _cache.LookController ?? new BotLookController(bot, _cache);
				_tilt = _cache.Tilt ?? new BotTilt(bot);
				_groupBehavior = _cache.GroupBehavior ?? new BotGroupBehavior();

				_corner = new BotCornerScanner(bot, _cache);
				_jump = new BotJumpController(bot, _cache);

				_vision = new BotVisionSystem(); _vision.Initialize(_cache);
				_hearing = new BotHearingSystem(); _hearing.Initialize(_cache);
				_perception = new BotPerceptionSystem(); _perception.Initialize(_cache);

				_flashReaction = new BotFlashReactionComponent(); _flashReaction.Initialize(_cache);
				_flashDetector = new FlashGrenadeComponent(); _flashDetector.Initialize(_cache);
				_hearingDamage = new HearingDamageComponent();
				_tactical = _cache.Tactical ?? new BotTacticalDeviceController();

				_mission = new BotMissionController(bot, _cache);
				_groupSync = new BotGroupSyncCoordinator(); _groupSync.Initialize(bot); _groupSync.InjectLocalCache(_cache);
				_asyncProcessor = new BotAsyncProcessor(); _asyncProcessor.Initialize(bot, _cache);
				_teamLogic = new BotTeamLogic(bot);
				_threatEscalationMonitor = new BotThreatEscalationMonitor(); _threatEscalationMonitor.Initialize(bot);

				// Timers set to "now" for smooth startup
				float now = Time.time;
				_nextPerceptionTick = now;
				_nextCombatTick = now;
				_nextLogicTick = now;

				BotBrainGuardian.Enforce(_player.gameObject);
				enabled = true;

				LogDebug("[BotBrain] ✅ AI initialized for: " + (_player.Profile.Info.Nickname ?? "Unnamed"));
			}
			catch (Exception ex)
			{
				LogError("[BotBrain] Initialization failed: " + ex);
				enabled = true; // Never disables permanently; must retry until successful.
			}
		}

		#endregion

		#region Main Tick

		/// <summary>
		/// The only update loop for this bot. All per-bot subsystems tick here and only here.
		/// </summary>
		public void Tick(float deltaTime)
		{
			try
			{
				if (!enabled || _bot == null || _player == null || _bot.IsDead)
					return;
				if (_bot.GetPlayer == null || _bot.GetPlayer.HealthController == null || !_bot.GetPlayer.HealthController.IsAlive)
					return;

				float now = Time.time;

				// 1. Frame-perfect subsystems (movement, pose, look, lean, jump, corner, group) always tick EVERY FRAME (fluid).
				SafeTick(_movement, m => m.Tick(deltaTime), "Movement", warn: true);
				SafeTick(_pose, p => p.Tick(now), "Pose");
				SafeTick(_look, l => l.Tick(deltaTime), "Look");
				SafeTick(_jump, j => j.Tick(deltaTime), "Jump");
				SafeTick(_corner, c => c.Tick(now), "CornerScanner");
				SafeTick(_tilt, t => t.ManualUpdate(), "Tilt");
				SafeTick(_groupBehavior, g => g.Tick(deltaTime), "GroupBehavior");

				// 2. Perception/Combat/Logic: Ticked at user-controlled rates
				if (now >= _nextPerceptionTick)
				{
					SafeTick(_vision, v => v.Tick(now), "Vision");
					SafeTick(_hearing, h => h.Tick(now), "Hearing");
					SafeTick(_perception, p => p.Tick(now), "Perception");
					_nextPerceptionTick = now + PerceptionTickRate;
				}

				if (now >= _nextCombatTick)
				{
					SafeTick(_combat, c => c.Tick(now), "Combat");
					SafeTick(_cache?.Escalation, e => e.Tick(now), "Escalation");
					SafeTick(_flashReaction, f => f.Tick(now), "FlashReaction");
					SafeTick(_flashDetector, f => f.Tick(now), "FlashDetector");
					SafeTick(_groupSync, g => g.Tick(now), "GroupSync");
					SafeTick(_teamLogic, t => t.CoordinateMovement(), "TeamLogic");
					SafeTick(_threatEscalationMonitor, t => t.Tick(now), "ThreatEscalation");
					_nextCombatTick = now + CombatTickRate;
				}

				if (now >= _nextLogicTick)
				{
					SafeTick(_mission, m => m.Tick(now), "Mission");
					SafeTick(_hearingDamage, h => h.Tick(deltaTime), "HearingDamage");
					SafeTick(_tactical, t => t.Tick(), "Tactical");
					SafeTick(_cache?.LootScanner, l => l.Tick(deltaTime), "LootScanner");
					SafeTick(_cache?.DeadBodyScanner, d => d.Tick(now), "DeadBodyScanner");
					SafeTick(_asyncProcessor, a => a.Tick(now), "AsyncProcessor");
					_nextLogicTick = now + LogicTickRate;
				}

				// 3. Fallback handler (if used)
				if (_combat != null && _combat.IsInCombatState() && _cache?.Fallback != null && _cache.Fallback.IsActive())
				{
					SafeTick(_cache.Fallback, f => f.Tick(now, null), "Fallback");
				}
			}
			catch (Exception ex)
			{
				LogError("[BotBrain] Tick error: " + ex);
			}
		}

		#endregion

		#region Tick Helper

		/// <summary>
		/// Ticks a subsystem and swallows/logs all errors. Optionally warns if missing.
		/// </summary>
		private static void SafeTick<T>(T obj, Action<T> tick, string label, bool warn = false)
			where T : class
		{
			try
			{
				if (obj != null) tick(obj);
				else if (warn)
					Logger.LogWarning($"[BotBrain] {label} subsystem missing.");
			}
			catch (Exception ex)
			{
				Logger.LogWarning($"[BotBrain] {label} Tick failed: {ex}");
			}
		}

		#endregion

		#region Logging

		private static void LogDebug(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogDebug(msg);
		}

		private static void LogWarn(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogWarning(msg);
		}

		private static void LogError(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogError(msg);
		}

		#endregion
	}
}
