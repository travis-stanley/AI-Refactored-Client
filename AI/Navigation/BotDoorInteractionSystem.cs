// <auto-generated>
//   AI-Refactored: BotDoorInteractionSystem.cs (Beyond Diamond, Stutter-Proofed Edition)
//   SYSTEMATICALLY MANAGED. Bulletproof door logic with anti-stale checks and movement stutter prevention.
//   Licensed under MIT.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using UnityEngine;

    /// <summary>
    /// Handles squad-perfect, human-error-rich bot door logic.
    /// Bulletproof: no disables, no vanilla handoff, never blocks AI or squad flow.
    /// </summary>
    public sealed class BotDoorInteractionSystem
    {
        #region Constants

        private const float DoorRetryCooldown = 2.6f;
        private const float DoorCheckInterval = 0.41f;
        private const float DoorCastRange = 1.85f;
        private const float DoorCastRadius = 0.45f;
        private const float HesitateChance = 0.12f;
        private const float HesitateMinDelay = 0.16f;
        private const float HesitateMaxDelay = 0.53f;
        private const float SquadWaitRadius = 2.1f;
        private const float PanicFastDelay = 0.04f;
        private const float StealthExtraWait = 0.23f;
        private const float RareGiveUpChance = 0.04f;
        private const float MaxStaleDoorTime = 5.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly ManualLogSource _log;

        private float _lastDoorCheckTime;
        private float _nextRetryTime;
        private float _doorStateSinceTime;
        private Door _currentDoor;
        private float _hesitateUntil;
        private float _giveUpUntil;
        private bool _hasGivenUp;

        #endregion

        #region Properties

        public bool IsBlockedByDoor { get; private set; }

        #endregion

        #region Constructor

        public BotDoorInteractionSystem(BotOwner bot)
        {
            if (bot == null)
                throw new ArgumentNullException(nameof(bot), "[BotDoorInteractionSystem] BotOwner was null.");
            _bot = bot;
            _log = Plugin.LoggerInstance;
            _hesitateUntil = 0f;
            _giveUpUntil = 0f;
            _hasGivenUp = false;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Main tick entry point for door logic, called by BotBrain.
        /// </summary>
        public void Tick(float time)
        {
            try
            {
                if (_bot == null || _bot.IsDead)
                    return;
                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.CurrentManagedState == null)
                    return;

                if (time < _lastDoorCheckTime + DoorCheckInterval)
                    return;
                _lastDoorCheckTime = time;

                if (_hasGivenUp && time < _giveUpUntil)
                {
                    MarkBlocked(_currentDoor, time);
                    return;
                }
                if (_hasGivenUp && time >= _giveUpUntil)
                {
                    _hasGivenUp = false;
                    _giveUpUntil = 0f;
                }

                if (_currentDoor != null && time - _doorStateSinceTime > MaxStaleDoorTime)
                {
                    ClearDoorState();
                }

                Vector3 origin = _bot.Position + Vector3.up * 1.18f;
                Vector3 forward = _bot.LookDirection;
                RaycastHit hit;
                if (!Physics.SphereCast(origin, DoorCastRadius, forward, out hit, DoorCastRange, AIRefactoredLayerMasks.Interactive))
                {
                    ClearDoorState();
                    return;
                }

                Collider col = hit.collider;
                if (col == null)
                {
                    ClearDoorState();
                    return;
                }

                Door door = col.GetComponentInParent<Door>();
                if (door == null || !door.enabled || !door.Operatable)
                {
                    ClearDoorState();
                    return;
                }

                float doorDist = Vector3.Distance(EFTPlayerUtil.GetPosition(_bot), door.transform.position);
                if (doorDist > DoorCastRange)
                {
                    ClearDoorState();
                    return;
                }

                EDoorState state = door.DoorState;
                if ((state & EDoorState.Open) != 0 || (state & EDoorState.Breaching) != 0)
                {
                    ClearDoorState();
                    return;
                }

                if (state == EDoorState.Interacting || time < _nextRetryTime || ShouldWaitForSquad(door))
                {
                    MarkBlocked(door, time);
                    return;
                }

                float hesitation = 0f;
                var cache = _bot.GetComponent<BotComponentCache>();
                var profile = cache?.PersonalityProfile;
                if (cache != null && cache.PanicHandler != null && cache.PanicHandler.IsPanicking)
                {
                    hesitation = PanicFastDelay;
                }
                else if (profile != null && (profile.Personality == PersonalityType.Stalker || profile.Caution > 0.7f))
                {
                    hesitation = UnityEngine.Random.Range(HesitateMinDelay, HesitateMaxDelay) + StealthExtraWait;
                }
                else if (UnityEngine.Random.value < HesitateChance)
                {
                    hesitation = UnityEngine.Random.Range(HesitateMinDelay, HesitateMaxDelay);
                }

                if (_hesitateUntil < time)
                    _hesitateUntil = time + hesitation;
                if (_hesitateUntil > time)
                {
                    MarkBlocked(door, time);
                    return;
                }

                if (UnityEngine.Random.value < RareGiveUpChance)
                {
                    _hasGivenUp = true;
                    _giveUpUntil = time + DoorRetryCooldown + UnityEngine.Random.Range(0.4f, 1.8f);
                    MarkBlocked(door, time);
                    return;
                }

                float pose = _bot.GetPlayer?.MovementContext?.PoseLevel ?? 100f;
                if (pose < 40f)
                {
                    MarkBlocked(door, time);
                    return;
                }

                try
                {
                    EInteractionType interactionType = GetBestInteractionType(state);
                    InteractionResult result = new InteractionResult(interactionType);
                    player.CurrentManagedState.StartDoorInteraction(door, result, null);
                    _log.LogDebug($"[BotDoorInteraction] {player.ProfileId} → {interactionType} door {door.name}");
                }
                catch (Exception ex)
                {
                    _log.LogError("[BotDoorInteraction] Door interaction failed: " + ex);
                }

                _nextRetryTime = time + DoorRetryCooldown;
                _currentDoor = door;
                _doorStateSinceTime = time;
                IsBlockedByDoor = true;
            }
            catch
            {
                ClearDoorState();
            }
        }

        /// <summary>
        /// Returns true if the door is currently blocking a specific world position.
        /// </summary>
        public bool IsDoorBlocking(Vector3 position)
        {
            try
            {
                if (_currentDoor == null || !_currentDoor.enabled)
                    return false;
                float dist = Vector3.Distance(_currentDoor.transform.position, position);
                return dist < DoorCastRange && (_currentDoor.DoorState & EDoorState.Open) == 0;
            }
            catch { return false; }
        }

        /// <summary>
        /// Resets all internal door state (for retry, world reload, etc).
        /// </summary>
        public void Reset()
        {
            _currentDoor = null;
            IsBlockedByDoor = false;
            _nextRetryTime = 0f;
            _lastDoorCheckTime = 0f;
            _hesitateUntil = 0f;
            _giveUpUntil = 0f;
            _hasGivenUp = false;
            _doorStateSinceTime = 0f;
        }

        #endregion

        #region Private Helpers

        /// <summary>
        /// Clears internal door tracking state.
        /// </summary>
        private void ClearDoorState()
        {
            _currentDoor = null;
            IsBlockedByDoor = false;
            _hesitateUntil = 0f;
            _giveUpUntil = 0f;
            _hasGivenUp = false;
            _doorStateSinceTime = 0f;
        }

        /// <summary>
        /// Marks current door as blocking.
        /// </summary>
        private void MarkBlocked(Door door, float now)
        {
            if (door == null || Vector3.Distance(EFTPlayerUtil.GetPosition(_bot), door.transform.position) > DoorCastRange)
                return;

            _currentDoor = door;
            IsBlockedByDoor = true;
            _doorStateSinceTime = now;
        }

        /// <summary>
        /// Returns true if the bot should wait for other squadmates to clear a door.
        /// </summary>
        private bool ShouldWaitForSquad(Door door)
        {
            try
            {
                if (_bot?.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1)
                    return false;
                int waiting = 0;
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    BotOwner mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate.IsDead || mate == _bot)
                        continue;
                    float dist = Vector3.Distance(door.transform.position, mate.Position);
                    if (dist < SquadWaitRadius)
                        waiting++;
                    if (waiting > 2)
                        return true;
                }
                return false;
            }
            catch { return false; }
        }

        /// <summary>
        /// Returns best interaction type for a door state.
        /// </summary>
        private static EInteractionType GetBestInteractionType(EDoorState state)
        {
            if ((state & EDoorState.Shut) != 0 || state == EDoorState.None)
                return EInteractionType.Open;
            if ((state & EDoorState.Open) != 0)
                return EInteractionType.Close;
            return EInteractionType.Open;
        }

        #endregion
    }
}
