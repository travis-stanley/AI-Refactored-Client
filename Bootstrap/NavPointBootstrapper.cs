// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All failures are locally contained, never break other subsystems, and always trigger fallback isolation.
//   See: AIRefactored “Bulletproof Fallback & Isolation Safety Rule Set” for audit compliance.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
	using System;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using AIRefactored.AI.Core;
	using AIRefactored.Core;
	using AIRefactored.Pools;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using Unity.AI.Navigation;
	using UnityEngine;
	using UnityEngine.AI;

	/// <summary>
	/// Dynamically scans valid AI navigation points including cover, rooftop, flank, and fallback zones.
	/// Headless-safe, memory-safe, pooling enforced, and bulletproof isolation for runtime safety.
	/// </summary>
	public static class NavPointBootstrapper
	{
		#region Constants

		private const float ForwardCoverCheckDistance = 4.0f;
		private const float MaxSampleHeight = 4.0f;
		private const float MinNavPointClearance = 1.6f;
		private const float RoofRaycastHeight = 12.0f;
		private const float ScanRadius = 80.0f;
		private const float ScanSpacing = 2.5f;
		private const float VerticalProbeMax = 24.0f;
		private const float VerticalStep = 2.0f;

		#endregion

		#region State

		private static readonly List<Vector3> BackgroundPending = new List<Vector3>(1024);
		private static readonly Queue<Vector3> ScanQueue = new Queue<Vector3>(2048);
		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static Vector3 _center = Vector3.zero;
		private static bool _isRunning;
		private static bool _isTaskRunning;
		private static int _registered;
		private static string _mapId = string.Empty;
		private static bool _hasFailed;

		#endregion

		#region Public API

		/// <summary>
		/// Registers all navigation points for the given mapId.
		/// Bulletproof: Any error disables only this scan, never breaks system or cascades error.
		/// </summary>
		public static void RegisterAll(string mapId)
		{
			Reset();
			_mapId = mapId;
			_hasFailed = false;

			if (!GameWorldHandler.IsHost || !GameWorldHandler.IsInitialized)
			{
				Logger.LogWarning("[NavPointBootstrapper] Skipped — not host or world not initialized.");
				return;
			}

			try
			{
				if (NavPointCacheManager.TryLoad(mapId, out var cached))
				{
					for (int i = 0; i < cached.Count; i++)
					{
						var p = cached[i];
						NavPointRegistry.Register(p.Position, p.IsCover, p.Tag, p.Elevation, p.IsIndoor, p.IsJumpable, p.CoverAngle);
					}

					NavMeshStatus.SetReady();
					Logger.LogDebug("[NavPointBootstrapper] ✅ Loaded from cache: " + cached.Count + " points.");
					return;
				}
			}
			catch (Exception ex)
			{
				_hasFailed = true;
				Logger.LogError("[NavPointBootstrapper] Failed loading cache: " + ex);
				return;
			}

			_isRunning = true;
			_registered = 0;
			NavMeshStatus.Reset();

			NavMeshSurface[] surfaces = null;
			try
			{
				surfaces = UnityEngine.Object.FindObjectsOfType<NavMeshSurface>();
			}
			catch (Exception ex)
			{
				_hasFailed = true;
				Logger.LogError("[NavPointBootstrapper] Find NavMeshSurface failed: " + ex);
				_isRunning = false;
				return;
			}

			if (surfaces == null || surfaces.Length == 0)
			{
				Logger.LogWarning("[NavPointBootstrapper] No NavMeshSurface found.");
				_isRunning = false;
				return;
			}

			_center = surfaces[0].transform.position;
			float half = ScanRadius * 0.5f;

			List<Vector3> pooled = TempListPool.Rent<Vector3>();
			try
			{
				for (float x = -half; x <= half; x += ScanSpacing)
				{
					for (float z = -half; z <= half; z += ScanSpacing)
					{
						pooled.Add(new Vector3(x, MaxSampleHeight, z) + _center);
					}
				}

				for (int i = 0; i < pooled.Count; i++)
				{
					ScanQueue.Enqueue(pooled[i]);
				}
			}
			catch (Exception ex)
			{
				_hasFailed = true;
				Logger.LogError("[NavPointBootstrapper] Grid point prequeue failed: " + ex);
				_isRunning = false;
			}
			finally
			{
				TempListPool.Return(pooled);
			}

			Logger.LogDebug("[NavPointBootstrapper] Queued " + ScanQueue.Count + " surface points.");

			if (!_isTaskRunning)
			{
				_isTaskRunning = true;
				Task.Run(() =>
				{
					try { PrequeueVerticalPoints(); }
					catch (Exception ex) { Logger.LogError("[NavPointBootstrapper] Vertical prequeue error: " + ex); }
					finally { _isTaskRunning = false; }
				});
			}
		}

		/// <summary>
		/// Processes nav point scan queue in real-time. Bulletproof: all errors localized, no crashes.
		/// </summary>
		public static void Tick()
		{
			if (!_isRunning || !GameWorldHandler.IsHost || _hasFailed)
			{
				return;
			}

			try
			{
				int maxPerFrame = FikaHeadlessDetector.IsHeadless ? 80 : 40;
				int processed = 0;

				int rejectedRaycast = 0, rejectedNavmesh = 0, rejectedClearance = 0, rejectedCheckSphere = 0;

				while (ScanQueue.Count > 0 && processed++ < maxPerFrame)
				{
					Vector3 probe = ScanQueue.Dequeue();

					try
					{
						if (!Physics.Raycast(probe, Vector3.down, out RaycastHit hit, MaxSampleHeight))
						{
							if (++rejectedRaycast <= 10)
								Logger.LogWarning("[NavPointBootstrapper] Point rejected (raycast miss): " + probe + " (y=" + probe.y + ")");
							continue;
						}

						Vector3 pos = hit.point;

						if (!NavMesh.SamplePosition(pos, out NavMeshHit navHit, 2.5f, NavMesh.AllAreas))
						{
							if (++rejectedNavmesh <= 10)
								Logger.LogWarning("[NavPointBootstrapper] Point rejected (NavMesh.SamplePosition fail): " + pos);
							continue;
						}

						if (Physics.Raycast(pos + Vector3.up * 0.5f, Vector3.up, MinNavPointClearance))
						{
							if (++rejectedClearance <= 10)
								Logger.LogWarning("[NavPointBootstrapper] Point rejected (blocked above): " + pos);
							continue;
						}

						Vector3 final = navHit.position;
						float elevation = final.y - _center.y;
						bool isCover = IsCoverPoint(final);
						bool isIndoor = IsIndoorPoint(final);
						string tag = ClassifyNavPoint(elevation, isCover, isIndoor);
						float coverAngle = CalculateCoverAngle(final);

						if (!Physics.CheckSphere(final, 0.2f, AIRefactoredLayerMasks.TerrainAndObstacles))
						{
							if (++rejectedCheckSphere <= 10)
								Logger.LogWarning("[NavPointBootstrapper] Point rejected (CheckSphere failed TerrainAndObstacles): " + final);
							continue;
						}

						NavPointRegistry.Register(final, isCover, tag, elevation, isIndoor, true, coverAngle);
						_registered++;
					}
					catch (Exception ex)
					{
						Logger.LogError("[NavPointBootstrapper] ScanQueue processing error: " + ex);
						continue; // always localize error, continue scanning
					}
				}

				if (ScanQueue.Count == 0 && BackgroundPending.Count > 0)
				{
					lock (BackgroundPending)
					{
						for (int i = 0; i < BackgroundPending.Count; i++)
						{
							ScanQueue.Enqueue(BackgroundPending[i]);
						}
						BackgroundPending.Clear();
					}

					Logger.LogDebug("[NavPointBootstrapper] Queued vertical fallback points.");
				}

				if (ScanQueue.Count == 0 && !_isTaskRunning)
				{
					_isRunning = false;
					NavMeshStatus.SetReady();

					List<NavPointData> snapshot = null;
					try
					{
						snapshot = NavPointRegistry.QueryNearby(_center, ScanRadius, null);
						NavPointCacheManager.Save(_mapId, snapshot);
						Logger.LogDebug("[NavPointBootstrapper] ✅ Completed scan and cached " + (snapshot?.Count ?? 0) + " nav points. Total registered: " + _registered);
					}
					catch (Exception ex)
					{
						Logger.LogError("[NavPointBootstrapper] Snapshot/cache error: " + ex);
					}
					finally
					{
						if (snapshot != null)
						{
							TempListPool.Return(snapshot);
						}
					}
				}
			}
			catch (Exception ex)
			{
				_hasFailed = true;
				Logger.LogError("[NavPointBootstrapper] Tick() failed: " + ex);
				_isRunning = false;
			}
		}

		/// <summary>
		/// Resets the scan and clears all queued points and state.
		/// </summary>
		public static void Reset()
		{
			try
			{
				ScanQueue.Clear();
				BackgroundPending.Clear();
				_registered = 0;
				_isRunning = false;
				_isTaskRunning = false;
				_hasFailed = false;
				NavMeshStatus.Reset();
				_mapId = string.Empty;
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointBootstrapper] Reset() failed: " + ex);
			}
		}

		#endregion

		#region Internals

		private static void PrequeueVerticalPoints()
		{
			float half = ScanRadius * 0.5f;
			List<Vector3> tempList = TempListPool.Rent<Vector3>();

			try
			{
				for (float x = -half; x <= half; x += ScanSpacing)
				{
					for (float z = -half; z <= half; z += ScanSpacing)
					{
						for (float y = 5.0f; y <= VerticalProbeMax; y += VerticalStep)
						{
							tempList.Add(_center + new Vector3(x, y, z));
						}
					}
				}

				lock (BackgroundPending)
				{
					BackgroundPending.AddRange(tempList);
				}
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointBootstrapper] PrequeueVerticalPoints() failed: " + ex);
			}
			finally
			{
				TempListPool.Return(tempList);
			}
		}

		private static bool IsCoverPoint(Vector3 pos)
		{
			Vector3 eye = pos + Vector3.up * 1.4f;
			for (float angle = -45f; angle <= 45f; angle += 15f)
			{
				try
				{
					Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;
					if (Physics.Raycast(eye, dir, ForwardCoverCheckDistance, AIRefactoredLayerMasks.HighPolyCollider))
					{
						return true;
					}
				}
				catch (Exception ex)
				{
					Logger.LogError("[NavPointBootstrapper] IsCoverPoint() failed: " + ex);
				}
			}
			return false;
		}

		private static bool IsIndoorPoint(Vector3 pos)
		{
			try
			{
				return Physics.Raycast(pos + Vector3.up * 1.4f, Vector3.up, RoofRaycastHeight);
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointBootstrapper] IsIndoorPoint() failed: " + ex);
				return false;
			}
		}

		private static string ClassifyNavPoint(float elevation, bool isCover, bool isIndoor)
		{
			if (isIndoor) return "indoor";
			if (elevation > 6.0f) return "roof";
			return isCover ? "fallback" : "flank";
		}

		private static float CalculateCoverAngle(Vector3 pos)
		{
			Vector3 eye = pos + Vector3.up * 1.4f;
			for (float angle = -45f; angle <= 45f; angle += 15f)
			{
				try
				{
					Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;
					if (Physics.Raycast(eye, dir, ForwardCoverCheckDistance, AIRefactoredLayerMasks.HighPolyCollider))
					{
						return angle;
					}
				}
				catch (Exception ex)
				{
					Logger.LogError("[NavPointBootstrapper] CalculateCoverAngle() failed: " + ex);
				}
			}
			return 0f;
		}

		#endregion
	}
}
