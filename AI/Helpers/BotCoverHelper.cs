// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
//   Never block vanilla logic if registry is empty or disabled.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Utility for scoring, checking, and tracking tactical cover positions.
    /// Supports memory cooldown, real cover posture analysis, and multiplayer-safe validation.
    /// Bulletproof: errors are local and never break the bot or other systems.
    /// </summary>
    public static class BotCoverHelper
    {
        #region Constants

        private const float MemoryDuration = 20f;
        private const float MaxValidDistanceSqr = 16f;

        #endregion

        #region Static Memory

        // Covers are keyed by rounded position, with time-stamp.
        private static readonly Dictionary<string, float> CoverMemory = new Dictionary<string, float>(128);

        #endregion

        #region Cover Type Checks

        public static bool IsLowCover(CustomNavigationPoint point)
        {
            return point != null && point.CoverLevel == CoverLevel.Sit;
        }

        public static bool IsProneCover(CustomNavigationPoint point)
        {
            return point != null && point.CoverLevel == CoverLevel.Lay;
        }

        public static bool IsStandingCover(CustomNavigationPoint point)
        {
            return point != null && point.CoverLevel == CoverLevel.Stay;
        }

        public static bool IsLowCover(NavPointData point)
        {
            return point.IsCover && point.ElevationBand == "Mid";
        }

        public static bool IsProneCover(NavPointData point)
        {
            return point.IsCover && point.ElevationBand == "Low";
        }

        public static bool IsStandingCover(NavPointData point)
        {
            return point.IsCover && point.ElevationBand == "High";
        }

        #endregion

        #region Cover Memory Usage

        public static void MarkUsed(CustomNavigationPoint point)
        {
            if (point == null)
                return;
            MarkUsed(point.Position);
        }

        public static void MarkUsed(NavPointData point)
        {
            if (!IsValidPos(point.Position))
                return;
            MarkUsed(point.Position);
        }

        public static void MarkUsed(Vector3 position)
        {
            if (!IsValidPos(position))
                return;
            try
            {
                string key = GetKey(position);
                if (!string.IsNullOrEmpty(key))
                    CoverMemory[key] = Time.time;
            }
            catch
            {
                // Ignore, never break bot logic
            }
        }

        public static bool WasRecentlyUsed(CustomNavigationPoint point)
        {
            return point != null && WasRecentlyUsed(point.Position);
        }

        public static bool WasRecentlyUsed(NavPointData point)
        {
            return WasRecentlyUsed(point.Position);
        }

        public static bool WasRecentlyUsed(Vector3 position)
        {
            try
            {
                string key = GetKey(position);
                return CoverMemory.TryGetValue(key, out float last) && (Time.time - last) < MemoryDuration;
            }
            catch
            {
                return false;
            }
        }

        #endregion

        #region Pose Application

        public static void TrySetStanceFromNearbyCover(BotComponentCache cache, Vector3 position)
        {
            if (cache?.PoseController == null)
                return;

            if (!NavPointRegistry.IsReady || NavPointRegistry.IsEmpty)
                return;

            try
            {
                BotPoseController controller = cache.PoseController;
                List<NavPointData> points = NavPointRegistry.QueryNearby(position, 4f, null);

                for (int i = 0; i < points.Count; i++)
                {
                    NavPointData point = points[i];
                    if (!point.IsCover)
                        continue;

                    if ((point.Position - position).sqrMagnitude > MaxValidDistanceSqr)
                        continue;

                    if (IsProneCover(point))
                    {
                        controller.SetProne(true);
                        return;
                    }

                    if (IsLowCover(point))
                    {
                        controller.SetCrouch(true);
                        return;
                    }
                }
            }
            catch
            {
                // Never break bot logic if registry or posture fails
            }
        }

        #endregion

        #region Cover Scoring

        public static float Score(CustomNavigationPoint point, Vector3 botPos, Vector3 threatPos)
        {
            if (point == null) return 0f;
            try
            {
                float distBot = Vector3.Distance(botPos, point.Position);
                float distThreat = Vector3.Distance(threatPos, point.Position);
                float angle = Vector3.Angle(threatPos - point.Position, botPos - point.Position);

                float bonus = 0.5f;
                if (IsProneCover(point)) bonus = 1.25f;
                else if (IsLowCover(point)) bonus = 1.0f;
                else if (IsStandingCover(point)) bonus = 0.85f;

                float threatFactor = Mathf.Clamp01(distThreat / 20f);
                float angleFactor = Mathf.Clamp01(angle / 180f);

                return (bonus + threatFactor + angleFactor) / (1f + distBot * 0.15f);
            }
            catch
            {
                return 0f;
            }
        }

        public static float Score(NavPointData point, Vector3 botPos, Vector3 threatPos)
        {
            try
            {
                float distBot = Vector3.Distance(botPos, point.Position);
                float distThreat = Vector3.Distance(threatPos, point.Position);
                float angle = Vector3.Angle(threatPos - point.Position, botPos - point.Position);

                float bonus = 0.5f;
                if (IsProneCover(point)) bonus = 1.25f;
                else if (IsLowCover(point)) bonus = 1.0f;
                else if (IsStandingCover(point)) bonus = 0.85f;

                float threatFactor = Mathf.Clamp01(distThreat / 20f);
                float angleFactor = Mathf.Clamp01(angle / 180f);

                return (bonus + threatFactor + angleFactor) / (1f + distBot * 0.15f);
            }
            catch
            {
                return 0f;
            }
        }

        #endregion

        #region Cover Validation

        public static bool IsValidCoverPoint(CustomNavigationPoint point, BotOwner bot, bool requireFree, bool preferIndoor)
        {
            try
            {
                if (point == null || bot == null)
                    return false;

                if (requireFree && !point.IsFreeById(bot.Id))
                    return false;

                if (point.IsSpotted)
                    return false;

                if (preferIndoor && !point.IsGoodInsideBuilding)
                    return false;

                return true;
            }
            catch
            {
                return false;
            }
        }

        #endregion

        #region Internal Helpers

        private static string GetKey(Vector3 position)
        {
            int x = Mathf.RoundToInt(position.x);
            int y = Mathf.RoundToInt(position.y);
            int z = Mathf.RoundToInt(position.z);
            return $"{x}_{y}_{z}";
        }

        private static bool IsValidPos(Vector3 pos)
        {
            return pos != Vector3.zero && !float.IsNaN(pos.x) && !float.IsNaN(pos.y) && !float.IsNaN(pos.z);
        }

        #endregion
    }
}
