// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Scans for edges and corners to trigger realistic lean, crouch, or pause behavior.
    /// Aggressive bots peek corners quickly, cautious bots crouch before engaging.
    /// </summary>
    public sealed class BotCornerScanner
    {
        #region Constants

        private const float BasePauseDuration = 0.4f;
        private const float BaseWallCheckDistance = 1.5f;
        private const float EdgeCheckDistance = 1.25f;
        private const float EdgeRaySpacing = 0.25f;
        private const float MinFallHeight = 2.2f;
        private const float PrepCrouchTime = 0.75f;
        private const float WallAngleThreshold = 0.7f;
        private const float WallCheckHeight = 1.5f;
        private const float NavSampleTolerance = 0.65f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Log = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotPersonalityProfile _profile;

        private float _pauseUntil;
        private float _prepCrouchUntil;

        private bool _isLeaning;
        private bool _isCrouching;
        private bool _isInitialized;

        #endregion

        #region Constructors

        public BotCornerScanner() { }

        public BotCornerScanner(BotOwner bot, BotComponentCache cache)
        {
            try
            {
                Initialize(bot, cache);
            }
            catch (Exception ex)
            {
                Log.LogError("[BotCornerScanner] Constructor init failed: " + ex);
            }
        }

        #endregion

        #region Initialization

        public void Initialize(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null || bot.Transform == null)
            {
                Log.LogWarning("[BotCornerScanner] Initialization skipped — invalid bot or transform.");
                return;
            }

            BotPersonalityProfile profile = cache.AIRefactoredBotOwner?.PersonalityProfile;
            if (profile == null)
            {
                Log.LogWarning("[BotCornerScanner] Initialization failed — missing personality for bot " + bot.ProfileId);
                return;
            }

            _bot = bot;
            _cache = cache;
            _profile = profile;
            _isInitialized = true;
        }

        #endregion

        #region Public API

        public void Tick(float time)
        {
            if (!_isInitialized || _bot == null || _cache == null || _profile == null)
            {
                return;
            }

            if (_bot.IsDead || _bot.Mover == null || _bot.Transform == null)
            {
                return;
            }

            if (_cache.Tilt == null || _cache.PoseController == null)
            {
                return;
            }

            if (_bot.Memory != null && _bot.Memory.GoalEnemy != null)
            {
                return;
            }

            if (time < _pauseUntil || time < _prepCrouchUntil)
            {
                return;
            }

            if (IsApproachingEdge())
            {
                PauseMovement(time);
                return;
            }

            if (TryCornerPeekWithCrouch(time))
            {
                return;
            }

            ResetLean(time);
        }

        #endregion

        #region Edge + Corner Logic

        private bool IsApproachingEdge()
        {
            Vector3 origin = _bot.Position + Vector3.up * 0.2f;
            Vector3 forward = _bot.Transform.forward;
            Vector3 right = _bot.Transform.right;

            int rays = Mathf.CeilToInt((EdgeCheckDistance * 2f) / EdgeRaySpacing);

            for (int i = 0; i < rays; i++)
            {
                float offset = (i - (rays * 0.5f)) * EdgeRaySpacing;
                Vector3 rayOrigin = origin + (right * offset) + (forward * EdgeCheckDistance);
                Vector3 rayDown = rayOrigin + Vector3.down * MinFallHeight;

                if (!Physics.Raycast(rayOrigin, Vector3.down, MinFallHeight, AIRefactoredLayerMasks.NavObstacleMask))
                {
                    if (!NavMesh.SamplePosition(rayDown, out NavMeshHit hit, 1.0f, NavMesh.AllAreas) || hit.distance > NavSampleTolerance)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool TryCornerPeekWithCrouch(float time)
        {
            Vector3 origin = _bot.Position + Vector3.up * WallCheckHeight;
            Vector3 right = _bot.Transform.right;
            Vector3 left = -right;
            float dist = BaseWallCheckDistance + ((1f - _profile.Caution) * 0.5f);

            if (CheckWall(origin, left, dist))
            {
                return TriggerLeanOrCrouch(BotTiltType.left, time);
            }

            if (CheckWall(origin, right, dist))
            {
                return TriggerLeanOrCrouch(BotTiltType.right, time);
            }

            return false;
        }

        private bool CheckWall(Vector3 origin, Vector3 dir, float dist)
        {
            if (!Physics.Raycast(origin, dir, out RaycastHit hit, dist, AIRefactoredLayerMasks.CoverRayMask))
            {
                return false;
            }

            return Vector3.Dot(hit.normal, dir) < WallAngleThreshold;
        }

        private bool TriggerLeanOrCrouch(BotTiltType side, float time)
        {
            if (!_isCrouching && AttemptCrouch(time))
            {
                _isCrouching = true;
                return true;
            }

            if (!_isLeaning)
            {
                _cache.Tilt.Set(side);
                PauseMovement(time);
                _isLeaning = true;
            }

            return true;
        }

        private bool AttemptCrouch(float time)
        {
            if (_cache.PoseController.GetPoseLevel() > 30f)
            {
                _cache.PoseController.SetCrouch();
                _prepCrouchUntil = time + PrepCrouchTime;
                return true;
            }

            return false;
        }

        #endregion

        #region Helpers

        private void PauseMovement(float time)
        {
            float duration = BasePauseDuration * Mathf.Clamp(0.5f + _profile.Caution, 0.35f, 2.0f);
            _bot.Mover.MovementPause(duration);
            _pauseUntil = time + duration;
        }

        private void ResetLean(float time)
        {
            if (_cache.Tilt != null && _cache.Tilt._coreTilt)
            {
                _cache.Tilt.tiltOff = time - 1f;
                _cache.Tilt.ManualUpdate();
            }

            _isLeaning = false;
            _isCrouching = false;
        }

        #endregion
    }
}
