// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.InventoryLogic;
    using UnityEngine;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Controls and manages tactical device toggling for bot AI:
    /// Flashlights, lasers, NVGs, and thermals.
    /// Handles ambient/fog-based logic and chaos-driven baiting,
    /// ensuring full headless and multiplayer safety.
    /// </summary>
    public sealed class BotTacticalDeviceController
    {
        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _nextDecisionTime;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the controller for the provided bot component cache.
        /// </summary>
        /// <param name="cache">The bot's runtime component cache.</param>
        /// <exception cref="ArgumentNullException">Thrown if cache or cache.Bot is null.</exception>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
            {
                throw new ArgumentNullException(nameof(cache), "BotComponentCache and Bot must not be null.");
            }

            _bot = cache.Bot;
            _cache = cache;
            _nextDecisionTime = 0f;
        }

        #endregion

        #region Tick

        /// <summary>
        /// Updates tactical device logic. Must be called every frame by BotBrain.
        /// Fully allocation- and null-safe, with pooling and headless/multiplayer support.
        /// </summary>
        public void Tick()
        {
            if (!CanThink())
            {
                return;
            }

            _nextDecisionTime = Time.time + TacticalConfig.CheckInterval;

            Weapon weapon = _bot.WeaponManager != null ? _bot.WeaponManager.CurrentWeapon : null;
            if (weapon == null)
            {
                return;
            }

            List<LightComponent> devices = TempListPool.Rent<LightComponent>();
            try
            {
                ScanModsForTacticalDevices(weapon, devices);

                bool isLowVisibility = IsLowVisibility();
                float chaosChance = GetChaosBaitChance();
                bool baitTrigger = Random.value < chaosChance;
                bool shouldEnable = isLowVisibility || baitTrigger;

                for (int i = 0, count = devices.Count; i < count; i++)
                {
                    LightComponent device = devices[i];
                    if (device != null && device.IsActive != shouldEnable)
                    {
                        device.IsActive = shouldEnable;
                    }
                }

                // If chaos bait is triggered, flash the lights briefly, then force-off for bait
                if (baitTrigger)
                {
                    _nextDecisionTime = Time.time + 1.5f;
                    for (int i = 0, count = devices.Count; i < count; i++)
                    {
                        LightComponent device = devices[i];
                        if (device != null)
                        {
                            device.IsActive = false;
                        }
                    }
                }
            }
            finally
            {
                TempListPool.Return(devices);
            }
        }

        #endregion

        #region Logic

        /// <summary>
        /// Determines if tactical device logic should run this frame.
        /// </summary>
        private bool CanThink()
        {
            return _bot != null
                   && _cache != null
                   && !_bot.IsDead
                   && Time.time >= _nextDecisionTime
                   && EFTPlayerUtil.IsValid(_bot.GetPlayer)
                   && _bot.GetPlayer.IsAI;
        }

        /// <summary>
        /// Computes bait/chaos chance from the bot's personality.
        /// </summary>
        private float GetChaosBaitChance()
        {
            var owner = _cache.AIRefactoredBotOwner;
            if (owner == null)
            {
                return 0f;
            }

            BotPersonalityProfile profile = owner.PersonalityProfile;
            return profile != null ? profile.ChaosFactor * 0.25f : 0f;
        }

        /// <summary>
        /// Returns true if the environment is considered low-visibility.
        /// </summary>
        private static bool IsLowVisibility()
        {
            float ambient = RenderSettings.ambientLight.grayscale;
            float fogDensity = RenderSettings.fog ? RenderSettings.fogDensity : 0f;
            return ambient < TacticalConfig.LightThreshold || fogDensity > TacticalConfig.FogThreshold;
        }

        /// <summary>
        /// Adds all valid tactical devices on the weapon to the result list.
        /// </summary>
        private static void ScanModsForTacticalDevices(Weapon weapon, List<LightComponent> result)
        {
            var slots = weapon.AllSlots;
            if (slots == null)
            {
                return;
            }

            foreach (Slot slot in slots)
            {
                if (slot == null)
                {
                    continue;
                }

                Item mod = slot.ContainedItem;
                if (mod == null || mod.Template == null)
                {
                    continue;
                }

                string name = mod.Template.Name?.ToLowerInvariant();
                if (string.IsNullOrEmpty(name) || !IsTacticalName(name))
                {
                    continue;
                }

                if (mod is FlashlightItemClass flash && flash.Light != null)
                {
                    result.Add(flash.Light);
                }
                else if (mod is TacticalComboItemClass combo && combo.Light != null)
                {
                    result.Add(combo.Light);
                }
                else if (mod is LightLaserItemClass laser && laser.Light != null)
                {
                    result.Add(laser.Light);
                }
            }
        }

        /// <summary>
        /// Checks if the mod name contains tactical keywords.
        /// </summary>
        private static bool IsTacticalName(string name)
        {
            var keywords = TacticalConfig.Keywords;
            for (int i = 0, count = keywords.Length; i < count; i++)
            {
                if (name.Contains(keywords[i]))
                {
                    return true;
                }
            }

            return false;
        }

        #endregion

        #region TacticalConfig

        /// <summary>
        /// Static tactical device config for thresholds and keywords.
        /// </summary>
        private static class TacticalConfig
        {
            public const float CheckInterval = 2.0f;
            public const float FogThreshold = 0.5f;
            public const float LightThreshold = 0.3f;

            public static readonly string[] Keywords = { "light", "laser", "nvg", "thermal", "flash" };
        }

        #endregion
    }
}
