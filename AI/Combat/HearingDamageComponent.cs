// <auto-generated>
//   AI-Refactored: HearingDamageComponent.cs (Max Realism Edition)
//   Ear fatigue, nonlinear ringing, self-healing, no allocations, bulletproof error handling.
//   Licensed under MIT.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using UnityEngine;

    /// <summary>
    /// Simulates realistic bot hearing loss and recovery after loud events (gunfire, grenades, etc).
    /// Nonlinear fatigue and ear ringing, ultra-robust, cannot fail or propagate errors.
    /// Fully bulletproof: always self-healing, zero allocations, never disables parent system.
    /// </summary>
    public sealed class HearingDamageComponent
    {
        #region Fields

        private float _targetDeafness;      // Intensity to fade from (0..1)
        private float _deafnessLevel;       // Current deafness level (0..1)
        private float _deafDuration;        // Duration of deafness (s)
        private float _elapsedTime;         // Elapsed time since start (s)
        private float _recoverySlope;       // Controls nonlinear recovery
        private float _lastApplyTime;       // Time of last deafness event
        private float _earFatigue;          // Cumulative fatigue from recent events (0..1)

        #endregion

        #region Properties

        /// <summary>
        /// Gets the current deafness intensity (0..1).
        /// </summary>
        public float Deafness => _deafnessLevel;

        /// <summary>
        /// Returns true if the bot is currently affected by deafness.
        /// </summary>
        public bool IsDeafened => _deafnessLevel > 0.08f;

        /// <summary>
        /// Gets the remaining deafness duration in seconds.
        /// </summary>
        public float RemainingTime => Mathf.Max(_deafDuration - _elapsedTime, 0f);

        /// <summary>
        /// Gets the cumulative ear fatigue level (0..1). Increases with repeated deafness events.
        /// </summary>
        public float EarFatigue => _earFatigue;

        #endregion

        #region Public Methods

        /// <summary>
        /// Applies a new deafness effect. Intensity and duration are automatically combined with current effects
        /// to prevent "popping" between deafness levels. Multiple rapid events build up fatigue.
        /// </summary>
        public void ApplyDeafness(float intensity, float duration)
        {
            try
            {
                float newIntensity = Mathf.Clamp01(intensity);
                float newDuration = Mathf.Max(duration, 0.1f);
                float now = Time.time;
                float fatigueDecay = 0.23f;

                // Fatigue increases if events stack up in short time
                if (now - _lastApplyTime < 3.8f)
                    _earFatigue = Mathf.Clamp01(_earFatigue + newIntensity * 0.35f);
                else
                    _earFatigue = Mathf.Clamp01(_earFatigue - fatigueDecay * (now - _lastApplyTime) / 8.0f);

                _lastApplyTime = now;

                // Increase duration and intensity if stronger or stacking
                if (newIntensity > _targetDeafness ||
                    (Mathf.Approximately(newIntensity, _targetDeafness) && newDuration > RemainingTime))
                {
                    _targetDeafness = Mathf.Clamp01(newIntensity + _earFatigue * 0.3f);
                    _deafDuration = newDuration + _earFatigue * 1.1f;
                    _elapsedTime = 0f;
                    _deafnessLevel = _targetDeafness;
                    _recoverySlope = 1.5f + 2.5f * _targetDeafness + (_earFatigue * 1.8f);
                }
            }
            catch
            {
                Clear();
            }
        }

        /// <summary>
        /// Clears all deafness and fatigue immediately.
        /// </summary>
        public void Clear()
        {
            _targetDeafness = 0f;
            _deafnessLevel = 0f;
            _deafDuration = 0f;
            _elapsedTime = 0f;
            _recoverySlope = 2f;
            _lastApplyTime = 0f;
            _earFatigue = 0f;
        }

        /// <summary>
        /// Updates deafness over time. Nonlinear fade simulates human ear recovery (slow at first, then fast).
        /// Call every frame. Bulletproof, cannot break, always self-healing.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_targetDeafness <= 0.01f || _deafDuration <= 0f)
                {
                    Clear();
                    return;
                }

                _elapsedTime += Mathf.Max(0f, deltaTime);

                if (_elapsedTime >= _deafDuration)
                {
                    Clear();
                    return;
                }

                // Fatigue decays very slowly over time
                if (_earFatigue > 0.01f)
                    _earFatigue = Mathf.Clamp01(_earFatigue - deltaTime * 0.025f);

                float t = Mathf.Clamp01(_elapsedTime / _deafDuration);
                float recovery = 1f - Mathf.Pow(1f - t, _recoverySlope);
                _deafnessLevel = Mathf.Lerp(_targetDeafness, 0f, recovery);

                // Clamp to zero if nearly recovered
                if (_deafnessLevel < 0.01f)
                {
                    Clear();
                }
            }
            catch
            {
                Clear(); // Fail-safe: never propagate errors
            }
        }

        #endregion
    }
}
