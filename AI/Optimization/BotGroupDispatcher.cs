// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All threading and background logic is bulletproof and fully isolated. Realism Pass: thread-batch micro-variance, job isolation, domain reload safety.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
	using System;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using AIRefactored.AI.Core;
	using AIRefactored.Core;
	using AIRefactored.Pools;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using UnityEngine;

	/// <summary>
	/// Schedules and dispatches thread-safe bot workloads during headless or client-hosted execution.
	/// All failures are strictly isolated to the affected job; the system cannot break, hang, or leak.
	/// </summary>
	public static class BotWorkGroupDispatcher
	{
		#region Constants

		private const int MaxWorkPerTick = 256;
		private const int MaxThreads = 16;
		private const float ThreadVariance = 0.08f; // 8% micro-randomization for realism

		#endregion

		#region Fields

		private static readonly object Sync = new object();
		private static readonly ManualLogSource Log = Plugin.LoggerInstance;
		private static readonly List<IBotWorkload> WorkQueue = new List<IBotWorkload>(MaxWorkPerTick);
		private static int ThreadCount => Mathf.Clamp((int)(Environment.ProcessorCount * (1f + UnityEngine.Random.Range(-ThreadVariance, ThreadVariance))), 1, MaxThreads);

		#endregion

		#region Public API

		/// <summary>
		/// Queues a bot workload for background execution.
		/// Errors in queueing never break dispatcher.
		/// </summary>
		/// <param name="workload">The workload to execute.</param>
		public static void Schedule(IBotWorkload workload)
		{
			try
			{
				if (workload == null)
					return;

				lock (Sync)
				{
					if (WorkQueue.Count >= MaxWorkPerTick)
					{
						LogIfNotHeadless("[BotWorkGroupDispatcher] Max queue capacity reached. Dropping workload.");
						return;
					}

					WorkQueue.Add(workload);
				}
			}
			catch (Exception ex)
			{
				LogIfNotHeadless("[BotWorkGroupDispatcher] Schedule() error: " + ex, true);
			}
		}

		/// <summary>
		/// Executes queued workloads in thread batches. Call from Update().
		/// All errors are contained and never propagate.
		/// </summary>
		public static void Tick()
		{
			try
			{
				if (!GameWorldHandler.IsLocalHost())
					return;

				List<IBotWorkload> batch = null;

				lock (Sync)
				{
					if (WorkQueue.Count == 0)
						return;

					int count = Mathf.Min(WorkQueue.Count, MaxWorkPerTick);
					batch = TempListPool.Rent<IBotWorkload>();
					for (int i = 0; i < count; i++)
						batch.Add(WorkQueue[i]);
					WorkQueue.RemoveRange(0, count);
				}

				try
				{
					Dispatch(batch);
				}
				catch (Exception ex)
				{
					LogIfNotHeadless("[BotWorkGroupDispatcher] Dispatch() error: " + ex, true);
				}
				finally
				{
					TempListPool.Return(batch);
				}
			}
			catch (Exception ex)
			{
				LogIfNotHeadless("[BotWorkGroupDispatcher] Tick() error: " + ex, true);
			}
		}

		/// <summary>
		/// Call on domain reload/hot-reload to clear all static state.
		/// </summary>
		public static void ClearAll()
		{
			lock (Sync)
			{
				WorkQueue.Clear();
			}
		}

		#endregion

		#region Dispatch

		private static void Dispatch(List<IBotWorkload> batch)
		{
			if (batch == null || batch.Count == 0)
				return;

			try
			{
				int total = batch.Count;
				int threads = Mathf.Clamp(ThreadCount, 1, total);
				int blockSize = Mathf.CeilToInt(total / (float)threads);

				for (int t = 0; t < threads; t++)
				{
					int start = t * blockSize;
					if (start >= total)
						break;

					int end = Mathf.Min(start + blockSize, total);

					// Local copy for closure safety
					int localStart = start;
					int localEnd = end;

					Task.Run(() =>
					{
						for (int i = localStart; i < localEnd; i++)
						{
							IBotWorkload job = null;
							try
							{
								job = batch[i];
							}
							catch
							{
								// Defensive: batch access error, skip
								continue;
							}

							if (job == null)
								continue;

							try
							{
								job.RunBackgroundWork();
							}
							catch (Exception ex)
							{
								LogIfNotHeadless("[BotWorkGroupDispatcher] Background workload exception:\n" + ex, false);
							}
						}
					});
				}
			}
			catch (Exception ex)
			{
				LogIfNotHeadless("[BotWorkGroupDispatcher] Dispatch() error: " + ex, true);
			}
		}

		#endregion

		#region Logging

		private static void LogIfNotHeadless(string msg, bool error = false)
		{
			if (FikaHeadlessDetector.IsHeadless)
				return;

			if (error)
				Log.LogError(msg);
			else
				Log.LogWarning(msg);
		}

		#endregion
	}

	/// <summary>
	/// Background-safe interface for threaded bot logic. Must not use Unity APIs.
	/// </summary>
	public interface IBotWorkload
	{
		/// <summary>
		/// Executes the workload from a thread pool context.
		/// All errors are strictly isolated to this job instance.
		/// </summary>
		void RunBackgroundWork();
	}
}
