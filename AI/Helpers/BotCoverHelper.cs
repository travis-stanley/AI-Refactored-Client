// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Utility for scoring, checking, and tracking tactical cover positions.
    /// Supports memory cooldown, real cover posture analysis, and multiplayer-safe validation.
    /// </summary>
    public static class BotCoverHelper
    {
        #region Constants

        private const float MemoryDuration = 20f;
        private const float MaxValidDistanceSqr = 16f;

        #endregion

        #region Static Memory

        private static readonly Dictionary<string, float> CoverMemory = new Dictionary<string, float>(128);

        #endregion

        #region Cover Type Checks

        public static bool IsLowCover(CustomNavigationPoint point) => point != null && point.CoverLevel == CoverLevel.Sit;

        public static bool IsProneCover(CustomNavigationPoint point) => point != null && point.CoverLevel == CoverLevel.Lay;

        public static bool IsStandingCover(CustomNavigationPoint point) => point != null && point.CoverLevel == CoverLevel.Stay;

        public static bool IsLowCover(NavPointData point) => point.IsCover && point.ElevationBand == "Mid";

        public static bool IsProneCover(NavPointData point) => point.IsCover && point.ElevationBand == "Low";

        public static bool IsStandingCover(NavPointData point) => point.IsCover && point.ElevationBand == "High";

        #endregion

        #region Cover Memory Usage

        public static void MarkUsed(CustomNavigationPoint point)
        {
            if (point != null)
            {
                CoverMemory[GetKey(point.Position)] = Time.time;
            }
        }

        public static void MarkUsed(NavPointData point)
        {
            CoverMemory[GetKey(point.Position)] = Time.time;
        }

        public static void MarkUsed(Vector3 position)
        {
            CoverMemory[GetKey(position)] = Time.time;
        }

        public static bool WasRecentlyUsed(CustomNavigationPoint point)
        {
            return point != null && WasRecentlyUsed(point.Position);
        }

        public static bool WasRecentlyUsed(NavPointData point)
        {
            return WasRecentlyUsed(point.Position);
        }

        public static bool WasRecentlyUsed(Vector3 position)
        {
            string key = GetKey(position);
            return CoverMemory.TryGetValue(key, out float last) && (Time.time - last) < MemoryDuration;
        }

        #endregion

        #region Pose Application

        public static void TrySetStanceFromNearbyCover(BotComponentCache cache, Vector3 position)
        {
            if (cache?.PoseController == null)
                return;

            if (!NavPointRegistry.IsReady || NavPointRegistry.IsEmpty)
                return;

            BotPoseController controller = cache.PoseController;
            List<NavPointData> points = NavPointRegistry.QueryNearby(position, 4f, null);

            for (int i = 0; i < points.Count; i++)
            {
                NavPointData point = points[i];
                if (!point.IsCover)
                    continue;

                if ((point.Position - position).sqrMagnitude > MaxValidDistanceSqr)
                    continue;

                if (IsProneCover(point))
                {
                    controller.SetProne(true);
                    return;
                }

                if (IsLowCover(point))
                {
                    controller.SetCrouch(true);
                    return;
                }
            }
        }

        #endregion

        #region Cover Scoring

        public static float Score(CustomNavigationPoint point, Vector3 botPos, Vector3 threatPos)
        {
            float distBot = Vector3.Distance(botPos, point.Position);
            float distThreat = Vector3.Distance(threatPos, point.Position);
            float angle = Vector3.Angle(threatPos - point.Position, botPos - point.Position);

            float bonus = 0.5f;
            if (IsProneCover(point)) bonus = 1.25f;
            else if (IsLowCover(point)) bonus = 1.0f;
            else if (IsStandingCover(point)) bonus = 0.85f;

            float threatFactor = Mathf.Clamp01(distThreat / 20f);
            float angleFactor = Mathf.Clamp01(angle / 180f);

            return (bonus + threatFactor + angleFactor) / (1f + distBot * 0.15f);
        }

        public static float Score(NavPointData point, Vector3 botPos, Vector3 threatPos)
        {
            float distBot = Vector3.Distance(botPos, point.Position);
            float distThreat = Vector3.Distance(threatPos, point.Position);
            float angle = Vector3.Angle(threatPos - point.Position, botPos - point.Position);

            float bonus = 0.5f;
            if (IsProneCover(point)) bonus = 1.25f;
            else if (IsLowCover(point)) bonus = 1.0f;
            else if (IsStandingCover(point)) bonus = 0.85f;

            float threatFactor = Mathf.Clamp01(distThreat / 20f);
            float angleFactor = Mathf.Clamp01(angle / 180f);

            return (bonus + threatFactor + angleFactor) / (1f + distBot * 0.15f);
        }

        #endregion

        #region Cover Validation

        public static bool IsValidCoverPoint(CustomNavigationPoint point, BotOwner bot, bool requireFree, bool preferIndoor)
        {
            if (point == null || bot == null)
                return false;

            if (requireFree && !point.IsFreeById(bot.Id))
                return false;

            if (point.IsSpotted)
                return false;

            if (preferIndoor && !point.IsGoodInsideBuilding)
                return false;

            return true;
        }

        #endregion

        #region Internal Helpers

        private static string GetKey(Vector3 position)
        {
            int x = Mathf.RoundToInt(position.x);
            int y = Mathf.RoundToInt(position.y);
            int z = Mathf.RoundToInt(position.z);
            return $"{x}_{y}_{z}";
        }

        #endregion
    }
}
