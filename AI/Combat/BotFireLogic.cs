// <auto-generated>
//   AI-Refactored: BotFireLogic.cs (Ultimate Realism – Maximum Expansion)
//   The most complete, feature-rich, and realism-tuned weapon fire, aim, and engagement logic possible for EFT AI.
//   All parameters are surfaced, every branch is maximized for immersion, squad, and error handling.
//   Licensed under MIT.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.HealthSystem;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Controls weapon fire, aiming, and recoil simulation for AI bots.
    /// Integrates suppression, panic, squad comms, role leadership, emotional contagion, micro-jitter,
    /// realistic misses, dynamic body/bone targeting, cover anticipation, hesitation, 
    /// voice lines, and error isolation. 
    /// All failures are locally isolated. All behaviors are multiplayer and headless safe.
    /// </summary>
    public sealed class BotFireLogic
    {
        #region Constants & Static Tables

        private const float MaxAimPitch = 70f;
        private const float MaxHumanRecoilAngle = 12f;
        private const float MaxMissAngle = 7.2f;
        private const float AimDriftMagnitude = 0.18f;
        private const float MinBurstCadence = 0.15f;
        private const float MaxBurstCadence = 1.2f;
        private const float SuppressionPanicMissPenalty = 1.1f;
        private const float PanicFireChanceReduction = 0.35f;
        private const float PanicMisfireChance = 0.08f;
        private const float SquadFireEchoChance = 0.22f;
        private const float FriendlyFirePreventionAngle = 11.5f;

        private static readonly EBodyPart[] AllBodyParts = (EBodyPart[])Enum.GetValues(typeof(EBodyPart));
        private static readonly PlayerBoneType[] PreferredBones =
        {
            PlayerBoneType.Head, PlayerBoneType.Ribcage, PlayerBoneType.Spine, PlayerBoneType.LeftShoulder,
            PlayerBoneType.RightShoulder, PlayerBoneType.Pelvis, PlayerBoneType.LeftThigh1, PlayerBoneType.RightThigh1
        };

        private static readonly Dictionary<string, float> WeaponTypeRanges = new Dictionary<string, float>(StringComparer.OrdinalIgnoreCase)
        {
            { "sniper", 180f }, { "marksman", 150f }, { "rifle", 120f }, { "assault", 100f },
            { "smg", 75f }, { "shotgun", 50f }, { "pistol", 35f }
        };

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _idleLookDirection = Vector3.forward;
        private float _lastLookAroundTime;
        private float _nextDecisionTime;
        private float _nextFireTime;

        // Configurable for profile/environmental tuning (can expose via BotPersonalityProfile later)
        private float _panicVoiceChance = 0.17f;
        private float _voiceCalloutMinInterval = 2.2f;
        private float _voiceCalloutMaxInterval = 7.5f;
        private float _lastVoiceCalloutTime = -10f;

        #endregion

        #region Construction

        /// <summary>
        /// Construct a new BotFireLogic system for the given bot and cache.
        /// </summary>
        public BotFireLogic(BotOwner bot, BotComponentCache cache)
        {
            _bot = bot ?? throw new ArgumentNullException(nameof(bot));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
        }

        #endregion

        #region Public API

        /// <summary>
        /// Update fire and aim logic. Called every frame from BotBrain.
        /// </summary>
        public void Tick(float time)
        {
            if (_bot.IsDead || !_bot.IsAI || _bot.Memory == null)
                return;

            try
            {
                var weaponManager = _bot.WeaponManager;
                var shootData = _bot.ShootData;
                var weaponInfo = weaponManager?._currentWeaponInfo;
                var weapon = weaponInfo?.weapon;
                var settings = _bot.Settings?.FileSettings?.Core;
                var profile = _cache.AIRefactoredBotOwner?.PersonalityProfile;

                if (weaponManager == null || shootData == null || weaponInfo == null || weapon == null || settings == null || profile == null)
                    return;

                if (!TryResolveEnemy(out Player target))
                    return;

                // Voice/Panic Callout (dynamic interval, rarely triggers)
                TryVoicePanicOrCallout(profile, time);

                Vector3 aimPosition = GetHumanizedAimPosition(target, time, profile);
                UpdateBotAiming(aimPosition, profile, time);

                if (!EFTPlayerUtil.IsValid(target))
                    return;

                float distance = Vector3.Distance(_bot.Position, aimPosition);
                float weaponRange = EstimateWeaponRange(weapon);
                float maxRange = Mathf.Min(profile.EngagementRange, weaponRange, 200f);

                // Squad/leadership: Only leaders are allowed to call out "push" orders
                if (_cache.GroupBehavior != null && _cache.GroupBehavior.IsLeader &&
                    distance > 28f && UnityEngine.Random.value < 0.25f && time - _lastVoiceCalloutTime > _voiceCalloutMinInterval)
                {
                    _bot.BotTalk?.TrySay(EPhraseTrigger.CoverMe);
                    _lastVoiceCalloutTime = time + UnityEngine.Random.Range(_voiceCalloutMinInterval, _voiceCalloutMaxInterval);
                }

                // Panic: bots in deep panic randomly abort firing even with line of sight
                if (_cache.PanicHandler?.IsPanicking == true && UnityEngine.Random.value < PanicMisfireChance)
                {
                    // May abort shooting for this frame
                    if (profile != null && UnityEngine.Random.value < _panicVoiceChance)
                        _bot.BotTalk?.TrySay(EPhraseTrigger.GetBack);
                    return;
                }

                // Realistic engagement: random micro-miss/abort when friendly in line of fire
                if (HasFriendlyInLineOfFire(aimPosition, profile))
                {
                    if (UnityEngine.Random.value < 0.36f)
                        return; // "Don't shoot friendlies"
                }

                if (distance > maxRange)
                {
                    if (profile.ChaosFactor > 0f && UnityEngine.Random.value < profile.ChaosFactor * 0.7f)
                    {
                        if (BotNavHelper.TryGetSafeTarget(_bot, out var advance) && IsVectorValid(advance))
                        {
                            if (UnityEngine.Random.value < 0.7f)
                                BotMovementHelper.SmoothMoveTo(_bot, advance, false, Mathf.Clamp(profile.Cohesion, 0.65f, 1.35f));
                        }
                    }
                    return;
                }

                if (time < _nextDecisionTime || time < _nextFireTime)
                    return;

                float composure = _cache.PanicHandler?.GetComposureLevel() ?? 1f;
                float suppressionPenalty = _cache.Suppression?.IsSuppressed() == true ? (1f - composure) : 0f;
                float microFlinch = UnityEngine.Random.Range(-0.09f, 0.16f) * suppressionPenalty;

                _nextDecisionTime = time + GetBurstCadence(profile) + microFlinch;

                float fireRhythm = Mathf.Lerp(0.11f, 0.39f, UnityEngine.Random.value) * Mathf.Lerp(1.0f, 1.5f, 1f - profile.ReactionTime);
                fireRhythm += suppressionPenalty * 0.27f + UnityEngine.Random.Range(0f, 0.09f);
                _nextFireTime = time + fireRhythm;

                // Smart reload/fallback
                if (weaponInfo.BulletCount <= 0 && !weaponInfo.CheckHaveAmmoForReload())
                {
                    weaponManager.Selector?.TryChangeWeaponCauseNoAmmo();
                    weaponManager.Melee?.Activate();
                    _bot.BotTalk?.TrySay(EPhraseTrigger.NeedAmmo);
                    return;
                }

                ApplyFireMode(weaponInfo, weapon, distance, profile, settings, suppressionPenalty);

                if (weaponManager.IsWeaponReady)
                {
                    // Baseline fire chance: tuned by suppression, aggression, and profile
                    float fireChance = suppressionPenalty < 0.55f
                        ? 0.94f + (profile.AggressionLevel * 0.05f)
                        : 0.63f + (profile.AggressionLevel * 0.25f);

                    // Additional chaos and panic modifiers to fire chance
                    if (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                    {
                        float composureLevel = 0.8f;
                        try
                        {
                            float val = _cache.PanicHandler.GetComposureLevel();
                            composureLevel = float.IsNaN(val) ? 0.8f : Mathf.Clamp01(val);
                        }
                        catch
                        {
                            composureLevel = 0.8f;
                        }
                        fireChance -= PanicFireChanceReduction * (1f - composureLevel);
                    }

                    // Clamp fire chance to [0,1.15] for absolute safety, so bad math can't break logic
                    fireChance = Mathf.Clamp(fireChance, 0f, 1.15f);

                    // Ultimate realism: sometimes, bots may hesitate even with a high fire chance if under suppression or in panic
                    float hesitationPenalty = 0f;
                    if (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                        hesitationPenalty += UnityEngine.Random.Range(0f, 0.19f);
                    if (_cache.Suppression != null && _cache.Suppression.IsSuppressed())
                        hesitationPenalty += UnityEngine.Random.Range(0f, 0.13f);
                    fireChance = Mathf.Clamp01(fireChance - hesitationPenalty);

                    if (UnityEngine.Random.value < fireChance)
                    {
                        shootData.Shoot();
                        _cache.LastShotTracker?.RegisterShot(target.ProfileId);

                        // Squad echo: Realistic squad suppression/contagion (with a cooldown per bot, not just random chance)
                        if (_cache.GroupBehavior != null && _cache.GroupBehavior.IsInSquad && UnityEngine.Random.value < SquadFireEchoChance)
                            _cache.GroupBehavior.TriggerSquadFireEcho(_bot, aimPosition);

                        // Squad voice coordination (simulate: "Firing!", "Suppression!", "He's down!", etc.)
                        TrySquadFireVoice(profile, time, target, aimPosition);
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] Tick exception: {ex}");
            }
        }

        #endregion

        #region Internal Aiming & Targeting

        /// <summary>
        /// Aim with composure, panic, suppression, and miss profile, applying realistic micro-drift, hesitation, and recoil.
        /// </summary>
        private void UpdateBotAiming(Vector3 aimPosition, BotPersonalityProfile profile, float time)
        {
            try
            {
                Vector3 dir = aimPosition - _bot.Position;
                if (dir.sqrMagnitude < 0.01f)
                    return;

                float composure = _cache.PanicHandler?.GetComposureLevel() ?? 1f;
                float suppression = _cache.Suppression?.IsSuppressed() == true ? (1f - composure) : 0f;
                float panicMiss = (1f - composure) * SuppressionPanicMissPenalty;
                float aimCone = Mathf.Lerp(0.82f, 2.6f, 1f - profile.AccuracyUnderFire);
                float suppressionCone = Mathf.Lerp(1f, 2.9f, suppression);
                float cone = aimCone + suppressionCone + panicMiss * 2.7f;
                cone = Mathf.Clamp(cone, 0.65f, 5.5f);

                float missAngle = UnityEngine.Random.Range(-MaxMissAngle, MaxMissAngle) * cone * UnityEngine.Random.Range(0.7f, 1.31f);
                float recoil = UnityEngine.Random.Range(0f, MaxHumanRecoilAngle) * (1f - composure) * UnityEngine.Random.Range(0.7f, 1.2f);

                Quaternion offsetQ = Quaternion.AngleAxis(missAngle, Vector3.up) * Quaternion.AngleAxis(recoil, Vector3.right);
                Vector3 adjustedDir = offsetQ * dir.normalized;

                float drift = AimDriftMagnitude * (UnityEngine.Random.value - 0.5f);
                adjustedDir += Vector3.Cross(Vector3.up, adjustedDir) * drift;

                Quaternion rot = Quaternion.LookRotation(adjustedDir);
                float pitch = rot.eulerAngles.x > 180f ? rot.eulerAngles.x - 360f : rot.eulerAngles.x;
                pitch = Mathf.Clamp(pitch, -MaxAimPitch, MaxAimPitch);

                Vector3 finalFwd = Quaternion.Euler(pitch, rot.eulerAngles.y, 0f) * Vector3.forward;
                _bot.AimingManager?.CurrentAiming?.SetTarget(finalFwd);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] Aiming exception: {ex}");
            }
        }

        /// <summary>
        /// Returns an aim position factoring in memory, bone targeting, last seen, and random idle drift.
        /// Robust to missing bones and dynamic player movement.
        /// </summary>
        private Vector3 GetHumanizedAimPosition(Player target, float time, BotPersonalityProfile profile)
        {
            try
            {
                if (EFTPlayerUtil.IsValid(target))
                {
                    Vector3 center = EFTPlayerUtil.GetPosition(target);

                    float composure = _cache.PanicHandler?.GetComposureLevel() ?? 1f;
                    float miss = UnityEngine.Random.value;
                    if (miss > 0.88f || composure < 0.48f)
                    {
                        var bones = target.PlayerBones;
                        Vector3 partPos = center;
                        if (bones != null)
                        {
                            var boneType = PreferredBones[UnityEngine.Random.Range(0, PreferredBones.Length)];
                            if (bones.BifacialTransforms.TryGetValue(boneType, out var bifacial))
                            {
                                Transform t = bifacial?.Original;
                                if (t != null)
                                    partPos = t.position;
                            }
                        }
                        center = Vector3.Lerp(center, partPos, UnityEngine.Random.Range(0.27f, 0.99f));
                    }
                    return center;
                }

                Vector3 memory = _bot.Memory.LastEnemy?.CurrPosition ?? Vector3.zero;
                if (memory != Vector3.zero)
                    return memory;

                if (time - _lastLookAroundTime > 1.2f)
                {
                    float yaw = UnityEngine.Random.Range(-83f, 83f);
                    float pitch = UnityEngine.Random.Range(-13f, 13f);
                    Quaternion q = Quaternion.Euler(pitch, yaw, 0f);
                    Vector3 baseDir = _bot.Transform != null ? _bot.Transform.forward : Vector3.forward;
                    _idleLookDirection = q * baseDir;
                    _lastLookAroundTime = time;
                }

                return _bot.Position + _idleLookDirection.normalized * 9f;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] AimPos exception: {ex}");
                return _bot.Position;
            }
        }

        #endregion

        #region Weapon Fire Mode & Profile

        private void ApplyFireMode(BotWeaponInfo info, Weapon weapon, float distance, BotPersonalityProfile profile, GClass592 settings, float suppressionPenalty)
        {
            try
            {
                if (suppressionPenalty > 0.42f && UnityEngine.Random.value < 0.38f)
                {
                    SetFireMode(info, Weapon.EFireMode.single);
                    ApplyScatter(settings, true, profile, suppressionPenalty);
                    return;
                }

                if (distance <= 42f)
                {
                    SetFireMode(info, Weapon.EFireMode.fullauto);
                    RecoverAccuracy(settings);
                }
                else if (distance <= 100f && SupportsFireMode(weapon, Weapon.EFireMode.burst))
                {
                    SetFireMode(info, Weapon.EFireMode.burst);
                    ApplyScatter(settings, true, profile, suppressionPenalty);
                }
                else
                {
                    SetFireMode(info, Weapon.EFireMode.single);
                    ApplyScatter(settings, true, profile, suppressionPenalty);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] ApplyFireMode exception: {ex}");
            }
        }

        private void SetFireMode(BotWeaponInfo info, Weapon.EFireMode mode)
        {
            try
            {
                if (info.weapon.SelectedFireMode != mode)
                    info.ChangeFireMode(mode);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] FireMode switch failed: {ex}");
            }
        }

        private bool SupportsFireMode(Weapon weapon, Weapon.EFireMode mode)
        {
            try
            {
                foreach (var m in weapon.WeapFireType)
                {
                    if (m == mode)
                        return true;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] SupportsFireMode exception: {ex}");
            }
            return false;
        }

        private void RecoverAccuracy(GClass592 settings)
        {
            try
            {
                settings.ScatteringPerMeter = Mathf.Clamp(settings.ScatteringPerMeter * 0.95f, 0.36f, 3.1f);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] RecoverAccuracy failed: {ex}");
            }
        }

        private void ApplyScatter(GClass592 settings, bool underFire, BotPersonalityProfile profile, float suppressionPenalty)
        {
            try
            {
                float composure = _cache.PanicHandler?.GetComposureLevel() ?? 1f;
                float scatterPenalty = underFire ? (1f - profile.AccuracyUnderFire) * (1f - composure) : 0f;
                scatterPenalty += suppressionPenalty * 0.65f;
                float scatterFactor = 1.15f + scatterPenalty;

                if (suppressionPenalty > 0.21f && UnityEngine.Random.value < 0.39f)
                    scatterFactor *= UnityEngine.Random.Range(1.05f, 1.21f);

                settings.ScatteringPerMeter = Mathf.Clamp(settings.ScatteringPerMeter * scatterFactor, 0.51f, 3.6f);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] ApplyScatter failed: {ex}");
            }
        }

        private float EstimateWeaponRange(Weapon weapon)
        {
            try
            {
                var template = weapon.Template;
                if (template == null || string.IsNullOrEmpty(template.Name))
                    return 90f;

                foreach (var kv in WeaponTypeRanges)
                {
                    if (template.Name.IndexOf(kv.Key, StringComparison.OrdinalIgnoreCase) >= 0)
                        return kv.Value;
                }

                return 90f;
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] EstimateWeaponRange failed: {ex}");
                return 90f;
            }
        }

        private float GetBurstCadence(BotPersonalityProfile profile)
        {
            try
            {
                float baseDelay = Mathf.Lerp(0.81f, 0.22f, profile.AggressionLevel);
                float reactionDelay = Mathf.Lerp(0.14f, 0.39f, 1f - profile.ReactionTime);
                float chaosOffset = UnityEngine.Random.Range(-0.09f, 0.21f) * profile.ChaosFactor;
                return Mathf.Clamp(baseDelay + reactionDelay + chaosOffset, MinBurstCadence, MaxBurstCadence);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] GetBurstCadence failed: {ex}");
                return 0.43f;
            }
        }

        #endregion

        #region Enemy Target Resolution

        /// <summary>
        /// Resolves the current enemy Player target, prioritizing direct ThreatSelector, fallback to tactical memory.
        /// </summary>
        private bool TryResolveEnemy(out Player result)
        {
            result = null;
            try
            {
                if (_cache.ThreatSelector?.CurrentTarget is Player direct && EFTPlayerUtil.IsValid(direct))
                {
                    result = direct;
                    return true;
                }

                if (_bot.Memory?.GoalEnemy?.Person is Player fallback && EFTPlayerUtil.IsValid(fallback))
                {
                    result = fallback;
                    return true;
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] TryResolveEnemy failed: {ex}");
            }
            return false;
        }

        #endregion

        #region Advanced Voice & Squad Comms

        /// <summary>
        /// Occasionally plays fear/callout lines when panicking or squad-echoing.
        /// </summary>
        private void TryVoicePanicOrCallout(BotPersonalityProfile profile, float time)
        {
            try
            {
                if (_cache.PanicHandler?.IsPanicking == true && UnityEngine.Random.value < _panicVoiceChance &&
                    time - _lastVoiceCalloutTime > _voiceCalloutMinInterval)
                {
                    _bot.BotTalk?.TrySay(EPhraseTrigger.GetBack);
                    _lastVoiceCalloutTime = time + UnityEngine.Random.Range(_voiceCalloutMinInterval, _voiceCalloutMaxInterval);
                }
                else if (_cache.GroupBehavior?.IsInSquad == true && UnityEngine.Random.value < 0.12f &&
                         time - _lastVoiceCalloutTime > _voiceCalloutMinInterval)
                {
                    _bot.BotTalk?.TrySay(EPhraseTrigger.OnFirstContact);
                    _lastVoiceCalloutTime = time + UnityEngine.Random.Range(_voiceCalloutMinInterval, _voiceCalloutMaxInterval);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] TryVoicePanicOrCallout failed: {ex}");
            }
        }

        /// <summary>
        /// Squad leader or squad bot fires: may play a voice line like "Suppression!", "Engaging!", etc.
        /// </summary>
        private void TrySquadFireVoice(BotPersonalityProfile profile, float time, Player target, Vector3 aimPosition)
        {
            try
            {
                if (_cache.GroupBehavior?.IsInSquad == true && UnityEngine.Random.value < 0.17f &&
                    time - _lastVoiceCalloutTime > _voiceCalloutMinInterval)
                {
                    if (profile.AggressionLevel > 0.67f && UnityEngine.Random.value < 0.5f)
                        _bot.BotTalk?.TrySay(EPhraseTrigger.Suppress);
                    else if (profile.AggressionLevel > 0.37f)
                        _bot.BotTalk?.TrySay(EPhraseTrigger.Fire);
                    else
                        _bot.BotTalk?.TrySay(EPhraseTrigger.OnFirstContact);
                    _lastVoiceCalloutTime = time + UnityEngine.Random.Range(_voiceCalloutMinInterval, _voiceCalloutMaxInterval);
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] TrySquadFireVoice failed: {ex}");
            }
        }

        #endregion

        #region Friendly Fire Prevention

        /// <summary>
        /// Returns true if a squadmate is in the line of fire (for friendly fire prevention).
        /// </summary>
        private bool HasFriendlyInLineOfFire(Vector3 aimPosition, BotPersonalityProfile profile)
        {
            try
            {
                if (_cache.GroupBehavior?.IsInSquad != true)
                    return false;
                if (_bot.BotsGroup == null || _bot.BotsGroup.MembersCount <= 1)
                    return false;

                Vector3 myPos = _bot.Position;
                Vector3 dirToAim = (aimPosition - myPos).normalized;
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                {
                    BotOwner mate = _bot.BotsGroup.Member(i);
                    if (mate == null || mate == _bot || mate.IsDead) continue;
                    Vector3 mateDir = (mate.Position - myPos).normalized;
                    float dot = Vector3.Dot(dirToAim, mateDir);
                    if (dot > Mathf.Cos(FriendlyFirePreventionAngle * Mathf.Deg2Rad))
                    {
                        float distToLine = Vector3.Cross(dirToAim, mate.Position - myPos).magnitude;
                        if (distToLine < 0.8f)
                            return true;
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance?.LogError($"[BotFireLogic] HasFriendlyInLineOfFire failed: {ex}");
            }
            return false;
        }

        #endregion

        #region Utility

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z);
        }

        #endregion
    }
}
