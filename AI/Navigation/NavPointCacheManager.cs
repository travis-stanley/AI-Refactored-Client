// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Do not modify without verifying the NavPointRegistry binary format.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Text;
	using AIRefactored.Core;
	using BepInEx;
	using BepInEx.Logging;
	using UnityEngine;

	/// <summary>
	/// Handles persistent caching of NavPointData for faster warmup and reduced runtime cost.
	/// </summary>
	public static class NavPointCacheManager
	{
		#region Constants

		private const string FolderName = "AI-Refactored";
		private const string CacheDirName = "Cache";
		private const string CacheExt = ".navcache";
		private const string MetaExt = ".meta";

		#endregion

		#region Static

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
		private static readonly string CacheDirPath = Path.Combine(Paths.PluginPath, FolderName, CacheDirName);

		#endregion

		#region Public API

		/// <summary>
		/// Attempts to load cached navpoints from disk.
		/// </summary>
		public static bool TryLoad(string mapId, out List<NavPointData> navPoints)
		{
			navPoints = null;
			if (string.IsNullOrEmpty(mapId))
			{
				return false;
			}

			try
			{
				string file = GetCacheFilePath(mapId);
				string meta = GetMetaFilePath(mapId);

				if (!File.Exists(file) || !File.Exists(meta) || !VerifyChecksum(meta, mapId))
				{
					return false;
				}

				using (BinaryReader reader = new BinaryReader(File.OpenRead(file)))
				{
					int count = reader.ReadInt32();
					navPoints = new List<NavPointData>(count);

					for (int i = 0; i < count; i++)
					{
						Vector3 position = ReadVector3(reader);
						bool isCover = reader.ReadBoolean();
						string tag = reader.ReadString();
						float elevation = reader.ReadSingle();
						bool isIndoor = reader.ReadBoolean();
						bool isJumpable = reader.ReadBoolean();
						float coverAngle = reader.ReadSingle();
						string zone = reader.ReadString();
						string elevationBand = reader.ReadString();

						navPoints.Add(new NavPointData(position, isCover, tag, elevation, isIndoor, isJumpable, coverAngle, zone, elevationBand));
					}
				}

				Logger.LogInfo("[NavPointCacheManager] ✅ Loaded cached navpoints for map: " + mapId);
				return true;
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointCacheManager] ❌ Failed to load cache: " + ex);
				return false;
			}
		}

		/// <summary>
		/// Saves the current navpoint registry state to disk.
		/// </summary>
		public static void Save(string mapId, List<NavPointData> navPoints)
		{
			if (string.IsNullOrEmpty(mapId) || navPoints == null || navPoints.Count == 0)
			{
				return;
			}

			try
			{
				Directory.CreateDirectory(CacheDirPath);
				string file = GetCacheFilePath(mapId);
				string meta = GetMetaFilePath(mapId);

				using (BinaryWriter writer = new BinaryWriter(File.Create(file)))
				{
					writer.Write(navPoints.Count);

					for (int i = 0; i < navPoints.Count; i++)
					{
						NavPointData point = navPoints[i];

						WriteVector3(writer, point.Position);
						writer.Write(point.IsCover);
						writer.Write(point.Tag);
						writer.Write(point.Elevation);
						writer.Write(point.IsIndoor);
						writer.Write(point.IsJumpable);
						writer.Write(point.CoverAngle);
						writer.Write(point.Zone);
						writer.Write(point.ElevationBand);
					}
				}

				File.WriteAllText(meta, GenerateChecksum(mapId, navPoints.Count));
				Logger.LogInfo("[NavPointCacheManager] 💾 Saved navpoint cache for map: " + mapId + " (" + navPoints.Count + " points)");
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointCacheManager] ❌ Failed to save navpoint cache: " + ex);
			}
		}

		#endregion

		#region Internal Helpers

		private static string GetCacheFilePath(string mapId)
		{
			return Path.Combine(CacheDirPath, mapId + CacheExt);
		}

		private static string GetMetaFilePath(string mapId)
		{
			return Path.Combine(CacheDirPath, mapId + CacheExt + MetaExt);
		}

		private static string GenerateChecksum(string mapId, int count)
		{
			return mapId + ":" + count;
		}

		private static bool VerifyChecksum(string metaPath, string mapId)
		{
			try
			{
				string content = File.ReadAllText(metaPath);
				string[] parts = content.Split(':');
				return parts.Length == 2 && parts[0] == mapId && int.TryParse(parts[1], out int _);
			}
			catch
			{
				return false;
			}
		}

		private static void WriteVector3(BinaryWriter writer, Vector3 vec)
		{
			writer.Write(vec.x);
			writer.Write(vec.y);
			writer.Write(vec.z);
		}

		private static Vector3 ReadVector3(BinaryReader reader)
		{
			float x = reader.ReadSingle();
			float y = reader.ReadSingle();
			float z = reader.ReadSingle();
			return new Vector3(x, y, z);
		}

		#endregion
	}
}
