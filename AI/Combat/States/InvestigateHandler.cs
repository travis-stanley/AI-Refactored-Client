// <auto-generated>
//   AI-Refactored: InvestigateHandler.cs (Beyond Diamond – Hard Realism Edition, Anti-Jitter, Resettable, June 2025)
//   Fully patched for Critical AI Movement & Teleportation Regression Fix Plan.
//   All fallback/target vectors are NavMesh-sampled, fallback-safe, and validated for movement.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles squad/personality-aware, fallback-safe, fully NavMesh-validated investigation movement.
    /// Zero teleport, no host gating, only ticked by BotBrain, and all movement is bulletproofed.
    /// </summary>
    public sealed class InvestigateHandler
    {
        #region Constants

        private const float InvestigateCooldown = 10f;
        private const float ScanRadius = 4f;
        private const float SoundReactTime = 1f;
        private const float MaxInvestigateTime = 15f;
        private const float ExitDelayBuffer = 1.25f;
        private const float ActiveWindow = 5f;
        private const float MinCaution = 0.3f;
        private const float MinHumanDelay = 0.07f;
        private const float MaxHumanDelay = 0.18f;
        private const float NavMeshSampleRadius = 1.2f;
        private const float SquadSpread = 0.9f;
        private const float IdleLookIntervalMin = 0.65f;
        private const float IdleLookIntervalMax = 1.15f;
        private const float GiveUpChanceBase = 0.13f;
        private const float AllClearVoiceChance = 0.25f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotTacticalMemory _memory;
        private float _lastInvestigateTime = -1000f;
        private float _nextIdleScanTime = -1000f;
        private bool _hasGivenUp = false;
        private bool _hasArrived = false;

        #endregion

        #region Constructor

        /// <summary>
        /// Instantiates an InvestigateHandler for the given bot cache.
        /// </summary>
        public InvestigateHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _memory = cache?.TacticalMemory;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Resets internal state for new investigation.
        /// </summary>
        public void Clear()
        {
            _hasGivenUp = false;
            _hasArrived = false;
            _lastInvestigateTime = -1000f;
            _nextIdleScanTime = -1000f;
        }

        /// <summary>
        /// Gets a valid, squad/personality/humanized investigation target, always NavMesh-sampled.
        /// </summary>
        public Vector3 GetInvestigateTarget(Vector3 visualLastKnown)
        {
            Vector3 origin = _bot?.Position ?? Vector3.zero;
            Vector3 result = Vector3.zero;

            if (IsValid(visualLastKnown))
                result = SampleNavMesh(visualLastKnown);
            else if (TryGetMemory(out var mem))
                result = SampleNavMesh(mem);
            else if (TryGetSquadMemory(out var squad))
                result = SampleNavMesh(squad);
            else
                result = SampleNavMesh(origin + UnityEngine.Random.insideUnitSphere * ScanRadius);

            // Squad spread: personality/squad role, fully deterministic
            if (_cache?.SquadPath != null)
            {
                try { result = _cache.SquadPath.ApplyOffsetTo(result); } catch { }
            }
            else if (_bot?.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                int index = GetSquadIndex(_bot);
                Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                result += perp * (SquadSpread * (index - (_bot.BotsGroup.MembersCount / 2f)));
            }

            return BotMovementHelper.ApplyMicroDrift(result, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);
        }

        /// <summary>
        /// Drives realistic investigate movement, stance, voice. Always path-based, never teleports. 
        /// </summary>
        public void Investigate(Vector3 target)
        {
            if (_hasGivenUp || _bot == null || _cache == null) return;

            float now = Time.time;
            float anticipate = UnityEngine.Random.Range(MinHumanDelay, MaxHumanDelay) *
                               (1f + (_cache.PersonalityProfile?.Caution ?? 0.1f) * 0.55f);
            if (now - _lastInvestigateTime < anticipate) return;

            _lastInvestigateTime = now;
            Vector3 dest = SampleNavMesh(target);

            if (_cache?.SquadPath != null)
            {
                try { dest = _cache.SquadPath.ApplyOffsetTo(dest); } catch { }
            }
            else if (_bot?.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                int index = GetSquadIndex(_bot);
                Vector3 perp = Vector3.Cross(Vector3.up, _bot.LookDirection.normalized);
                dest += perp * (SquadSpread * (index - (_bot.BotsGroup.MembersCount / 2f)));
            }

            dest = BotMovementHelper.ApplyMicroDrift(dest, _bot.ProfileId, Time.frameCount, _cache.PersonalityProfile);
            float cohesion = Mathf.Clamp(_cache?.PersonalityProfile?.Cohesion ?? 1f, 0.7f, 1.3f);

            if (_bot.Mover != null)
            {
                BotMovementHelper.SmoothMoveTo(_bot, dest, true, cohesion);
                _memory?.MarkCleared(dest);

                float distance = Vector3.Distance(_bot.Position, dest);
                if (!_hasArrived && distance < 1.1f)
                {
                    _hasArrived = true;
                    if (!_hasGivenUp && UnityEngine.Random.value < (GiveUpChanceBase + (_cache.PersonalityProfile?.Caution ?? 0)))
                    {
                        _hasGivenUp = true;
                        if (_bot.BotTalk != null && UnityEngine.Random.value < AllClearVoiceChance)
                        {
                            try { _bot.BotTalk.TrySay(EPhraseTrigger.Clear); } catch { }
                        }
                    }
                    PerformIdleScan();
                }
                else if (distance > 1.2f) _hasArrived = false;

                if (_cache?.PoseController != null)
                {
                    if (distance < 2.4f && UnityEngine.Random.value < 0.4f + (_cache.PersonalityProfile?.Caution ?? 0.15f))
                        _cache.PoseController.Crouch();
                    else
                        _cache.PoseController.TrySetStanceFromNearbyCover(dest);
                }
            }
        }

        /// <summary>
        /// Returns true if bot should currently investigate (sound heard recently, not in exit buffer, not given up).
        /// </summary>
        public bool ShallUseNow(float now, float lastTransition)
        {
            return _cache?.AIRefactoredBotOwner?.PersonalityProfile?.Caution >= MinCaution &&
                   (_cache.LastHeardTime + SoundReactTime) > now &&
                   (now - lastTransition) > ExitDelayBuffer && !_hasGivenUp;
        }

        /// <summary>
        /// Returns true if bot should exit investigate state (time expired, or gave up).
        /// </summary>
        public bool ShouldExit(float now, float lastHit, float cooldown)
        {
            float elapsed = now - lastHit;
            return _hasGivenUp || elapsed > cooldown || elapsed > MaxInvestigateTime;
        }

        public bool IsInvestigating() => (Time.time - _cache.LastHeardTime) <= ActiveWindow && !_hasGivenUp;

        #endregion

        #region Internal

        private bool TryGetMemory(out Vector3 result)
        {
            result = _memory?.GetRecentEnemyMemory() ?? Vector3.zero;
            return IsValid(result);
        }

        private bool TryGetSquadMemory(out Vector3 result)
        {
            result = Vector3.zero;
            if (_bot?.BotsGroup == null) return false;

            for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
            {
                var mate = _bot.BotsGroup.Member(i);
                if (mate == null || mate == _bot || mate.IsDead) continue;
                var cache = BotCacheUtility.GetCache(mate);
                if (cache?.TacticalMemory != null)
                {
                    Vector3? memory = cache.TacticalMemory.GetRecentEnemyMemory();
                    if (memory.HasValue && IsValid(memory.Value))
                    {
                        result = memory.Value;
                        return true;
                    }
                }
            }
            return false;
        }

        private static Vector3 SampleNavMesh(Vector3 candidate)
        {
            return NavMesh.SamplePosition(candidate, out var hit, NavMeshSampleRadius, NavMesh.AllAreas)
                ? hit.position : candidate;
        }

        private void PerformIdleScan()
        {
            if (Time.time < _nextIdleScanTime) return;
            _nextIdleScanTime = Time.time + UnityEngine.Random.Range(IdleLookIntervalMin, IdleLookIntervalMax);

            Vector3 offset = UnityEngine.Random.insideUnitSphere * 1.6f;
            offset.y = 0;
            BotMovementHelper.SmoothLookTo(_bot, _bot.Position + _bot.LookDirection * 2.4f + offset, 2.4f);
        }

        private static bool IsValid(Vector3 v)
        {
            return v != Vector3.zero &&
                   !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z);
        }

        private static int GetSquadIndex(BotOwner bot)
        {
            if (bot?.BotsGroup == null) return -1;
            for (int i = 0; i < bot.BotsGroup.MembersCount; i++)
                if (bot.BotsGroup.Member(i) == bot) return i;
            return -1;
        }

        #endregion
    }
}
