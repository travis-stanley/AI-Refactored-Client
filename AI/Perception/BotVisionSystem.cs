// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.Animations;
    using UnityEngine;

    public sealed class BotVisionSystem
    {
        #region Constants

        private const float AutoDetectRadius = 4f;
        private const float BaseViewConeAngle = 120f;
        private const float BoneConfidenceDecay = 0.1f;
        private const float BoneConfidenceThreshold = 0.45f;
        private const float MaxDetectionDistance = 120f;
        private const float SuppressionMissChance = 0.2f;
        private const float MotionBoost = 0.2f;

        private static readonly Vector3 EyeOffset = new Vector3(0f, 1.4f, 0f);

        private static readonly PlayerBoneType[] BonesToCheck =
        {
            PlayerBoneType.Head, PlayerBoneType.Spine, PlayerBoneType.Ribcage,
            PlayerBoneType.LeftShoulder, PlayerBoneType.RightShoulder,
            PlayerBoneType.Pelvis, PlayerBoneType.LeftThigh1, PlayerBoneType.RightThigh1
        };

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotTacticalMemory _memory;
        private BotPersonalityProfile _profile;
        private float _lastCommitTime;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.TacticalMemory == null || cache.AIRefactoredBotOwner == null)
            {
                return;
            }

            _bot = cache.Bot;
            _cache = cache;
            _memory = cache.TacticalMemory;
            _profile = cache.AIRefactoredBotOwner.PersonalityProfile;
            _lastCommitTime = -999f;
        }

        #endregion

        #region Tick

        public void Tick(float time)
        {
            if (!IsValid())
            {
                return;
            }

            Vector3 eye = _bot.Position + EyeOffset;
            Vector3 forward = _bot.LookDirection;

            float fogFactor = RenderSettings.fog ? Mathf.Clamp01(RenderSettings.fogDensity * 4f) : 0f;
            float ambient = RenderSettings.ambientLight.grayscale;
            float viewCone = Mathf.Lerp(BaseViewConeAngle, 60f, 1f - ambient);

            Transform head = BotCacheUtility.Head(_cache);
            if (head != null && FlashlightRegistry.IsExposingBot(head, out _))
            {
                viewCone *= 0.6f;
            }

            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            Player bestTarget = null;
            float bestDist = float.MaxValue;

            for (int i = 0; i < players.Count; i++)
            {
                Player p = players[i];
                if (!IsValidTarget(p))
                {
                    continue;
                }

                Vector3 pos = EFTPlayerUtil.GetPosition(p);
                float dist = Vector3.Distance(eye, pos);
                float maxVis = MaxDetectionDistance * (1f - fogFactor);

                if (dist > maxVis)
                {
                    continue;
                }

                bool inCone = IsInViewCone(forward, eye, pos, viewCone);
                bool close = dist <= AutoDetectRadius;
                bool canSee = HasLineOfSight(eye, p);

                if ((inCone && canSee) || (close && canSee))
                {
                    if (dist < bestDist)
                    {
                        bestDist = dist;
                        bestTarget = p;
                    }
                }
                else if ((inCone || close) && !canSee && !FikaHeadlessDetector.IsHeadless)
                {
                    _bot.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
                }
            }

            if (bestTarget != null)
            {
                Vector3 pos = EFTPlayerUtil.GetPosition(bestTarget);
                _memory.RecordEnemyPosition(pos, "Visual", bestTarget.ProfileId);
                ShareMemoryToSquad(pos);
                TrackVisibleBones(eye, bestTarget, fogFactor);
                EvaluateTargetConfidence(bestTarget, time);
            }
        }

        #endregion

        #region Target Evaluation

        private void EvaluateTargetConfidence(Player target, float time)
        {
            TrackedEnemyVisibility tracker = _cache.VisibilityTracker;
            if (tracker == null || !tracker.HasEnoughData)
            {
                return;
            }

            float confidence = tracker.GetOverallConfidence();

            if (_bot.Memory.IsUnderFire && Random.value < SuppressionMissChance)
            {
                return;
            }

            if (confidence < BoneConfidenceThreshold)
            {
                return;
            }

            CommitEnemyIfAllowed(target, time);
        }

        private void CommitEnemyIfAllowed(Player target, float time)
        {
            if (!EFTPlayerUtil.IsEnemyOf(_bot, target))
            {
                return;
            }

            float delay = Mathf.Lerp(0.1f, 0.6f, 1f - _profile.ReactionTime);
            if (time - _lastCommitTime < delay)
            {
                return;
            }

            IPlayer enemy = EFTPlayerUtil.AsSafeIPlayer(target);
            if (enemy == null || _bot.BotsGroup == null)
            {
                return;
            }

            _bot.BotsGroup.AddEnemy(enemy, EBotEnemyCause.addPlayer);
            _lastCommitTime = time;

            if (!FikaHeadlessDetector.IsHeadless)
            {
                _bot.BotTalk?.TrySay(EPhraseTrigger.OnEnemyConversation);
            }
        }

        #endregion

        #region Bone Tracking

        private void TrackVisibleBones(Vector3 eye, Player target, float fog)
        {
            if (_cache.VisibilityTracker == null)
            {
                _cache.VisibilityTracker = new TrackedEnemyVisibility(_bot.Transform.Original);
            }

            TrackedEnemyVisibility tracker = _cache.VisibilityTracker;

            if (target.TryGetComponent<PlayerSpiritBones>(out PlayerSpiritBones bones))
            {
                Bounds[] bounds = TempBoundsPool.Rent(BonesToCheck.Length);

                for (int i = 0; i < BonesToCheck.Length; i++)
                {
                    Transform bone = bones.GetBone(BonesToCheck[i]).Original;
                    if (bone != null && !Physics.Linecast(eye, bone.position, out _, AIRefactoredLayerMasks.LineOfSightMask))
                    {
                        bounds[i] = new Bounds(bone.position, Vector3.one * 0.2f);
                        float boost = IsMovingFast(target) ? MotionBoost : 0f;
                        tracker.UpdateBoneVisibility(BonesToCheck[i].ToString(), bone.position, boost, fog);
                    }
                }

                TempBoundsPool.Return(bounds);
            }
            else
            {
                Transform tf = EFTPlayerUtil.GetTransform(target);
                if (tf != null && !Physics.Linecast(eye, tf.position, out _, AIRefactoredLayerMasks.LineOfSightMask))
                {
                    tracker.UpdateBoneVisibility("Body", tf.position);
                }
            }

            tracker.DecayConfidence(BoneConfidenceDecay * Time.deltaTime);
        }

        #endregion

        #region Memory Sharing

        private void ShareMemoryToSquad(Vector3 pos)
        {
            if (_cache.GroupSync == null)
            {
                return;
            }

            List<BotComponentCache> teammates = TempListPool.Rent<BotComponentCache>();
            try
            {
                IReadOnlyList<BotOwner> squad = _cache.GroupSync.GetTeammates();
                for (int i = 0; i < squad.Count; i++)
                {
                    BotOwner mate = squad[i];
                    if (mate != null && BotRegistry.TryGetCache(mate.ProfileId, out BotComponentCache comp))
                    {
                        teammates.Add(comp);
                    }
                }

                _memory.ShareMemoryWith(teammates);
            }
            finally
            {
                TempListPool.Return(teammates);
            }
        }

        #endregion

        #region Utility

        private static bool HasLineOfSight(Vector3 from, Player target)
        {
            Transform t = EFTPlayerUtil.GetTransform(target);
            if (t == null)
            {
                return false;
            }

            Vector3 to = t.position + EyeOffset;
            return !Physics.Linecast(from, to, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask)
                   || hit.collider.transform.root == t.root;
        }

        private static bool IsInViewCone(Vector3 forward, Vector3 origin, Vector3 target, float angle)
        {
            return Vector3.Angle(forward, target - origin) <= angle * 0.5f;
        }

        private static bool IsMovingFast(Player p)
        {
            return p != null && p.Velocity.sqrMagnitude > 2.25f;
        }

        private bool IsValid()
        {
            return _bot != null &&
                   _cache != null &&
                   _profile != null &&
                   _memory != null &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   !_bot.IsDead &&
                   GameWorldHandler.IsSafeToInitialize;
        }

        private bool IsValidTarget(Player t)
        {
            return EFTPlayerUtil.IsValid(t) &&
                   t.ProfileId != _bot.ProfileId &&
                   EFTPlayerUtil.IsEnemyOf(_bot, t);
        }

        #endregion
    }
}
