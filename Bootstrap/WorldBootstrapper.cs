// <auto-generated>
//   AI-Refactored: WorldBootstrapper.cs (Beyond Diamond – Ultimate Parity & Isolation Edition, June 2025)
//   SYSTEMATICALLY MANAGED. No disables, no logic split. All failures isolated; atomic attach/retry. 
//   All headless checks INIT-ONLY; never in runtime/tick. Zero deadlocks, zero state drift.
//   All pooling, static prewarm, and global attach bulletproofed.
//   MIT License.
// </auto-generated>

namespace AIRefactored.Bootstrap
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Looting;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.AI.Threads;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// AI-Refactored global world initializer and runtime tick manager.
    /// Ensures bulletproof attach/retry, never disables, and always runs full logic in both headless and client.
    /// No runtime split—only init is allowed to branch for headless mode.
    /// </summary>
    public static class WorldBootstrapper
    {
        #region Fields

        private static readonly List<IAIWorldSystemBootstrapper> Systems = new List<IAIWorldSystemBootstrapper>(16);
        private static ManualLogSource _loggerInstance = Plugin.LoggerInstance;
        private static bool _hasInitialized;
        private static bool _hasShutdownLogged;
        private static float _lastSweep;
        private const float SweepInterval = 20f;

        private static ManualLogSource Logger => _loggerInstance ?? Plugin.LoggerInstance;

        #endregion

        #region Initialization & Attach

        /// <summary>
        /// Entry point for initializing world-level AI systems. Headless/client logic unified—branch only at init.
        /// </summary>
        public static void Begin(ManualLogSource logger, string mapId)
        {
            _loggerInstance = logger ?? Plugin.LoggerInstance;

            if (_hasInitialized)
                return;

            // INIT-ONLY: Only headless gating allowed here.
            if (FikaHeadlessDetector.IsHeadless && !FikaHeadlessDetector.HasRaidStarted())
                return;

            try
            {
                _hasShutdownLogged = false;
                Systems.Clear();

                // Prewarm and clear all statics/pools/registries for 100% robust re-attach
                TrySafe(BotRecoveryService.Reset, "[WorldBootstrapper] BotRecoveryService.Reset() failed: ");
                TrySafe(BotSpawnWatcherService.Reset, "[WorldBootstrapper] BotSpawnWatcherService.Reset() failed: ");
                TrySafe(LootRuntimeWatcher.Reset, "[WorldBootstrapper] LootRuntimeWatcher.Reset() failed: ");
                TrySafe(DeadBodyObserverService.Reset, "[WorldBootstrapper] DeadBodyObserverService.Reset() failed: ");
                TrySafe(DeadBodyContainerCache.Clear, "[WorldBootstrapper] DeadBodyContainerCache.Clear() failed: ");
                TrySafe(LootRegistry.Clear, "[WorldBootstrapper] LootRegistry.Clear() failed: ");
                TrySafe(HotspotRegistry.Clear, "[WorldBootstrapper] HotspotRegistry.Clear() failed: ");

                if (!string.IsNullOrEmpty(mapId))
                    TrySafe(() => HotspotRegistry.Initialize(mapId), "[WorldBootstrapper] HotspotRegistry.Initialize() failed: ");

                RegisterSystemSafe(new RaidLifecycleWatcher());
                RegisterSystemSafe(new BotRecoveryService());
                RegisterSystemSafe(new BotSpawnWatcherService());
                RegisterSystemSafe(new LootRuntimeWatcher());
                RegisterSystemSafe(new DeadBodyObserverService());
                RegisterSystemSafe(new HotspotRegistryBootstrapper());

                for (int i = 0; i < Systems.Count; i++)
                    TrySafe(Systems[i].Initialize, $"[WorldBootstrapper] Failed to initialize {Systems[i].GetType().Name}: ");

                _hasInitialized = true;
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldBootstrapper] Initialization failed: " + ex);
            }
        }

        #endregion

        #region Teardown & Stop

        /// <summary>
        /// Cleanly shuts down all world-level AIRefactored systems, locally isolating all errors.
        /// </summary>
        public static void Stop()
        {
            if (!_hasInitialized)
                return;

            try
            {
                for (int i = 0; i < Systems.Count; i++)
                    TrySafe(Systems[i].OnRaidEnd, $"[WorldBootstrapper] OnRaidEnd error in {Systems[i].GetType().Name}: ");

                Systems.Clear();
                _hasInitialized = false;

                if (!_hasShutdownLogged)
                {
                    _hasShutdownLogged = true;
                    Logger.LogDebug("[WorldBootstrapper] 🔻 AIRefactored systems shut down.");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldBootstrapper] Stop() encountered error: " + ex);
            }
        }

        #endregion

        #region Central Tick

        /// <summary>
        /// Central tick loop: ticks all world and bot AI subsystems, always 1:1 between headless and client.
        /// No branching, no disables, no difference between FIKA headless and client. 
        /// </summary>
        public static void Tick(float deltaTime)
        {
            if (!_hasInitialized)
                return;

            try
            {
                float now = Time.time;

                for (int i = 0; i < Systems.Count; i++)
                {
                    IAIWorldSystemBootstrapper system = Systems[i];
                    if (system == null)
                        continue;

                    try
                    {
                        if (WorldInitState.IsInPhase(system.RequiredPhase()))
                            system.Tick(deltaTime);
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError("[WorldBootstrapper] System Tick() error in " + system.GetType().Name + ": " + ex);
                    }
                }

                List<Player> players = GameWorldHandler.GetAllAlivePlayers();
                try
                {
                    for (int i = 0; i < players.Count; i++)
                    {
                        Player player = players[i];
                        if (!EFTPlayerUtil.IsValid(player) || !player.IsAI)
                            continue;

                        GameObject go = player.gameObject;
                        if (go == null)
                            continue;

                        BotBrain brain = go.GetComponent<BotBrain>();
                        if (brain != null && brain.enabled)
                        {
                            try
                            {
                                brain.Tick(deltaTime);
                            }
                            catch (Exception ex)
                            {
                                Logger.LogError("[WorldBootstrapper] BotBrain.Tick() error: " + ex);
                            }
                        }
                    }
                }
                finally
                {
                    TempListPool.Return(players);
                }

                if (now - _lastSweep >= SweepInterval)
                {
                    _lastSweep = now;
                    TrySafe(GameWorldHandler.EnforceBotBrains, "[WorldBootstrapper] EnforceBotBrains() failed: ");
                    TrySafe(GameWorldHandler.CleanupDeadBotsSmoothly, "[WorldBootstrapper] CleanupDeadBotsSmoothly() failed: ");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldBootstrapper] Tick() outer error: " + ex);
            }
        }

        #endregion

        #region Attach/Reliability API

        /// <summary>
        /// Forces a bot brain attach/retry for a given player+bot, bulletproof and unified across all modes.
        /// </summary>
        public static void EnforceBotBrain(Player player, BotOwner bot)
        {
            if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || bot == null)
                return;

            string profileId = bot.Profile?.Id;
            if (string.IsNullOrEmpty(profileId))
                return;

            GameObject go = player.gameObject;
            if (go == null)
                return;

            try
            {
                BotComponentCache cache = BotComponentCacheRegistry.GetOrCreate(bot);
                if (cache == null || cache.AIRefactoredBotOwner == null)
                    return;

                BotBrainGuardian.Enforce(go);

                BotBrain existing = go.GetComponent<BotBrain>();
                if (existing == null)
                {
                    BotBrain brain = go.AddComponent<BotBrain>();
                    brain.enabled = true;
                    brain.Initialize(bot);
                }
                else if (!existing.enabled)
                {
                    existing.enabled = true;
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[WorldBootstrapper] BotBrain init failed for " + profileId + ": " + ex);
            }
        }

        #endregion

        #region System Registry Helpers

        private static void RegisterSystemSafe(IAIWorldSystemBootstrapper system)
        {
            try
            {
                if (system == null || Systems.Contains(system))
                    return;

                Systems.Add(system);
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldBootstrapper] RegisterSystemSafe() failed: " + ex);
            }
        }

        public static void RegisterSystem(IAIWorldSystemBootstrapper system)
        {
            RegisterSystemSafe(system);
        }

        #endregion

        #region Safe Helper

        private static void TrySafe(Action action, string errorPrefix)
        {
            try { action(); }
            catch (Exception ex) { Logger.LogError(errorPrefix + ex); }
        }

        #endregion
    }
}
