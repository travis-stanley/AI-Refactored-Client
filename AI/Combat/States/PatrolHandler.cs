// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Hotspots;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot behavior while in Patrol state.
    /// Evaluates suppression, panic, wounds, or nearby deaths to trigger fallback, and moves bots between hotspots.
    /// Bulletproof: All failures are isolated; only this handler disables itself and triggers vanilla fallback if required.
    /// </summary>
    public sealed class PatrolHandler
    {
        #region Constants

        private const float DeadAllyRadius = 10.0f;
        private const float InvestigateSoundDelay = 3.0f;
        private const float PanicThreshold = 0.25f;
        private const int FallbackPathMinLength = 2;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _minStateDuration;
        private readonly float _switchCooldownBase;

        private float _nextSwitchTime;
        private bool _isFallbackMode;

        #endregion

        #region Constructor

        public PatrolHandler(BotComponentCache cache, float minStateDuration, float switchCooldownBase)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _minStateDuration = minStateDuration;
            _switchCooldownBase = switchCooldownBase;

            if (_cache == null || _bot == null)
            {
                BotFallbackUtility.Trigger(this, _bot, "Constructor failed: cache or bot is null.");
                _isFallbackMode = true;
            }
            else
            {
                _isFallbackMode = false;
            }
        }

        #endregion

        #region Public Methods

        public bool ShallUseNow()
        {
            if (_isFallbackMode)
                return false;
            return true;
        }

        public bool ShouldTransitionToInvestigate(float time)
        {
            if (_isFallbackMode || _cache?.Combat == null || _cache.AIRefactoredBotOwner?.PersonalityProfile == null)
                return false;

            try
            {
                if (_cache.AIRefactoredBotOwner.PersonalityProfile.Caution <= 0.35f)
                    return false;

                return (_cache.LastHeardTime + InvestigateSoundDelay > time) &&
                       (time - _cache.Combat.LastStateChangeTime > _minStateDuration);
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "Exception in ShouldTransitionToInvestigate.", ex);
                _isFallbackMode = true;
                return false;
            }
        }

        public void Tick(float time)
        {
            if (_isFallbackMode || _cache == null || _bot == null)
                return;

            try
            {
                if (ShouldTriggerFallback())
                {
                    Vector3 fallback = TryGetFallbackPosition();

                    if (!BotNavValidator.Validate(_bot, "PatrolFallback"))
                    {
                        if (!EFTPathFallbackHelper.TryGetSafeTarget(_bot, out fallback))
                            fallback = EFTPathFallbackHelper.GetFallbackNavPoint(_bot.Position);
                    }
                    if (!IsVectorValid(fallback))
                        fallback = EFTPathFallbackHelper.GetFallbackNavPoint(_bot.Position);

                    try
                    {
                        _cache.Combat?.TriggerFallback(fallback);
                    }
                    catch (Exception ex)
                    {
                        BotFallbackUtility.Trigger(this, _bot, "TriggerFallback exception in Tick.", ex);
                        _isFallbackMode = true;
                        BotFallbackUtility.FallbackToEFTLogic(_bot);
                        return;
                    }
                    return;
                }

                if (time < _nextSwitchTime)
                    return;

                HotspotRegistry.Hotspot hotspot = null;
                try
                {
                    hotspot = HotspotRegistry.GetRandomHotspot();
                }
                catch (Exception ex)
                {
                    BotFallbackUtility.Trigger(this, _bot, "HotspotRegistry exception in Tick.", ex);
                    _isFallbackMode = true;
                    return;
                }

                if (hotspot == null || !IsVectorValid(hotspot.Position))
                {
                    BotFallbackUtility.Trigger(this, _bot, "Skipped patrol: hotspot was null or invalid.");
                    return;
                }

                Vector3 target = hotspot.Position;
                Vector3 destination = _cache.SquadPath != null
                    ? _cache.SquadPath.ApplyOffsetTo(target)
                    : target;

                if (!IsVectorValid(destination) ||
                    !BotNavValidator.Validate(_bot, "PatrolDestination"))
                {
                    if (!EFTPathFallbackHelper.TryGetSafeTarget(_bot, out destination))
                        destination = EFTPathFallbackHelper.GetFallbackNavPoint(_bot.Position);
                }
                if (!IsVectorValid(destination))
                    destination = EFTPathFallbackHelper.GetFallbackNavPoint(_bot.Position);

                if (_bot.Mover != null)
                {
                    try
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, destination);
                        BotCoverHelper.TrySetStanceFromNearbyCover(_cache, destination);
                    }
                    catch (Exception ex)
                    {
                        BotFallbackUtility.Trigger(this, _bot, "Exception in SmoothMoveTo or TrySetStance.", ex);
                        _isFallbackMode = true;
                        BotFallbackUtility.FallbackToEFTLogic(_bot);
                        return;
                    }
                }
                else
                {
                    BotFallbackUtility.Trigger(this, _bot, "BotMover missing. Fallback to EFT AI.");
                    _isFallbackMode = true;
                    BotFallbackUtility.FallbackToEFTLogic(_bot);
                    return;
                }

                _nextSwitchTime = time + UnityEngine.Random.Range(_switchCooldownBase, _switchCooldownBase + 18.0f);

                if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null && UnityEngine.Random.value < 0.25f)
                {
                    try { _bot.BotTalk.TrySay(EPhraseTrigger.GoForward); }
                    catch { /* no-op */ }
                }
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "General exception in Tick.", ex);
                _isFallbackMode = true;
            }
        }

        #endregion

        #region Private Methods

        private bool ShouldTriggerFallback()
        {
            if (_isFallbackMode || _cache == null || _bot == null)
                return false;

            try
            {
                if (_cache.PanicHandler != null && _cache.PanicHandler.GetComposureLevel() < PanicThreshold)
                    return true;

                if (_cache.InjurySystem != null && _cache.InjurySystem.ShouldHeal())
                    return true;

                if (_cache.Suppression != null && _cache.Suppression.IsSuppressed())
                    return true;

                BotsGroup group = _bot.BotsGroup;
                if (group == null)
                    return false;

                Vector3 selfPos = _bot.Position;
                for (int i = 0, count = group.MembersCount; i < count; i++)
                {
                    BotOwner member = group.Member(i);
                    if (member != null && member != _bot && member.IsDead)
                    {
                        if (Vector3.Distance(selfPos, member.Position) < DeadAllyRadius)
                            return true;
                    }
                }

                return false;
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "Exception in ShouldTriggerFallback.", ex);
                _isFallbackMode = true;
                return false;
            }
        }

        private Vector3 TryGetFallbackPosition()
        {
            if (_isFallbackMode || _cache?.Pathing == null || _bot == null)
                return _bot != null ? _bot.Position : Vector3.zero;

            try
            {
                Vector3 direction = _bot.LookDirection.normalized;
                List<Vector3> path = BotCoverRetreatPlanner.GetCoverRetreatPath(_bot, direction, _cache.Pathing);

                if (path != null && path.Count >= FallbackPathMinLength)
                    return path[path.Count - 1];

                return FallbackNavPointProvider.GetSafePoint(_bot.Position);
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "Exception in TryGetFallbackPosition.", ex);
                _isFallbackMode = true;
                return _bot != null ? _bot.Position : Vector3.zero;
            }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z);
        }

        #endregion
    }
}
