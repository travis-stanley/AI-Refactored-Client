// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Do not modify without verifying the NavPointRegistry binary format.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using AIRefactored.Core;
	using BepInEx.Logging;
	using UnityEngine;

	/// <summary>
	/// Handles persistent caching of NavPointData for faster warmup and reduced runtime cost.
	/// Fully bulletproof: all errors are isolated, never propagate, and always fallback gracefully.
	/// </summary>
	public static class NavPointCacheManager
	{
		#region Constants

		private const string FolderName = "AI-Refactored";
		private const string CacheDirName = "Cache";
		private const string CacheExt = ".navcache";
		private const string MetaExt = ".meta";
		private const int CurrentCacheVersion = 1;

		#endregion

		#region Static

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
		private static readonly string CacheDirPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "BepInEx", FolderName, CacheDirName);

		#endregion

		#region Public API

		/// <summary>
		/// Attempts to load cached navpoints from disk, validates version and structure.
		/// </summary>
		public static bool TryLoad(string mapId, out List<NavPointData> navPoints)
		{
			navPoints = null;
			if (string.IsNullOrEmpty(mapId))
				return false;

			try
			{
				string file = GetCacheFilePath(mapId);
				string meta = GetMetaFilePath(mapId);

				if (!File.Exists(file) || !File.Exists(meta) || !VerifyChecksum(meta, mapId))
					return false;

				using (var stream = File.OpenRead(file))
				using (var reader = new BinaryReader(stream))
				{
					// Versioning support (future-proofed)
					int version = 1;
					long startPos = stream.Position;
					int possibleVersion = reader.ReadInt32();
					if (possibleVersion > 1000)
					{
						// Unlikely to ever have 1000+ navpoints, treat as version
						version = possibleVersion;
					}
					else
					{
						// No version in file, rewind and treat as old format
						stream.Position = startPos;
					}

					int count = reader.ReadInt32();
					if (count < 0 || count > 200000)
					{
						Logger.LogWarning("[NavPointCacheManager] Cache corrupted or obsolete (bad point count). Deleting: " + file);
						TryDelete(file);
						TryDelete(meta);
						return false;
					}

					navPoints = new List<NavPointData>(count);

					for (int i = 0; i < count; i++)
					{
						Vector3 position = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
						bool isCover = reader.ReadBoolean();
						string tag = SafeReadString(reader);
						float elevation = reader.ReadSingle();
						bool isIndoor = reader.ReadBoolean();
						bool isJumpable = reader.ReadBoolean();
						float coverAngle = reader.ReadSingle();
						string zone = SafeReadString(reader);
						string elevationBand = SafeReadString(reader);

						if (!IsValidPosition(position))
						{
							Logger.LogWarning($"[NavPointCacheManager] Skipping invalid navpoint at index {i} (position NaN or zero).");
							continue;
						}

						navPoints.Add(new NavPointData(position, isCover, tag, elevation, isIndoor, isJumpable, coverAngle, zone, elevationBand));
					}
				}

				if (navPoints.Count == 0)
				{
					Logger.LogWarning("[NavPointCacheManager] No valid navpoints loaded (empty cache).");
					return false;
				}

				Logger.LogInfo("[NavPointCacheManager] ✅ Loaded cached navpoints for map: " + mapId + $" ({navPoints.Count} points)");
				return true;
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointCacheManager] ❌ Failed to load cache: " + ex.Message);
				navPoints = null;
				return false;
			}
		}

		/// <summary>
		/// Saves the current navpoint registry state to disk. Bulletproof and versioned.
		/// </summary>
		public static void Save(string mapId, List<NavPointData> navPoints)
		{
			if (string.IsNullOrEmpty(mapId) || navPoints == null || navPoints.Count == 0)
				return;

			try
			{
				try
				{
					Directory.CreateDirectory(CacheDirPath);
				}
				catch (Exception exDir)
				{
					Logger.LogWarning("[NavPointCacheManager] Directory creation failed: " + exDir.Message);
				}

				string file = GetCacheFilePath(mapId);
				string meta = GetMetaFilePath(mapId);

				using (var stream = File.Create(file))
				using (var writer = new BinaryWriter(stream))
				{
					writer.Write(CurrentCacheVersion); // version
					writer.Write(navPoints.Count);

					foreach (var point in navPoints)
					{
						writer.Write(point.Position.x);
						writer.Write(point.Position.y);
						writer.Write(point.Position.z);

						writer.Write(point.IsCover);
						writer.Write(point.Tag ?? string.Empty);
						writer.Write(point.Elevation);
						writer.Write(point.IsIndoor);
						writer.Write(point.IsJumpable);
						writer.Write(point.CoverAngle);
						writer.Write(point.Zone ?? string.Empty);
						writer.Write(point.ElevationBand ?? string.Empty);
					}
				}

				File.WriteAllText(meta, GenerateChecksum(mapId, navPoints.Count));
				Logger.LogInfo($"[NavPointCacheManager] 💾 Saved navpoint cache for map: {mapId} ({navPoints.Count} points)");
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointCacheManager] ❌ Failed to save navpoint cache: " + ex.Message);
			}
		}

		#endregion

		#region Internal Helpers

		private static string GetCacheFilePath(string mapId)
			=> Path.Combine(CacheDirPath, mapId + CacheExt);

		private static string GetMetaFilePath(string mapId)
			=> Path.Combine(CacheDirPath, mapId + CacheExt + MetaExt);

		private static string GenerateChecksum(string mapId, int count)
			=> $"{mapId}:{count}:{CurrentCacheVersion}";

		private static bool VerifyChecksum(string metaPath, string mapId)
		{
			try
			{
				if (!File.Exists(metaPath))
					return false;

				string content = File.ReadAllText(metaPath);
				var parts = content.Split(':');
				return parts.Length >= 2 && parts[0] == mapId && int.TryParse(parts[1], out _);
			}
			catch
			{
				return false;
			}
		}

		private static bool IsValidPosition(Vector3 pos)
		{
			return !float.IsNaN(pos.x) && !float.IsNaN(pos.y) && !float.IsNaN(pos.z) && pos != Vector3.zero;
		}

		private static void TryDelete(string file)
		{
			try { if (File.Exists(file)) File.Delete(file); } catch { }
		}

		private static string SafeReadString(BinaryReader reader)
		{
			try { return reader.ReadString(); }
			catch { return string.Empty; }
		}

		#endregion
	}
}
