// <auto-generated>
//   AI-Refactored. Ultra-Realistic Movement, Lean, and Reaction Logic. MIT License.
//   SYSTEMATICALLY MANAGED. 100% native EFT nav, squad formation, full error isolation.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Human-realistic movement, lean, and formation controller, 100% EFT-native.
    /// Bulletproof: All null/invalid states are isolated, no vanilla fallback.
    /// </summary>
    public sealed class BotMovementController
    {
        #region Constants

        private const float MicroDriftIntervalMin = 0.65f, MicroDriftIntervalMax = 1.48f, MicroDriftMagnitude = 0.10f;
        private const float CombatStrafeBase = 1.05f, CombatStrafeJitter = 0.05f;
        private const float CombatStrafeCooldownMin = 0.38f, CombatStrafeCooldownMax = 1.13f;
        private const float CombatStrafeSuppressedMul = 0.45f;
        private const float FallbackBackoffDistance = 0.32f;
        private const float LeanCooldownMin = 0.72f, LeanCooldownMax = 1.23f, LeanLockoutSuppressed = 1.05f;
        private const float MaxStrafeAngle = 75f, StartlePause = 0.23f;
        private const float PathUncertaintyMagnitude = 0.14f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _lastScanTime, _nextLeanTime, _strafeTimer, _lastRandomPause, _nextRandomPause, _leanLockoutUntil, _lastFallbackOrSprint, _leanMissChance;
        private float _nextMicroDrift, _panicPathWobbleTimer, _entryPauseUntil, _startleUntil, _fallbackRetryTime;
        private bool _strafeRight, _lootingMode, _fallbackActive;
        private Vector3 _microDriftOffset;
        private float _personalityScanDelay, _personalityStartleChance;
        private bool _lastPanickingState;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new InvalidOperationException("[BotMovementController] Invalid initialization.");

            _cache = cache;
            _bot = cache.Bot;
            _lastScanTime = Time.time;
            _nextLeanTime = Time.time;
            _strafeTimer = 0.5f;
            _lootingMode = false;
            _lastRandomPause = Time.time;
            _nextRandomPause = Time.time + UnityEngine.Random.Range(1.5f, 3.8f);
            _leanLockoutUntil = 0f;
            _lastFallbackOrSprint = 0f;
            _leanMissChance = (_cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f) * 0.07f;
            _nextMicroDrift = Time.time + UnityEngine.Random.Range(MicroDriftIntervalMin, MicroDriftIntervalMax);
            _microDriftOffset = Vector3.zero;
            _panicPathWobbleTimer = 0f;
            _entryPauseUntil = 0f;
            _fallbackActive = false;
            _startleUntil = 0f;
            _fallbackRetryTime = 0f;
            _personalityScanDelay = UnityEngine.Random.Range(0.15f, 0.52f) * (_cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f);
            _personalityStartleChance = (_cache.AIRefactoredBotOwner?.PersonalityProfile?.AggressionLevel ?? 0.5f) < 0.33f ? 0.35f : 0.08f;
            _lastPanickingState = _cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking;
        }

        #endregion

        #region Main Tick

        /// <summary>
        /// Real-time per-frame update. Bulletproof and never disables itself.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead || _bot.Mover == null)
                    return;
                var player = _bot.GetPlayer;
                if (player == null || !player.IsAI)
                    return;

                // Startle/human hesitation after panic/trauma
                UpdateStartlePause();
                if (Time.time < _startleUntil)
                    return;

                TryFallbackPathCorrection();

                // Track fallback/sprint for lean lockout
                if (_cache?.Fallback != null && _cache.Fallback.IsActive())
                    _lastFallbackOrSprint = Time.time;
                if (player.IsSprintEnabled || _bot.Mover.Sprinting)
                    _lastFallbackOrSprint = Time.time;

                if (!_lootingMode)
                {
                    TryCombatStrafe(_bot.Mover, deltaTime);
                    TryLean();
                }

                TrySmoothLook(_bot.Mover, deltaTime);
                TryScan();
                TryMicroDrift(deltaTime);

                // Squad/formation/spacing handled by BotGroupBehavior/SquadPathCoordinator externally

                TryPanicPathWobble(deltaTime);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] Tick error: " + ex);
            }
        }

        #endregion

        #region Humanized Movement Subsystems

        private void TryMicroDrift(float deltaTime)
        {
            if (_bot == null || _bot.Transform == null || !_bot.Mover.IsMoving)
                return;
            if (Time.time < _nextMicroDrift)
                return;
            Vector3 randomOffset = UnityEngine.Random.insideUnitSphere * MicroDriftMagnitude;
            randomOffset.y = 0f;
            _microDriftOffset = randomOffset;
            var player = _bot.GetPlayer;
            player?.CharacterController?.Move(_microDriftOffset, deltaTime);
            _nextMicroDrift = Time.time + UnityEngine.Random.Range(MicroDriftIntervalMin, MicroDriftIntervalMax);
        }

        private void TrySmoothLook(BotMover mover, float deltaTime)
        {
            if (_bot?.Transform == null || mover == null)
                return;
            Vector3 target;
            try { target = mover._pathController.LastTargetPoint(1f); }
            catch { return; }
            if (!NavMesh.SamplePosition(target, out NavMeshHit navHit, 1.5f, NavMesh.AllAreas))
                return;
            Vector3 direction = navHit.position - _bot.Position;
            direction.y = 0f;
            if (direction.sqrMagnitude < 0.01f)
                return;
            if (Time.time < _lastRandomPause + 0.13f && UnityEngine.Random.value < 0.09f)
                return;
            Quaternion desired = Quaternion.LookRotation(direction);
            _bot.Transform.rotation = Quaternion.Lerp(_bot.Transform.rotation, desired, 5.5f * deltaTime);
            if (Time.time > _nextRandomPause)
            {
                _lastRandomPause = Time.time;
                _nextRandomPause = Time.time + UnityEngine.Random.Range(1.2f, 3.7f);
            }
        }

        private void TryCombatStrafe(BotMover mover, float deltaTime)
        {
            if (_bot == null || mover == null || _bot.Memory?.GoalEnemy == null)
                return;
            if (!mover.HasPathAndNoComplete || !_bot.Mover.IsMoving || _bot.Transform == null)
                return;
            float distToEnemy = Vector3.Distance(_bot.Position, _bot.Memory.GoalEnemy.CurrPosition);
            if (distToEnemy > 40f)
                return;
            _strafeTimer -= deltaTime;
            if (_strafeTimer <= 0f)
            {
                float suppressionFactor = 1f;
                if (_cache?.Suppression != null && _cache.Suppression.IsSuppressed())
                    suppressionFactor = CombatStrafeSuppressedMul;
                if (_cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                    suppressionFactor *= 0.72f;
                _strafeRight = UnityEngine.Random.value > 0.5f;
                _strafeTimer = UnityEngine.Random.Range(CombatStrafeCooldownMin, CombatStrafeCooldownMax) / suppressionFactor;
            }
            Vector3 toEnemy = _bot.Memory.GoalEnemy.CurrPosition - _bot.Position;
            float angle = Vector3.Angle(_bot.Transform.forward, toEnemy.normalized);
            if (angle > MaxStrafeAngle)
                return;
            Vector3 offset = _strafeRight ? _bot.Transform.right : -_bot.Transform.right;
            Vector3 jitter = UnityEngine.Random.insideUnitSphere * CombatStrafeJitter;
            Vector3 strafe = (offset + jitter).normalized * CombatStrafeBase;
            Vector3 navDir = mover.NormDirCurPoint;
            Vector3 blend = Vector3.Lerp(navDir, strafe, UnityEngine.Random.Range(0.18f, 0.32f)).normalized * deltaTime;
            if (_cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                blend += UnityEngine.Random.insideUnitSphere * PathUncertaintyMagnitude * deltaTime;
            var player = _bot.GetPlayer;
            player?.CharacterController?.Move(blend, deltaTime);
        }

        private void TryLean()
        {
            if (_cache?.Tilt == null || _bot == null)
                return;
            float now = Time.time;
            if ((_cache.Suppression != null && _cache.Suppression.IsSuppressed()) ||
                (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking))
            {
                _leanLockoutUntil = now + LeanLockoutSuppressed;
                return;
            }
            if (now < _leanLockoutUntil)
                return;
            if (now - _lastFallbackOrSprint < 1.25f)
            {
                _leanLockoutUntil = now + 0.7f;
                return;
            }
            if (_cache.IsBlinded)
                return;
            var memory = _bot.Memory;
            if (memory?.GoalEnemy == null || _bot.Transform == null)
                return;
            var player = _bot.GetPlayer;
            if (player != null && (player.IsSprintEnabled || _bot.Mover.Sprinting || !_bot.Mover.IsMoving))
                return;
            bool leanLeft = false, leanRight = false;
            Vector3 head = _bot.Position + Vector3.up * 1.5f;
            if (memory.IsDamaged && memory.LastHitPos != Vector3.zero)
            {
                Vector3 hitDir = memory.LastHitPos - _bot.Position;
                float hitDot = Vector3.Dot(hitDir.normalized, _bot.Transform.right);
                if (hitDot > 0.1f) leanRight = true;
                if (hitDot < -0.1f) leanLeft = true;
            }
            bool wallLeft = Physics.Raycast(head, -_bot.Transform.right, 1.35f, AIRefactoredLayerMasks.VisionBlockers);
            bool wallRight = Physics.Raycast(head, _bot.Transform.right, 1.35f, AIRefactoredLayerMasks.VisionBlockers);
            if (wallLeft && !wallRight)
                _cache.Tilt.Set(BotTiltType.right);
            else if (wallRight && !wallLeft)
                _cache.Tilt.Set(BotTiltType.left);
            else if (leanRight)
                _cache.Tilt.Set(BotTiltType.right);
            else if (leanLeft)
                _cache.Tilt.Set(BotTiltType.left);
            else
            {
                Vector3 toEnemy = memory.GoalEnemy.CurrPosition - _bot.Position;
                float dot = Vector3.Dot(toEnemy.normalized, _bot.Transform.right);
                bool tacticalLean = UnityEngine.Random.value < 0.8f;
                _cache.Tilt.Set(tacticalLean
                    ? (dot > 0f ? BotTiltType.right : BotTiltType.left)
                    : (dot > 0f ? BotTiltType.left : BotTiltType.right));
            }
            if (UnityEngine.Random.value < _leanMissChance)
            {
                _nextLeanTime = now + UnityEngine.Random.Range(0.65f, 1.25f);
                return;
            }
            if (now < _nextLeanTime)
                return;
            _nextLeanTime = now + UnityEngine.Random.Range(LeanCooldownMin, LeanCooldownMax);
            _leanLockoutUntil = now + UnityEngine.Random.Range(0.43f, 0.68f);
        }

        private void TryScan()
        {
            if (_bot?.Transform == null)
                return;
            if (Time.time - _lastScanTime < UnityEngine.Random.Range(1.12f, 1.45f) + _personalityScanDelay)
                return;
            Vector3 head = _bot.Position + Vector3.up * 1.5f;
            Vector3 dir = _bot.Transform.forward;
            if (Physics.SphereCast(head, 0.24f, dir, out _, 2.4f, AIRefactoredLayerMasks.VisionBlockers))
            {
                if (_bot.BotTalk != null && UnityEngine.Random.value < 0.21f)
                    _bot.BotTalk.TrySay(EPhraseTrigger.Look);
            }
            _lastScanTime = Time.time;
        }

        private void TryFallbackPathCorrection()
        {
            if (_fallbackActive && Time.time < _fallbackRetryTime)
                return;
            if (_fallbackActive)
            {
                Vector3 backoff = -_bot.Transform.forward * FallbackBackoffDistance;
                var player = _bot.GetPlayer;
                player?.CharacterController?.Move(backoff, 0.13f);
                _fallbackActive = false;
            }
        }

        private void TryPanicPathWobble(float deltaTime)
        {
            if (_cache?.PanicHandler == null || !_cache.PanicHandler.IsPanicking)
                return;
            _panicPathWobbleTimer -= deltaTime;
            if (_panicPathWobbleTimer > 0f)
                return;
            _panicPathWobbleTimer = UnityEngine.Random.Range(0.12f, 0.21f);
            Vector3 sidestep = UnityEngine.Random.insideUnitSphere * PathUncertaintyMagnitude;
            sidestep.y = 0f;
            var player = _bot.GetPlayer;
            player?.CharacterController?.Move(sidestep, 0.08f);
        }

        private void UpdateStartlePause()
        {
            if (_cache?.PanicHandler != null)
            {
                bool nowPanicking = _cache.PanicHandler.IsPanicking;
                if (!_lastPanickingState && nowPanicking)
                {
                    if (UnityEngine.Random.value < _personalityStartleChance)
                        _startleUntil = Time.time + StartlePause + UnityEngine.Random.Range(0.04f, 0.11f);
                }
                _lastPanickingState = nowPanicking;
            }
        }

        private void TrySquadSpacing(float deltaTime)
        {
            // External: driven by BotGroupBehavior/SquadPathCoordinator
        }

        #endregion

        #region Mode Controls

        public void EnterLootingMode() => _lootingMode = true;
        public void ExitLootingMode() => _lootingMode = false;
        public bool IsInLootingMode() => _lootingMode;

        #endregion
    }
}
