// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
	using System;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using AIRefactored.Core;
	using AIRefactored.Pools;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using UnityEngine;

	/// <summary>
	/// Schedules and dispatches thread-safe bot workloads during headless or client-hosted execution.
	/// </summary>
	public static class BotWorkGroupDispatcher
	{
		#region Constants

		private const int MaxWorkPerTick = 256;
		private const int MaxThreads = 16;

		#endregion

		#region Fields

		private static readonly object Sync = new object();
		private static readonly ManualLogSource Log = Plugin.LoggerInstance;
		private static readonly List<IBotWorkload> WorkQueue = new List<IBotWorkload>(MaxWorkPerTick);
		private static readonly int ThreadCount = Mathf.Clamp(Environment.ProcessorCount, 1, MaxThreads);

		#endregion

		#region Public API

		/// <summary>
		/// Queues a bot workload for background execution.
		/// </summary>
		/// <param name="workload">The workload to execute.</param>
		public static void Schedule(IBotWorkload workload)
		{
			if (workload == null)
			{
				return;
			}

			lock (Sync)
			{
				if (WorkQueue.Count >= MaxWorkPerTick)
				{
					Log.LogWarning("[BotWorkGroupDispatcher] Max queue capacity reached. Dropping workload.");
					return;
				}

				WorkQueue.Add(workload);
			}
		}

		/// <summary>
		/// Executes queued workloads in thread batches. Call from Update().
		/// </summary>
		public static void Tick()
		{
			if (!GameWorldHandler.IsLocalHost())
			{
				return;
			}

			List<IBotWorkload> batch = null;

			lock (Sync)
			{
				if (WorkQueue.Count == 0)
				{
					return;
				}

				int count = Mathf.Min(WorkQueue.Count, MaxWorkPerTick);
				batch = TempListPool.Rent<IBotWorkload>();

				for (int i = 0; i < count; i++)
				{
					batch.Add(WorkQueue[i]);
				}

				WorkQueue.RemoveRange(0, count);
			}

			try
			{
				Dispatch(batch);
			}
			finally
			{
				TempListPool.Return(batch);
			}
		}

		#endregion

		#region Dispatch

		private static void Dispatch(List<IBotWorkload> batch)
		{
			if (batch == null || batch.Count == 0)
			{
				return;
			}

			int total = batch.Count;
			int threads = Mathf.Clamp(ThreadCount, 1, total);
			int blockSize = Mathf.CeilToInt(total / (float)threads);

			for (int t = 0; t < threads; t++)
			{
				int start = t * blockSize;
				if (start >= total)
				{
					break;
				}

				int end = Mathf.Min(start + blockSize, total);

				// Local copy for closure safety
				int localStart = start;
				int localEnd = end;

				Task.Run(() =>
				{
					for (int i = localStart; i < localEnd; i++)
					{
						IBotWorkload job = batch[i];
						if (job == null)
						{
							continue;
						}

						try
						{
							job.RunBackgroundWork();
						}
						catch (Exception ex)
						{
							Log.LogWarning("[BotWorkGroupDispatcher] Background workload exception:\n" + ex);
						}
					}
				});
			}
		}

		#endregion
	}

	/// <summary>
	/// Background-safe interface for threaded bot logic. Must not use Unity APIs.
	/// </summary>
	public interface IBotWorkload
	{
		/// <summary>
		/// Executes the workload from a thread pool context.
		/// </summary>
		void RunBackgroundWork();
	}
}
