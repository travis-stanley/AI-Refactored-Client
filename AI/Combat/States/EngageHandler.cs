// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Guides tactical movement toward enemy's last known location.
    /// Supports cautious advancement and squad-aware pathing.
    /// Bulletproof: all failures are isolated; never disables itself or squadmates.
    /// </summary>
    public sealed class EngageHandler
    {
        private const float DefaultEngagementRange = 25.0f;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly float _fallbackRange;

        public EngageHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;

            float profileRange = cache?.PersonalityProfile?.EngagementRange ?? 0f;
            _fallbackRange = profileRange > 0f ? profileRange : DefaultEngagementRange;
        }

        public bool ShallUseNow()
        {
            if (!IsCombatCapable())
                return false;

            try
            {
                return TryGetLastKnownEnemy(out Vector3 enemyPos) && !IsWithinRange(enemyPos);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[EngageHandler] Exception in ShallUseNow: {ex}");
                return false;
            }
        }

        public bool CanAttack()
        {
            if (!IsCombatCapable())
                return false;

            try
            {
                return TryGetLastKnownEnemy(out Vector3 enemyPos) && IsWithinRange(enemyPos);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[EngageHandler] Exception in CanAttack: {ex}");
                return false;
            }
        }

        public void Tick()
        {
            if (!IsCombatCapable())
                return;

            try
            {
                if (!TryGetLastKnownEnemy(out Vector3 enemyPos))
                    return;

                Vector3 destination = enemyPos;
                // SquadPath is a tactical offset, never replaces vanilla nav
                if (_cache.SquadPath != null)
                {
                    try
                    {
                        destination = _cache.SquadPath.ApplyOffsetTo(enemyPos);
                    }
                    catch
                    {
                        destination = enemyPos;
                    }
                }

                // Only valid positions allowed
                if (!IsValid(destination))
                    return;

                // Use vanilla EFT-compatible movement helper, never custom fallback
                if (_bot.Mover != null)
                {
                    try
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, destination);
                        _cache.Combat?.TrySetStanceFromNearbyCover(destination);
                    }
                    catch (Exception ex)
                    {
                        Plugin.LoggerInstance.LogError($"[EngageHandler] Exception in SmoothMoveTo or TrySetStance: {ex}");
                    }
                }
                else
                {
                    Plugin.LoggerInstance.LogError("[EngageHandler] BotMover missing; cannot move.");
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[EngageHandler] General exception in Tick: {ex}");
            }
        }

        public bool IsEngaging()
        {
            if (!IsCombatCapable())
                return false;

            try
            {
                return TryGetLastKnownEnemy(out Vector3 enemyPos) && !IsWithinRange(enemyPos);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[EngageHandler] Exception in IsEngaging: {ex}");
                return false;
            }
        }

        private bool IsCombatCapable()
        {
            return _cache != null && _bot != null && _cache.Combat != null;
        }

        private bool TryGetLastKnownEnemy(out Vector3 result)
        {
            result = _cache?.Combat?.LastKnownEnemyPos ?? Vector3.zero;
            return IsValid(result) && result != Vector3.zero;
        }

        private bool IsWithinRange(Vector3 enemyPos)
        {
            return Vector3.SqrMagnitude(_bot.Position - enemyPos) < (_fallbackRange * _fallbackRange);
        }

        private static bool IsValid(Vector3 pos)
        {
            return pos != Vector3.zero &&
                   !float.IsNaN(pos.x) &&
                   !float.IsNaN(pos.y) &&
                   !float.IsNaN(pos.z);
        }
    }
}
