// <auto-generated>
//   AI-Refactored: BotRecoveryService.cs (Ultimate Parity & Atomic Recovery Edition, June 2025)
//   All failures are strictly localized. No fallback/terminal disables. All bots recover/retry until valid.
//   MIT License.
// </auto-generated>

namespace AIRefactored.Runtime
{
	using System;
	using System.Collections.Generic;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Hotspots;
	using AIRefactored.AI.Looting;
	using AIRefactored.AI.Navigation;
	using AIRefactored.AI.Threads;
	using AIRefactored.Bootstrap;
	using AIRefactored.Core;
	using BepInEx.Logging;
	using Comfort.Common;
	using EFT;
	using EFT.Game.Spawning;
	using UnityEngine;

	/// <summary>
	/// Monolithic bot lifecycle, cache, and owner/brain recovery watchdog.
	/// All failures are contained; no fallback or terminal disable, always retry on incomplete state.
	/// </summary>
	public sealed class BotRecoveryService : IAIWorldSystemBootstrapper
	{
		private const float TickInterval = 5f;

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static float _nextTickTime = -1f;
		private static bool _hasInitialized;
		private static bool _hookedSpawner;

		public static BotRecoveryService Instance { get; } = new BotRecoveryService();

		/// <summary>
		/// Initializes the recovery service and resets state.
		/// </summary>
		public void Initialize()
		{
			Reset();
			_hasInitialized = true;
		}

		/// <summary>
		/// Called on raid end or teardown to reset and detach hooks.
		/// </summary>
		public void OnRaidEnd()
		{
			try
			{
				if (_hookedSpawner && Singleton<BotSpawner>.Instantiated)
				{
					Singleton<BotSpawner>.Instance.OnBotCreated -= GameWorldHandler.TryAttachBotBrain;
					_hookedSpawner = false;
				}
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotRecoveryService] OnRaidEnd hook detach failed: " + ex);
			}

			Reset();
			_hasInitialized = false;
		}

		public bool IsReady() => _hasInitialized && GameWorldHandler.IsReady();
		public WorldPhase RequiredPhase() => WorldPhase.WorldReady;

		public static void Reset()
		{
			_nextTickTime = -1f;
			_hookedSpawner = false;
		}

		/// <summary>
		/// Ticks the recovery service to ensure all bots, owners, and caches are wired and running.
		/// </summary>
		public void Tick(float deltaTime)
		{
			try
			{
				if (!_hasInitialized || !GameWorldHandler.IsHost || !GameWorldHandler.IsReady())
					return;

				float now = Time.time;
				if (now < _nextTickTime)
					return;
				_nextTickTime = now + TickInterval;

				GameWorld world = GameWorldHandler.Get();
				if (world == null || world.AllAlivePlayersList == null)
					return;

				EnsureSpawnHook();
				ValidateBotBrains(world.AllAlivePlayersList);
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotRecoveryService] Tick error: " + ex);
			}
		}

		/// <summary>
		/// Ensures the BotSpawner event hook is attached for runtime bot injection.
		/// </summary>
		private static void EnsureSpawnHook()
		{
			try
			{
				if (_hookedSpawner || !Singleton<BotSpawner>.Instantiated)
					return;

				Singleton<BotSpawner>.Instance.OnBotCreated += GameWorldHandler.TryAttachBotBrain;
				_hookedSpawner = true;
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotRecoveryService] EnsureSpawnHook error: " + ex);
			}
		}

		/// <summary>
		/// Iterates all living AI players and ensures full owner/cache/brain wiring, recovering any missing subsystems.
		/// </summary>
		private static void ValidateBotBrains(List<Player> players)
		{
			for (int i = 0; i < players.Count; i++)
			{
				try
				{
					Player player = players[i];
					if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.gameObject == null || player.HealthController == null || !player.HealthController.IsAlive)
						continue;

					string profileId = player.ProfileId ?? player.Profile?.Id;
					if (string.IsNullOrEmpty(profileId))
						continue;

					if (player.gameObject.GetComponent<BotBrain>() != null)
						continue;

					if (player.AIData?.BotOwner == null)
						continue;

					var botOwner = player.AIData.BotOwner;
					var cache = BotComponentCacheRegistry.GetOrCreate(botOwner);
					if (cache == null || cache.Bot == null || cache.AIRefactoredBotOwner == null)
						continue;

					if (!cache.AIRefactoredBotOwner.HasPersonality())
						cache.AIRefactoredBotOwner.InitProfile(cache.AIRefactoredBotOwner.PersonalityProfile, cache.AIRefactoredBotOwner.PersonalityName);

					GameWorldHandler.TryAttachBotBrain(botOwner);
				}
				catch (Exception ex)
				{
					Logger.LogError("[BotRecoveryService] ValidateBotBrains() error: " + ex);
				}
			}
		}
	}
}
