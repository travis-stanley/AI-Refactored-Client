// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Triggers suppression and panic behavior in AIRefactored bots.
    /// Simulates enemy fire pressure and flash-based fear effects.
    /// Bulletproof: all errors and edge cases are local; never break the AI stack.
    /// </summary>
    public static class BotSuppressionHelper
    {
        private const float FlashBlindDuration = 4.5f;

        /// <summary>
        /// Gets the BotOwner instance from a Player, if valid AI.
        /// </summary>
        public static BotOwner GetBotOwner(Player player)
        {
            try
            {
                return EFTPlayerUtil.IsValid(player) && player.IsAI
                    ? player.AIData?.BotOwner
                    : null;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the BotComponentCache from a Player, if valid AI.
        /// </summary>
        public static BotComponentCache GetCache(Player player)
        {
            try
            {
                return EFTPlayerUtil.IsValid(player) && player.IsAI
                    ? BotCacheUtility.GetCache(player)
                    : null;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Evaluates whether suppression should occur based on bot visibility, proximity, and ambient lighting.
        /// Bots hunker or panic realistically if line-of-sight is short, threat is near, or light is low.
        /// </summary>
        public static bool ShouldTriggerSuppression(Player player, float visibleDistThreshold = 12f, float ambientThreshold = 0.25f)
        {
            try
            {
                BotOwner owner = GetBotOwner(player);
                if (owner?.LookSensor == null)
                    return false;

                float visibleDist = owner.LookSensor.ClearVisibleDist;

                float ambientLight = 0.5f;
                try
                {
                    ambientLight = RenderSettings.ambientLight.grayscale;
                }
                catch
                {
                    // Use default if RenderSettings not available
                }

                // Suppress if visibility is low, or it's very dark
                return visibleDist < visibleDistThreshold || ambientLight < ambientThreshold;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Triggers suppression effects for a bot from a threat source.
        /// Applies panic, flash blindness, or "under fire" state based on bot context.
        /// </summary>
        public static void TrySuppressBot(Player player, Vector3 threatPosition, IPlayer source = null)
        {
            try
            {
                if (!EFTPlayerUtil.IsValid(player) || !player.IsAI)
                    return;

                BotOwner owner = GetBotOwner(player);
                BotComponentCache cache = GetCache(player);

                if (owner == null || cache == null || owner.IsDead)
                    return;

                // Always set "under fire" memory state for tactical realism
                if (owner.Memory != null)
                {
                    try { owner.Memory.SetUnderFire(source); } catch { }
                }

                // Prefer panic if not already panicking
                if (cache.PanicHandler != null && !cache.PanicHandler.IsPanicking)
                {
                    try { cache.PanicHandler.TriggerPanic(); } catch { }
                    return;
                }

                // Otherwise, if flash grenade/flashblind available, use it as fallback
                if (cache.FlashGrenade != null)
                {
                    try { cache.FlashGrenade.ForceBlind(); } catch { }
                }
            }
            catch
            {
                // All failures are local; never break caller logic.
            }
        }
    }
}
