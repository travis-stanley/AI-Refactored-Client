// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Coordinates bot combat state transitions across patrol, engage, attack, fallback, and investigation.
    /// Bulletproof: All subsystem failures are isolated; fallback to vanilla AI for movement/combat if required.
    /// </summary>
    public sealed class CombatStateMachine
    {
        #region Constants

        private const float MinTransitionDelay = 0.4f;
        private const float PatrolMinDuration = 1.25f;
        private const float PatrolCooldown = 12.0f;
        private const float ReentryCooldown = 3.0f;

        #endregion

        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;

        private AttackHandler _attack;
        private EngageHandler _engage;
        private FallbackHandler _fallback;
        private InvestigateHandler _investigate;
        private PatrolHandler _patrol;
        private EchoCoordinator _echo;

        private Vector3 _lastKnownEnemyPos;
        private bool _hasKnownEnemy;
        private float _lastStateChangeTime;
        private bool _initialized;
        private bool _isFallbackMode;

        #endregion

        #region Properties

        public Vector3 LastKnownEnemyPos => _lastKnownEnemyPos;
        public float LastStateChangeTime => _lastStateChangeTime;

        #endregion

        #region Public Methods

        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache == null || componentCache.Bot == null)
            {
                BotFallbackUtility.Trigger(this, null, "[CombatStateMachine] Initialization failed: null references.");
                _isFallbackMode = true;
                return;
            }

            try
            {
                _cache = componentCache;
                _bot = componentCache.Bot;

                _patrol = new PatrolHandler(_cache, PatrolMinDuration, PatrolCooldown);
                _investigate = new InvestigateHandler(_cache);
                _engage = new EngageHandler(_cache);
                _attack = new AttackHandler(_cache);
                _fallback = new FallbackHandler(_cache);
                _echo = new EchoCoordinator(_cache);

                _initialized = true;
                _isFallbackMode = false;
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception during Initialize.", ex);
                _isFallbackMode = true;
                _initialized = false;
            }
        }

        public bool IsInCombatState()
        {
            if (!_initialized || _isFallbackMode)
                return false;

            try
            {
                return (_fallback.IsActive() ||
                        _engage.IsEngaging() ||
                        _investigate.IsInvestigating() ||
                        _cache.ThreatSelector.CurrentTarget != null);
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in IsInCombatState.", ex);
                _isFallbackMode = true;
                return false;
            }
        }

        public void NotifyDamaged()
        {
            if (!_initialized || _isFallbackMode)
                return;

            try
            {
                float time = Time.time;
                if (_fallback.ShallUseNow(time))
                {
                    AssignFallbackIfNeeded();
                    if (_bot.BotTalk != null) _bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt);
                    _lastStateChangeTime = time;
                }
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in NotifyDamaged.", ex);
                _isFallbackMode = true;
            }
        }

        public void NotifyEchoInvestigate()
        {
            if (!_initialized || _isFallbackMode)
                return;

            try
            {
                float time = Time.time;
                if (_investigate.ShallUseNow(time, _lastStateChangeTime))
                {
                    _lastStateChangeTime = time;
                    if (_bot.BotTalk != null) _bot.BotTalk.TrySay(EPhraseTrigger.Cooperation);
                }
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in NotifyEchoInvestigate.", ex);
                _isFallbackMode = true;
            }
        }

        public void Tick(float time)
        {
            if (!_initialized || _isFallbackMode || _bot == null || _bot.IsDead || !EFTPlayerUtil.IsValid(_bot.GetPlayer))
                return;

            try
            {
                if (time - _lastStateChangeTime < MinTransitionDelay)
                    return;

                if (TryReenterCombatState(time))
                {
                    _lastStateChangeTime = time;
                    return;
                }

                if (ShouldTriggerSuppressedFallback(time))
                {
                    AssignFallbackIfNeeded();
                    if (_bot.BotTalk != null) _bot.BotTalk.TrySay(EPhraseTrigger.OnBeingHurt);

                    Vector3 fallback = _fallback.HasValidFallbackPath()
                        ? _fallback.GetFallbackPosition()
                        : _bot.Position;

                    _echo.EchoFallbackToSquad(fallback);
                    _lastStateChangeTime = time;
                    return;
                }

                if (_fallback.ShallUseNow(time))
                {
                    AssignFallbackIfNeeded();
                    _fallback.Tick(time, SetLastStateChangeTime);
                    return;
                }

                Player enemy = _cache.ThreatSelector.CurrentTarget;
                if (EFTPlayerUtil.IsValid(enemy))
                {
                    _lastKnownEnemyPos = EFTPlayerUtil.GetPosition(enemy);
                    _hasKnownEnemy = true;

                    string id = enemy.ProfileId;
                    if (id.Length > 0)
                        _cache.TacticalMemory.RecordEnemyPosition(_lastKnownEnemyPos, "Combat", id);

                    if (_bot.Mover != null && !_bot.Mover.Sprinting)
                        _bot.Sprint(true);

                    _echo.EchoSpottedEnemyToSquad(_lastKnownEnemyPos);
                }

                if (_engage.ShallUseNow())
                {
                    if (_engage.CanAttack())
                        _attack.Tick(time);
                    else
                        _engage.Tick();

                    _lastStateChangeTime = time;
                    return;
                }

                if (_investigate.ShallUseNow(time, _lastStateChangeTime))
                {
                    Vector3 target = _investigate.GetInvestigateTarget(_hasKnownEnemy ? _lastKnownEnemyPos : Vector3.zero);
                    if (target != Vector3.zero)
                    {
                        _investigate.Investigate(target);
                        _lastStateChangeTime = time;
                    }
                    return;
                }

                _patrol.Tick(time);
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in Tick.", ex);
                _isFallbackMode = true;
                if (_bot != null) BotFallbackUtility.FallbackToEFTLogic(_bot);
            }
        }

        public void TriggerFallback(Vector3 fallbackPos)
        {
            if (!_initialized || _isFallbackMode)
                return;

            try
            {
                _fallback.SetFallbackTarget(fallbackPos);
                if (_bot.BotTalk != null) _bot.BotTalk.TrySay(EPhraseTrigger.OnLostVisual);
                _lastStateChangeTime = Time.time;
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in TriggerFallback.", ex);
                _isFallbackMode = true;
            }
        }

        public void TrySetStanceFromNearbyCover(Vector3 pos)
        {
            try
            {
                _cache?.PoseController?.TrySetStanceFromNearbyCover(pos);
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in TrySetStanceFromNearbyCover.", ex);
                _isFallbackMode = true;
            }
        }

        #endregion

        #region Private Methods

        private void AssignFallbackIfNeeded()
        {
            if (_isFallbackMode)
                return;

            try
            {
                if (_fallback.HasValidFallbackPath())
                    return;

                if (_cache.Pathing == null)
                {
                    BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Pathing system is null — fallback skipped.");
                    return;
                }

                Vector3 lookDir = _bot.LookDirection;
                Vector3 retreatDir = lookDir.sqrMagnitude > 0.01f ? -lookDir.normalized : Vector3.back;

                List<Vector3> path = TempListPool.Rent<Vector3>();
                try
                {
                    path.Clear();
                    List<Vector3> generated = BotCoverRetreatPlanner.GetCoverRetreatPath(_bot, retreatDir, _cache.Pathing);
                    for (int i = 0; i < generated.Count; i++)
                        path.Add(generated[i]);

                    if (path.Count > 0)
                    {
                        Vector3 final = path[path.Count - 1];
                        _fallback.SetFallbackPath(path);
                        _fallback.SetFallbackTarget(final);
                        TrySetStanceFromNearbyCover(final);
                    }
                    else
                    {
                        BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Fallback path not found.");
                    }
                }
                catch (Exception ex)
                {
                    BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in fallback planner.", ex);
                }
                finally
                {
                    TempListPool.Return(path);
                }
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in AssignFallbackIfNeeded.", ex);
                _isFallbackMode = true;
            }
        }

        private bool ShouldTriggerSuppressedFallback(float time)
        {
            try
            {
                float composure = _cache.PanicHandler.GetComposureLevel();
                float delay = Mathf.Lerp(0.75f, 1.5f, 1f - composure);
                return _fallback.ShouldTriggerSuppressedFallback(time, _lastStateChangeTime, delay);
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in ShouldTriggerSuppressedFallback.", ex);
                _isFallbackMode = true;
                return false;
            }
        }

        private bool TryReenterCombatState(float time)
        {
            if (_isFallbackMode)
                return false;

            try
            {
                if (!_fallback.IsActive())
                    return false;

                if (_cache.ThreatSelector.CurrentTarget != null)
                {
                    _fallback.Cancel();
                    if (_bot.BotTalk != null) _bot.BotTalk.TrySay(EPhraseTrigger.OnEnemyConversation);
                    return true;
                }

                if (_cache.GroupSync != null && _cache.GroupSync.IsSquadReady())
                {
                    Vector3 self = _bot.Position;
                    IReadOnlyList<BotOwner> mates = _cache.GroupSync.GetTeammates();
                    for (int i = 0; i < mates.Count; i++)
                    {
                        BotOwner mate = mates[i];
                        if (mate != null && mate != _bot && !mate.IsDead)
                        {
                            float dist = Vector3.Distance(mate.Position, self);
                            if (dist < 12f)
                            {
                                _fallback.Cancel();
                                if (_bot.BotTalk != null) _bot.BotTalk.TrySay(EPhraseTrigger.Cooperation);
                                return true;
                            }
                        }
                    }
                }

                if (time - _lastStateChangeTime > ReentryCooldown)
                {
                    _fallback.Cancel();
                    if (_bot.BotTalk != null) _bot.BotTalk.TrySay(EPhraseTrigger.Ready);
                    return true;
                }

                return false;
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "[CombatStateMachine] Exception in TryReenterCombatState.", ex);
                _isFallbackMode = true;
                return false;
            }
        }

        private void SetLastStateChangeTime(CombatState state, float time)
        {
            _lastStateChangeTime = time;
        }

        #endregion
    }
}
