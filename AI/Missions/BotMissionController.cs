// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Central runtime mission handler.
    /// Coordinates bot objectives, mission switching, fallback, and extraction.
    /// Modularized into subsystems for maintainability and realism.
    /// </summary>
    public sealed class BotMissionController
    {
        #region Constants

        private const float GroupRejoinTimeout = 20f;
        private const float LootSyncDistance = 7f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly MissionEvaluator _evaluator;
        private readonly ObjectiveController _objectives;
        private readonly MissionSwitcher _switcher;
        private readonly MissionVoiceCoordinator _voice;
        private readonly BotExtractionDecisionSystem _extraction;

        private MissionType _missionType;
        private bool _forcedMission;
        private bool _inCombatPause;
        private float _groupWaitStart = -1f;
        private float _lastCombatTime;
        private float _lastUpdateTime;

        #endregion

        #region Enums

        /// <summary>
        /// Defines major mission modes the bot can follow.
        /// </summary>
        public enum MissionType
        {
            Loot,
            Fight,
            Quest
        }

        #endregion

        #region Constructor

        public BotMissionController(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null)
            {
                throw new ArgumentException("[BotMissionController] Invalid bot or cache reference.");
            }

            _bot = bot;
            _cache = cache;

            _switcher = new MissionSwitcher(bot, cache);
            _objectives = new ObjectiveController(bot, cache);
            _evaluator = new MissionEvaluator(bot, cache);
            _voice = new MissionVoiceCoordinator(bot);

            BotPersonalityProfile profile = cache.AIRefactoredBotOwner != null
                ? cache.AIRefactoredBotOwner.PersonalityProfile
                : new BotPersonalityProfile();

            _extraction = new BotExtractionDecisionSystem(bot, cache, profile);

            GroupMissionCoordinator.RegisterFromBot(bot);
            _missionType = GroupMissionCoordinator.GetMissionForGroup(bot);
            _objectives.SetInitialObjective(_missionType);

            cache.AIRefactoredBotOwner?.SetMissionController(this);

            string nickname = bot.Profile?.Info?.Nickname ?? "Unknown";
            Logger.LogDebug("[BotMissionController] Assigned mission: " + _missionType + " for bot " + nickname);
        }

        #endregion

        #region Public Methods

        public void SetForcedMission(MissionType mission)
        {
            _missionType = mission;
            _forcedMission = true;
        }

        public void Tick(float time)
        {
            Player player = _bot.GetPlayer;
            IHealthController health = player?.HealthController;

            if (_bot.IsDead || player == null || health == null || !health.IsAlive)
            {
                return;
            }

            if (_cache.IsBlinded || (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking))
            {
                return;
            }

            _evaluator.UpdateStuckCheck(time);

            if (!_forcedMission)
            {
                _switcher.Evaluate(ref _missionType, time, SwitchToFight, _objectives.ResumeQuesting, _evaluator.IsGroupAligned);
            }

            if (_cache.Combat != null && _cache.Combat.IsInCombatState())
            {
                _lastCombatTime = time;
                if (_missionType == MissionType.Quest)
                {
                    _inCombatPause = true;
                }
            }

            if (_inCombatPause && time - _lastCombatTime > 4f)
            {
                _inCombatPause = false;
                _objectives.ResumeQuesting();
            }

            _extraction.Tick(time);

            if (!_evaluator.IsGroupAligned() && _missionType != MissionType.Fight)
            {
                if (_groupWaitStart < 0f)
                {
                    _groupWaitStart = time;
                }

                if (time - _groupWaitStart < GroupRejoinTimeout)
                {
                    return;
                }

                _groupWaitStart = -1f;
            }
            else
            {
                _groupWaitStart = -1f;
            }

            if (time - _lastUpdateTime > GetCooldown())
            {
                _objectives.OnObjectiveReached(_missionType);
                _lastUpdateTime = time;
            }

            if (!_inCombatPause &&
                Vector3.Distance(_bot.Position, _objectives.CurrentObjective) < LootSyncDistance)
            {
                OnObjectiveReached();
            }
        }

        #endregion

        #region Private Methods

        private void OnObjectiveReached()
        {
            if (_missionType == MissionType.Loot &&
                _cache.LootScanner != null &&
                _cache.GroupBehavior != null &&
                _cache.GroupBehavior.GroupSync != null)
            {
                Vector3 myPos = _bot.Position;
                _cache.GroupBehavior.GroupSync.BroadcastLootPoint(myPos);

                Vector3? fallback = _cache.GroupBehavior.GroupSync.GetSharedFallbackTarget();
                if (fallback.HasValue && Vector3.Distance(myPos, fallback.Value) > 4f)
                {
                    Logger.LogDebug("[BotMissionController] Loot canceled — squad fallback active.");
                    return;
                }

                _cache.Movement.EnterLootingMode();
                _cache.PoseController.LockCrouchPose();

                _cache.LootScanner.TryLootNearby();
                _cache.DeadBodyScanner?.TryLootNearby();

                _cache.Movement.ExitLootingMode();
                _voice.OnLoot();
            }

            _objectives.OnObjectiveReached(_missionType);
        }

        private void SwitchToFight()
        {
            _missionType = MissionType.Fight;
            _objectives.SetInitialObjective(_missionType);
            _voice.OnMissionSwitch();

            string groupId = _bot.Profile?.Info?.GroupId;
            if (!string.IsNullOrEmpty(groupId))
            {
                GroupMissionCoordinator.ForceMissionForGroup(groupId, MissionType.Fight);
            }
        }

        private float GetCooldown()
        {
            return 10f + Random.Range(0f, 5f);
        }

        #endregion
    }
}
