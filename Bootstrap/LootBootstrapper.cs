// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All failures are locally contained, never break other subsystems, and always trigger fallback isolation.
//   See: AIRefactored “Bulletproof Fallback & Isolation Safety Rule Set” for audit compliance.
// </auto-generated>

namespace AIRefactored.Bootstrap
{
	using System;
	using System.Collections.Generic;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Looting;
	using AIRefactored.Core;
	using AIRefactored.Pools;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using EFT.Interactive;
	using UnityEngine;

	/// <summary>
	/// Registers all lootable containers and loose loot items in the scene.
	/// Links dead player corpses to nearby loot containers for bot prioritization.
	/// All failures are locally contained—never propagate error or break global systems.
	/// </summary>
	public static class LootBootstrapper
	{
		#region Constants

		private const float MaxCorpseLinkDistance = 1.5f;

		#endregion

		#region Fields

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		#endregion

		#region Public Methods

		/// <summary>
		/// Registers all scene lootable containers and loose items.
		/// Bulletproof: Any error disables only this pass, never breaks caller or system.
		/// </summary>
		public static void RegisterAllLoot()
		{
			if (!GameWorldHandler.IsInitialized || !GameWorldHandler.IsHost)
			{
				Logger.LogDebug("[LootBootstrapper] Skipped loot registration — not host or not ready.");
				return;
			}

			try
			{
				LootableContainer[] containers = null;
				LootItem[] items = null;
				try
				{
					containers = UnityEngine.Object.FindObjectsOfType<LootableContainer>();
				}
				catch (Exception ex)
				{
					Logger.LogError("[LootBootstrapper] Failed to find LootableContainer: " + ex);
				}
				try
				{
					items = UnityEngine.Object.FindObjectsOfType<LootItem>();
				}
				catch (Exception ex)
				{
					Logger.LogError("[LootBootstrapper] Failed to find LootItem: " + ex);
				}

				if (containers != null && containers.Length > 0)
				{
					RegisterContainers(containers);
				}
				if (items != null && items.Length > 0)
				{
					RegisterLooseItems(items);
				}
			}
			catch (Exception ex)
			{
				Logger.LogError("[LootBootstrapper] RegisterAllLoot() failed: " + ex);
			}
		}

		#endregion

		#region Private Methods

		private static void RegisterContainers(LootableContainer[] containers)
		{
			for (int i = 0; i < containers.Length; i++)
			{
				LootableContainer container = containers[i];
				if (container == null || !container.enabled || container.transform == null)
				{
					continue;
				}

				try
				{
					LootRegistry.RegisterContainer(container);
					TryLinkToCorpse(container);
				}
				catch (Exception ex)
				{
					Logger.LogError("[LootBootstrapper] RegisterContainers() failed for container: " + ex);
				}
			}
		}

		private static void RegisterLooseItems(LootItem[] items)
		{
			for (int i = 0; i < items.Length; i++)
			{
				LootItem item = items[i];
				if (item == null || !item.enabled)
				{
					continue;
				}

				try
				{
					LootRegistry.RegisterItem(item);
				}
				catch (Exception ex)
				{
					Logger.LogError("[LootBootstrapper] RegisterLooseItems() failed for item: " + ex);
				}
			}
		}

		private static void TryLinkToCorpse(LootableContainer container)
		{
			if (container == null || container.transform == null)
			{
				return;
			}

			Vector3 containerPosition = container.transform.position;
			GameWorld world = GameWorldHandler.Get();
			if (world == null || world.RegisteredPlayers == null || world.RegisteredPlayers.Count == 0)
			{
				return;
			}

			List<Player> deadPlayers = null;
			List<IPlayer> all = world.RegisteredPlayers;

			try
			{
				deadPlayers = TempListPool.Rent<Player>();

				for (int i = 0; i < all.Count; i++)
				{
					Player player = EFTPlayerUtil.AsEFTPlayer(all[i]);
					if (player != null && player.HealthController != null && !player.HealthController.IsAlive)
					{
						deadPlayers.Add(player);
					}
				}

				for (int i = 0; i < deadPlayers.Count; i++)
				{
					Player corpse = deadPlayers[i];
					string profileId = corpse.Profile != null ? corpse.Profile.Id : null;
					if (string.IsNullOrEmpty(profileId) || DeadBodyContainerCache.Contains(profileId))
					{
						continue;
					}

					Vector3 corpsePosition = EFTPlayerUtil.GetPosition(corpse);
					if (Vector3.Distance(containerPosition, corpsePosition) <= MaxCorpseLinkDistance)
					{
						DeadBodyContainerCache.Register(corpse, container);
						string nickname = corpse.Profile != null && corpse.Profile.Info != null
							? corpse.Profile.Info.Nickname
							: "Unnamed";
						Logger.LogDebug("[LootBootstrapper] Linked container to corpse: " + nickname);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				Logger.LogError("[LootBootstrapper] TryLinkToCorpse() failed: " + ex);
			}
			finally
			{
				if (deadPlayers != null)
				{
					TempListPool.Return(deadPlayers);
				}
			}
		}

		#endregion
	}
}
