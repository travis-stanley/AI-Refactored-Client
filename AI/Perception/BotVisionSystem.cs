// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All visual perception logic is fully null-guarded, multiplayer/headless safe, and pooling-optimized.
//   Realism: Field-of-view, motion boosting, fog and flare occlusion, delayed commitment, bone scanning, and squad sync.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.Animations;
    using UnityEngine;

    /// <summary>
    /// Handles bot visual cone scanning, visibility tracking, and confidence-based enemy commitment.
    /// Bulletproof: full null safety, realistic vision, multiplayer/headless safe.
    /// </summary>
    public sealed class BotVisionSystem
    {
        #region Constants

        private const float AutoDetectRadius = 4f;
        private const float BaseViewConeAngle = 120f;
        private const float BoneConfidenceDecay = 0.1f;
        private const float BoneConfidenceThreshold = 0.45f;
        private const float MaxDetectionDistance = 120f;
        private const float SuppressionMissChance = 0.2f;
        private const float MotionBoost = 0.2f;

        private static readonly Vector3 EyeOffset = new Vector3(0f, 1.4f, 0f);

        private static readonly PlayerBoneType[] BonesToCheck =
        {
            PlayerBoneType.Head, PlayerBoneType.Spine, PlayerBoneType.Ribcage,
            PlayerBoneType.LeftShoulder, PlayerBoneType.RightShoulder,
            PlayerBoneType.Pelvis, PlayerBoneType.LeftThigh1, PlayerBoneType.RightThigh1
        };

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotTacticalMemory _memory;
        private BotPersonalityProfile _profile;
        private float _lastCommitTime;
        private bool _failed;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            try
            {
                if (cache == null || cache.Bot == null || cache.TacticalMemory == null || cache.AIRefactoredBotOwner == null)
                {
                    _failed = true;
                    return;
                }

                _bot = cache.Bot;
                _cache = cache;
                _memory = cache.TacticalMemory;
                _profile = cache.AIRefactoredBotOwner.PersonalityProfile;
                _lastCommitTime = -999f;
                _failed = false;
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotVisionSystem] Initialize exception: {ex}");
            }
        }

        #endregion

        #region Tick

        public void Tick(float time)
        {
            if (_failed || !IsValid())
                return;

            try
            {
                Vector3 eye = _bot.Position + EyeOffset;
                Vector3 forward = _bot.LookDirection;

                float fogFactor = RenderSettings.fog ? Mathf.Clamp01(RenderSettings.fogDensity * 4f) : 0f;
                float ambient = RenderSettings.ambientLight.grayscale;
                float viewCone = Mathf.Lerp(BaseViewConeAngle, 60f, 1f - ambient);

                Transform head = BotCacheUtility.Head(_cache);
                if (head != null && FlashlightRegistry.IsExposingBot(head, out _))
                {
                    viewCone *= 0.6f;
                }

                List<Player> players = GameWorldHandler.GetAllAlivePlayers();
                Player bestTarget = null;
                float bestDist = float.MaxValue;

                for (int i = 0, count = players.Count; i < count; i++)
                {
                    Player p = players[i];
                    if (!IsValidTarget(p))
                        continue;

                    Vector3 pos = EFTPlayerUtil.GetPosition(p);
                    float dist = Vector3.Distance(eye, pos);
                    float maxVis = MaxDetectionDistance * (1f - fogFactor);

                    if (dist > maxVis)
                        continue;

                    bool inCone = IsInViewCone(forward, eye, pos, viewCone);
                    bool close = dist <= AutoDetectRadius;
                    bool canSee = HasLineOfSight(eye, p);

                    if ((inCone && canSee) || (close && canSee))
                    {
                        if (dist < bestDist)
                        {
                            bestDist = dist;
                            bestTarget = p;
                        }
                    }
                    else if ((inCone || close) && !canSee && !FikaHeadlessDetector.IsHeadless)
                    {
                        _bot.BotTalk?.TrySay(EPhraseTrigger.OnBeingHurt);
                    }
                }

                if (bestTarget != null)
                {
                    Vector3 pos = EFTPlayerUtil.GetPosition(bestTarget);
                    _memory.RecordEnemyPosition(pos, "Visual", bestTarget.ProfileId);
                    ShareMemoryToSquad(pos);
                    TrackVisibleBones(eye, bestTarget, fogFactor);
                    EvaluateTargetConfidence(bestTarget, time);
                }
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotVisionSystem] Tick exception: {ex}");
            }
        }

        #endregion

        #region Target Evaluation

        private void EvaluateTargetConfidence(Player target, float time)
        {
            try
            {
                TrackedEnemyVisibility tracker = _cache.VisibilityTracker;
                if (tracker == null || !tracker.HasEnoughData)
                    return;

                float confidence = tracker.GetOverallConfidence();
                if (_bot.Memory.IsUnderFire && UnityEngine.Random.value < SuppressionMissChance)
                    return;

                if (confidence < BoneConfidenceThreshold)
                    return;

                CommitEnemyIfAllowed(target, time);
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotVisionSystem] EvaluateTargetConfidence exception: {ex}");
            }
        }

        private void CommitEnemyIfAllowed(Player target, float time)
        {
            try
            {
                if (!EFTPlayerUtil.IsEnemyOf(_bot, target))
                    return;

                float delay = Mathf.Lerp(0.1f, 0.6f, 1f - _profile.ReactionTime);
                if (time - _lastCommitTime < delay)
                    return;

                IPlayer enemy = EFTPlayerUtil.AsSafeIPlayer(target);
                if (enemy == null || _bot.BotsGroup == null)
                    return;

                _bot.BotsGroup.AddEnemy(enemy, EBotEnemyCause.addPlayer);
                _lastCommitTime = time;

                if (!FikaHeadlessDetector.IsHeadless)
                {
                    _bot.BotTalk?.TrySay(EPhraseTrigger.OnEnemyConversation);
                }
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotVisionSystem] CommitEnemyIfAllowed exception: {ex}");
            }
        }

        #endregion

        #region Bone Tracking

        private void TrackVisibleBones(Vector3 eye, Player target, float fog)
        {
            try
            {
                if (_cache.VisibilityTracker == null)
                    _cache.VisibilityTracker = new TrackedEnemyVisibility(_bot.Transform.Original);

                TrackedEnemyVisibility tracker = _cache.VisibilityTracker;

                if (target.TryGetComponent(out PlayerSpiritBones bones))
                {
                    Bounds[] bounds = TempBoundsPool.Rent(BonesToCheck.Length);

                    try
                    {
                        for (int i = 0; i < BonesToCheck.Length; i++)
                        {
                            Transform bone = bones.GetBone(BonesToCheck[i]).Original;
                            if (bone != null && !Physics.Linecast(eye, bone.position, out _, AIRefactoredLayerMasks.LineOfSightMask))
                            {
                                bounds[i] = new Bounds(bone.position, Vector3.one * 0.2f);
                                float boost = IsMovingFast(target) ? MotionBoost : 0f;
                                tracker.UpdateBoneVisibility(BonesToCheck[i].ToString(), bone.position, boost, fog);
                            }
                        }
                    }
                    finally
                    {
                        TempBoundsPool.Return(bounds);
                    }
                }
                else
                {
                    Transform tf = EFTPlayerUtil.GetTransform(target);
                    if (tf != null && !Physics.Linecast(eye, tf.position, out _, AIRefactoredLayerMasks.LineOfSightMask))
                    {
                        tracker.UpdateBoneVisibility("Body", tf.position);
                    }
                }

                tracker.DecayConfidence(BoneConfidenceDecay * Time.deltaTime);
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotVisionSystem] TrackVisibleBones exception: {ex}");
            }
        }

        #endregion

        #region Memory Sharing

        private void ShareMemoryToSquad(Vector3 pos)
        {
            if (_cache.GroupSync == null)
                return;

            List<BotComponentCache> teammates = TempListPool.Rent<BotComponentCache>();
            try
            {
                IReadOnlyList<BotOwner> squad = _cache.GroupSync.GetTeammates();
                if (squad == null || squad.Count == 0)
                    return;

                for (int i = 0; i < squad.Count; i++)
                {
                    BotOwner mate = squad[i];
                    if (mate == null)
                        continue;

                    BotComponentCache comp = BotComponentCacheRegistry.TryGetExisting(mate);
                    if (comp != null)
                        teammates.Add(comp);
                }

                if (teammates.Count > 0)
                    _memory.ShareMemoryWith(teammates);
            }
            finally
            {
                TempListPool.Return(teammates);
            }
        }

        #endregion

        #region Utility

        private static bool HasLineOfSight(Vector3 from, Player target)
        {
            Transform t = EFTPlayerUtil.GetTransform(target);
            if (t == null)
                return false;

            Vector3 to = t.position + EyeOffset;
            return !Physics.Linecast(from, to, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask)
                   || hit.collider.transform.root == t.root;
        }

        private static bool IsInViewCone(Vector3 forward, Vector3 origin, Vector3 target, float angle)
        {
            return Vector3.Angle(forward, target - origin) <= angle * 0.5f;
        }

        private static bool IsMovingFast(Player p)
        {
            return p != null && p.Velocity.sqrMagnitude > 2.25f;
        }

        private bool IsValid()
        {
            return !_failed &&
                   _bot != null &&
                   _cache != null &&
                   _profile != null &&
                   _memory != null &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   !_bot.IsDead &&
                   GameWorldHandler.IsSafeToInitialize;
        }

        private bool IsValidTarget(Player t)
        {
            return EFTPlayerUtil.IsValid(t) &&
                   t.ProfileId != _bot.ProfileId &&
                   EFTPlayerUtil.IsEnemyOf(_bot, t);
        }

        #endregion

        #region API

        /// <summary>
        /// Returns true if the given player is visible right now (tracked by confidence).
        /// </summary>
        public bool IsTargetVisible(Player enemy)
        {
            if (_cache?.VisibilityTracker == null || enemy == null)
                return false;
            return _cache.VisibilityTracker.GetOverallConfidence() > BoneConfidenceThreshold;
        }

        #endregion
    }
}
