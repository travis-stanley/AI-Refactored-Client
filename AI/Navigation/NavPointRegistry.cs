// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Nav fallback logic must trigger EFT or static fallback when registry is empty.
//   If registry or fallback fails, AIRefactored nav disables for the raid and vanilla logic is used.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Bootstrap;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Unity.AI.Navigation;
    using UnityEngine;

    public enum SpatialIndexMode
    {
        None,
        Grid,
        Quadtree,
        GridAndQuadtree
    }

    /// <summary>
    /// Central registry for all tactical navigation points. Provides fast queries for pathfinding, cover, fallback, and spatial AI systems.
    /// Enforces safe access: registry may not be used until fully built/ready.
    /// If the registry or fallback fails, disables AIRefactored nav and lets vanilla logic take over.
    /// </summary>
    public static class NavPointRegistry
    {
        #region Fields

        private static readonly List<NavPoint> Points = new List<NavPoint>(512);
        private static readonly HashSet<Vector3> Unique = new HashSet<Vector3>();

        private static readonly Dictionary<string, SpatialIndexMode> IndexModeMap =
            new Dictionary<string, SpatialIndexMode>(StringComparer.OrdinalIgnoreCase)
            {
                { "woods", SpatialIndexMode.Quadtree },
                { "shoreline", SpatialIndexMode.Quadtree },
                { "lighthouse", SpatialIndexMode.Quadtree },
                { "interchange", SpatialIndexMode.Quadtree },
                { "bigmap", SpatialIndexMode.Quadtree },
                { "sandbox", SpatialIndexMode.Grid },
                { "sandbox_high", SpatialIndexMode.Grid },
                { "factory4_day", SpatialIndexMode.Grid },
                { "factory4_night", SpatialIndexMode.Grid },
                { "laboratory", SpatialIndexMode.Grid },
                { "tarkovstreets", SpatialIndexMode.Grid },
                { "rezervbase", SpatialIndexMode.Grid }
            };

        private static QuadtreeNavGrid _quadtree;
        private static SpatialNavGrid _spatialGrid;
        private static bool _useQuadtree;
        private static bool _useSpatial;
        private static bool _aiRefactoredNavDisabled;

        private static ManualLogSource Logger => Plugin.LoggerInstance;

        #endregion

        #region Properties

        public static int Count => Points.Count;
        public static bool IsReady => Points.Count > 0 && !_aiRefactoredNavDisabled;
        public static bool IsEmpty => Points.Count == 0 || _aiRefactoredNavDisabled;
        public static bool IsInitialized { get; private set; }
        public static bool AIRefactoredNavDisabled => _aiRefactoredNavDisabled;

        #endregion

        #region Lifecycle

        public static void Initialize()
        {
            Points.Clear();
            Unique.Clear();
            _quadtree?.Clear();
            _spatialGrid?.Clear();
            _quadtree = null;
            _spatialGrid = null;
            _useQuadtree = false;
            _useSpatial = false;
            _aiRefactoredNavDisabled = false;
            IsInitialized = true;
            Logger.LogDebug("[NavPointRegistry] Initialized.");
        }

        public static void Clear()
        {
            Points.Clear();
            Unique.Clear();
            _quadtree?.Clear();
            _spatialGrid?.Clear();
            _aiRefactoredNavDisabled = false;
            IsInitialized = false;
        }

        /// <summary>
        /// Disables all AIRefactored nav for the rest of the session/raid.
        /// All queries will pass control to vanilla logic.
        /// </summary>
        public static void Disable()
        {
            if (!_aiRefactoredNavDisabled)
            {
                _aiRefactoredNavDisabled = true;
                Points.Clear();
                Unique.Clear();
                _quadtree?.Clear();
                _spatialGrid?.Clear();
                Logger.LogWarning("[NavPointRegistry] AIRefactored nav logic DISABLED due to fatal error. Reverting to vanilla Tarkov navigation.");
            }
        }

        #endregion

        #region Loading & Save

        public static void LoadFrom(List<NavPointData> source)
        {
            if (_aiRefactoredNavDisabled)
                return;

            Initialize();

            if (source == null || source.Count == 0)
            {
                Logger.LogWarning("[NavPointRegistry] LoadFrom failed — no points provided.");
                Disable();
                return;
            }

            for (int i = 0; i < source.Count; i++)
            {
                NavPointData data = source[i];
                if (!IsValid(data.Position) || !Unique.Add(data.Position))
                {
                    continue;
                }

                var point = new NavPoint(
                    data.Position,
                    data.IsCover,
                    data.Tag,
                    data.Elevation,
                    data.IsIndoor,
                    data.IsJumpable,
                    data.CoverAngle,
                    data.Zone,
                    data.ElevationBand);

                Points.Add(point);
            }

            AutoEnableIndexModeSafe();
            Logger.LogInfo("[NavPointRegistry] ✅ Loaded " + Points.Count + " points from cache.");
            IsInitialized = Points.Count > 0;
            if (!IsInitialized)
                Disable();
        }

        public static List<NavPointData> GetAllPoints()
        {
            var result = TempListPool.Rent<NavPointData>();
            for (int i = 0; i < Points.Count; i++)
            {
                var p = Points[i];
                result.Add(new NavPointData(
                    p.WorldPos,
                    p.IsCover,
                    p.Tag,
                    p.Elevation,
                    p.IsIndoor,
                    p.IsJumpable,
                    p.CoverAngle,
                    p.Zone,
                    p.ElevationBand));
            }
            return result;
        }

        #endregion

        #region Registration

        public static void RegisterAll(string mapId)
        {
            if (_aiRefactoredNavDisabled)
            {
                Logger.LogWarning("[NavPointRegistry] RegisterAll() skipped — AIRefactored nav disabled.");
                return;
            }

            if (!WorldInitState.IsInPhase(WorldPhase.WorldReady))
            {
                Logger.LogWarning("[NavPointRegistry] RegisterAll() skipped — world not ready.");
                return;
            }

            if (!GameWorldHandler.IsLocalHost() && !FikaHeadlessDetector.IsHeadless)
            {
                Logger.LogDebug("[NavPointRegistry] Skipped RegisterAll — not host.");
                return;
            }

            if (IsInitialized && Points.Count > 0)
            {
                Logger.LogDebug("[NavPointRegistry] Already built for this raid, skipping RegisterAll.");
                return;
            }

            Initialize();

            Logger.LogDebug("[NavPointRegistry] Registering nav points for map: " + mapId);

            try
            {
                if (UnityEngine.Object.FindObjectOfType<NavMeshSurface>() == null)
                {
                    Logger.LogWarning("[NavPointRegistry] No NavMeshSurface found.");
                    Disable();
                    return;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[NavPointRegistry] Error checking NavMeshSurface: " + ex);
                Disable();
                return;
            }

            NavPointBootstrapper.RegisterAll(mapId);

            if (Count == 0)
            {
                Logger.LogWarning("[NavPointRegistry] RegisterAll completed but point list is still empty.");
                Disable();
            }

            AutoEnableIndexModeSafe();
            IsInitialized = Points.Count > 0 && !_aiRefactoredNavDisabled;
        }

        public static void Register(Vector3 pos, bool isCover = false, string tag = "generic", float elevation = 0f, bool isIndoor = false, bool isJumpable = false, float coverAngle = 0f)
        {
            if (_aiRefactoredNavDisabled)
                return;

            if (!IsValid(pos) || !Unique.Add(pos))
            {
                return;
            }

            string elevationBand = GetElevationBand(elevation);

            NavPoint point = new NavPoint(pos, isCover, tag, elevation, isIndoor, isJumpable, coverAngle, "Unknown", elevationBand);
            Points.Add(point);

            _quadtree?.Insert(pos);
            _spatialGrid?.Register(new NavPointData(pos, isCover, tag, elevation, isIndoor, isJumpable, coverAngle, "Unknown", elevationBand));
        }

        #endregion

        #region Query

        public static List<Vector3> QueryNearby(Vector3 origin, float radius, Predicate<Vector3> filter = null, bool coverOnly = false)
        {
            var result = TempListPool.Rent<Vector3>();

            if (_aiRefactoredNavDisabled || Points.Count == 0)
            {
                return result;
            }

            float radiusSq = radius * radius;

            if (_useQuadtree && _quadtree != null)
            {
                var raw = _quadtree.QueryRaw(origin, radius, filter);
                for (int i = 0; i < raw.Count; i++)
                {
                    if (TryGetPoint(raw[i], out var nav) && (!coverOnly || nav.IsCover))
                    {
                        result.Add(raw[i]);
                    }
                }
                return result;
            }

            if (_useSpatial && _spatialGrid != null)
            {
                var raw = _spatialGrid.Query(origin, radius, null);
                for (int i = 0; i < raw.Count; i++)
                {
                    Vector3 pos = raw[i].Position;
                    if ((!coverOnly || raw[i].IsCover) && (filter == null || filter(pos)))
                    {
                        result.Add(pos);
                    }
                }
                return result;
            }

            for (int i = 0; i < Points.Count; i++)
            {
                Vector3 pos = Points[i].WorldPos;
                if ((pos - origin).sqrMagnitude <= radiusSq && (!coverOnly || Points[i].IsCover))
                {
                    if (filter == null || filter(pos))
                    {
                        result.Add(pos);
                    }
                }
            }
            return result;
        }

        public static List<NavPointData> QueryNearby(Vector3 origin, float radius, Predicate<NavPointData> filter = null)
        {
            var result = TempListPool.Rent<NavPointData>();

            if (_aiRefactoredNavDisabled || Points.Count == 0)
            {
                return result;
            }

            float radiusSq = radius * radius;

            if (_useSpatial && _spatialGrid != null)
            {
                var candidates = _spatialGrid.Query(origin, radius, filter);
                result.AddRange(candidates);
                return result;
            }

            if (_useQuadtree && _quadtree != null)
            {
                var raw = _quadtree.Query(origin, radius, filter);
                result.AddRange(raw);
                return result;
            }

            for (int i = 0; i < Points.Count; i++)
            {
                var p = Points[i];
                if ((p.WorldPos - origin).sqrMagnitude <= radiusSq)
                {
                    var data = new NavPointData(
                        p.WorldPos,
                        p.IsCover,
                        p.Tag,
                        p.Elevation,
                        p.IsIndoor,
                        p.IsJumpable,
                        p.CoverAngle,
                        p.Zone,
                        p.ElevationBand);

                    if (filter == null || filter(data))
                    {
                        result.Add(data);
                    }
                }
            }
            return result;
        }

        public static string GetTag(Vector3 pos) => TryGetPoint(pos, out var p) ? p.Tag : "untagged";
        public static bool IsCoverPoint(Vector3 pos) => TryGetPoint(pos, out var p) && p.IsCover;
        public static bool IsIndoor(Vector3 pos) => TryGetPoint(pos, out var p) && p.IsIndoor;
        public static bool IsJumpable(Vector3 pos) => TryGetPoint(pos, out var p) && p.IsJumpable;

        #endregion

        #region Indexing

        public static void AutoEnableIndexMode(string mapId)
        {
            if (_aiRefactoredNavDisabled)
                return;

            if (string.IsNullOrEmpty(mapId))
            {
                Logger.LogWarning("[NavPointRegistry] AutoEnableIndexMode skipped — mapId null.");
                return;
            }

            if (!IndexModeMap.TryGetValue(mapId, out SpatialIndexMode mode))
            {
                mode = SpatialIndexMode.Grid;
            }

            EnableSpatialIndexing(
                enableQuadtree: mode == SpatialIndexMode.Quadtree || mode == SpatialIndexMode.GridAndQuadtree,
                enableSpatialGrid: mode == SpatialIndexMode.Grid || mode == SpatialIndexMode.GridAndQuadtree);

            Logger.LogDebug($"[NavPointRegistry] Indexing mode for map '{mapId}' => {mode}");
        }

        private static void AutoEnableIndexModeSafe()
        {
            if (Points.Count == 0)
                return;
            string mapId = GameWorldHandler.TryGetValidMapName();
            if (string.IsNullOrEmpty(mapId))
                return;
            AutoEnableIndexMode(mapId);
        }

        public static void EnableSpatialIndexing(bool enableQuadtree, bool enableSpatialGrid = true)
        {
            if (_aiRefactoredNavDisabled)
                return;

            _useQuadtree = enableQuadtree;
            _useSpatial = enableSpatialGrid;

            _quadtree = enableQuadtree ? BuildQuadtree() : null;
            _spatialGrid = enableSpatialGrid ? BuildSpatialGrid() : null;
        }

        #endregion

        #region Internal

        private static bool TryGetPoint(Vector3 pos, out NavPoint point)
        {
            for (int i = 0; i < Points.Count; i++)
            {
                if (Points[i].WorldPos == pos)
                {
                    point = Points[i];
                    return true;
                }
            }
            point = default;
            return false;
        }

        public static Vector3 GetClosestPosition(Vector3 origin)
        {
            if (_aiRefactoredNavDisabled || Points.Count == 0)
            {
                return origin;
            }

            Vector3 closest = Vector3.zero;
            float minDistSq = float.MaxValue;

            if (_useQuadtree && _quadtree != null)
            {
                foreach (var pos in _quadtree.QueryRaw(origin, 25f, null))
                {
                    float distSq = (origin - pos).sqrMagnitude;
                    if (distSq < minDistSq)
                    {
                        minDistSq = distSq;
                        closest = pos;
                    }
                }

                if (IsValid(closest))
                    return closest;
            }

            if (_useSpatial && _spatialGrid != null)
            {
                foreach (var p in _spatialGrid.Query(origin, 25f, null))
                {
                    float distSq = (origin - p.Position).sqrMagnitude;
                    if (distSq < minDistSq)
                    {
                        minDistSq = distSq;
                        closest = p.Position;
                    }
                }

                if (IsValid(closest))
                    return closest;
            }

            foreach (var p in Points)
            {
                float distSq = (origin - p.WorldPos).sqrMagnitude;
                if (distSq < minDistSq)
                {
                    minDistSq = distSq;
                    closest = p.WorldPos;
                }
            }
            return IsValid(closest) ? closest : origin;
        }

        private static bool IsValid(Vector3 pos)
        {
            return pos != Vector3.zero &&
                !float.IsNaN(pos.x) &&
                !float.IsNaN(pos.y) &&
                !float.IsNaN(pos.z);
        }

        private static string GetElevationBand(float elevation)
        {
            if (elevation < 2f) return "Low";
            if (elevation < 7f) return "Mid";
            return "High";
        }

        private sealed class NavPoint
        {
            public NavPoint(Vector3 pos, bool isCover, string tag, float elevation, bool isIndoor, bool isJumpable, float coverAngle, string zone, string elevationBand)
            {
                WorldPos = pos;
                IsCover = isCover;
                Tag = tag;
                Elevation = elevation;
                IsIndoor = isIndoor;
                IsJumpable = isJumpable;
                CoverAngle = coverAngle;
                Zone = zone;
                ElevationBand = elevationBand;
            }

            public Vector3 WorldPos { get; }
            public bool IsCover { get; }
            public string Tag { get; }
            public float Elevation { get; }
            public bool IsIndoor { get; }
            public bool IsJumpable { get; }
            public float CoverAngle { get; }
            public string Zone { get; }
            public string ElevationBand { get; }
        }

        private static QuadtreeNavGrid BuildQuadtree()
        {
            if (Points.Count == 0)
            {
                return null;
            }

            float minX = float.MaxValue;
            float maxX = float.MinValue;
            float minZ = float.MaxValue;
            float maxZ = float.MinValue;

            for (int i = 0; i < Points.Count; i++)
            {
                Vector3 pos = Points[i].WorldPos;
                minX = Mathf.Min(minX, pos.x);
                maxX = Mathf.Max(maxX, pos.x);
                minZ = Mathf.Min(minZ, pos.z);
                maxZ = Mathf.Max(maxZ, pos.z);
            }

            Vector2 center = new Vector2((minX + maxX) * 0.5f, (minZ + maxZ) * 0.5f);
            float size = Mathf.Max(maxX - minX, maxZ - minZ) + 20f;

            QuadtreeNavGrid tree = new QuadtreeNavGrid(center, size);
            for (int i = 0; i < Points.Count; i++)
            {
                tree.Insert(Points[i].WorldPos);
            }

            Logger.LogDebug("[NavPointRegistry] Quadtree built for " + Points.Count + " points.");
            return tree;
        }

        private static SpatialNavGrid BuildSpatialGrid()
        {
            var grid = new SpatialNavGrid(5f);
            for (int i = 0; i < Points.Count; i++)
            {
                var p = Points[i];
                var data = new NavPointData(p.WorldPos, p.IsCover, p.Tag, p.Elevation, p.IsIndoor, p.IsJumpable, p.CoverAngle, p.Zone, p.ElevationBand);
                grid.Register(data);
            }

            Logger.LogDebug("[NavPointRegistry] Spatial grid built for " + Points.Count + " points.");
            return grid;
        }

        #endregion
    }
}
