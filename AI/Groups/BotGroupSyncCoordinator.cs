// <auto-generated>
//   AI-Refactored: BotGroupSyncCoordinator.cs (Ultimate Realism – BotBrain-Driven Edition)
//   All squad sync, fallback, danger, loot, and extraction comms are strictly BotBrain tick-driven.
//   No timers, coroutines, or async logic outside BotBrain. All errors are strictly local.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Coordinates squad-level fallback, loot, extract, and panic signal sharing.
    /// All sync is handled in BotBrain's tick, never internally.
    /// Bulletproof: No error propagates; all allocations use pooling.
    /// Fully humanized: All signal sharing, fallback, and loot arbitration is squad-aware, personality-influenced, and error-resilient.
    /// </summary>
    public sealed class BotGroupSyncCoordinator
    {
        #region Constants

        private const float PositionEpsilonSqr = 0.0225f;
        private const float MaxSyncJitter = 0.16f;

        #endregion

        #region Fields

        private readonly Dictionary<BotOwner, BotComponentCache> _teammateCaches = new Dictionary<BotOwner, BotComponentCache>(8);

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotsGroup _group;

        private Vector3 _fallbackPoint;
        private bool _hasFallback;

        private Vector3 _lootPoint;
        private bool _hasLoot;

        private Vector3 _extractPoint;
        private bool _hasExtract;

        private float _lastDangerBroadcastTime;
        private Vector3 _lastDangerPosition;

        #endregion

        #region Properties

        public float LastDangerBroadcastTime => _lastDangerBroadcastTime;
        public Vector3 LastDangerPosition => _lastDangerPosition;
        public bool IsActive => _bot != null && !_bot.IsDead && _group != null && _cache != null;
        public bool SupportsLootPoint => true;

        #endregion

        #region Initialization

        public void Initialize(BotOwner botOwner)
        {
            try
            {
                _bot = botOwner;
                _group = botOwner?.BotsGroup;
                if (_group == null)
                    throw new ArgumentException("[BotGroupSyncCoordinator] BotsGroup is null.");

                _group.OnMemberAdd += OnMemberAdded;
                _group.OnMemberRemove += OnMemberRemoved;
                ResetSync();
            }
            catch
            {
                _bot = null;
                _group = null;
                ResetSync();
            }
        }

        public void InjectLocalCache(BotComponentCache localCache)
        {
            _cache = localCache;
        }

        public void ResetSync()
        {
            _teammateCaches.Clear();
            _fallbackPoint = Vector3.zero;
            _lootPoint = Vector3.zero;
            _extractPoint = Vector3.zero;
            _hasFallback = false;
            _hasLoot = false;
            _hasExtract = false;
            _lastDangerBroadcastTime = -99f;
            _lastDangerPosition = Vector3.zero;
        }

        #endregion

        #region Public API (BotBrain-Driven)

        public void Tick(float time)
        {
            if (!IsActive) return;
            try { RefreshTeammateCaches(); } catch { }
        }

        public void ShareFallbackToSquad(Vector3 fallback, float now)
        {
            _fallbackPoint = fallback;
            _hasFallback = true;

            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead) continue;
                    mate.Combat?.TriggerFallback(fallback, now);
                }
                catch { }
            }
        }

        public void ShareDangerToSquad(Vector3 dangerPos, float now)
        {
            _lastDangerPosition = dangerPos;
            _lastDangerBroadcastTime = now;

            foreach (var mate in _teammateCaches.Values)
            {
                try
                {
                    if (mate?.Bot == null || mate.Bot.IsDead) continue;
                    if (!mate.PanicHandler?.IsPanicking ?? false)
                        mate.PanicHandler?.TriggerPanic();
                }
                catch { }
            }
        }

        public void ShareLootToSquad(Vector3 loot)
        {
            _lootPoint = loot;
            _hasLoot = true;

            foreach (var mate in _teammateCaches.Values)
            {
                try { mate.LootScanner?.RegisterSquadLootTarget(loot); } catch { }
            }
        }

        public void ShareExtractToSquad(Vector3 extract)
        {
            _extractPoint = extract;
            _hasExtract = true;

            foreach (var mate in _teammateCaches.Values)
            {
                try { mate.TacticalMemory?.MarkForcedExtract(); } catch { }
            }
        }

        #endregion

        #region Squad Queries

        public Vector3? GetSharedFallbackTarget() => _hasFallback ? (Vector3?)_fallbackPoint : null;
        public Vector3? GetSharedLootTarget() => _hasLoot ? (Vector3?)_lootPoint : null;
        public Vector3? GetSharedExtractTarget() => _hasExtract ? (Vector3?)_extractPoint : null;

        public bool IsSquadReady() => _teammateCaches.Count > 0;

        public IReadOnlyList<BotOwner> GetTeammates()
        {
            var result = TempListPool.Rent<BotOwner>();
            foreach (var kv in _teammateCaches)
            {
                var b = kv.Key;
                if (b != null && !b.IsDead && b.GetPlayer != null && b.GetPlayer.IsAI)
                    result.Add(b);
            }
            return result;
        }

        public BotComponentCache GetCache(BotOwner teammate)
        {
            if (teammate == null || !_teammateCaches.TryGetValue(teammate, out var cache) || cache == null)
                return BotComponentCache.Empty;
            return cache;
        }

        #endregion

        #region Internal

        private void RefreshTeammateCaches()
        {
            if (_group == null) return;

            for (int i = 0; i < _group.MembersCount; i++)
            {
                BotOwner member = _group.Member(i);
                if (member == null || ReferenceEquals(member, _bot) || member.IsDead) continue;
                if (!_teammateCaches.ContainsKey(member))
                {
                    if (!BotRegistry.TryGetRefactoredOwner(member.ProfileId, out var owner))
                        continue;

                    var cache = new BotComponentCache();
                    cache.Initialize(member);
                    cache.SetOwner(owner);
                    _teammateCaches[member] = cache;
                }
            }

            var toRemove = TempListPool.Rent<BotOwner>();
            foreach (var kv in _teammateCaches)
            {
                if (kv.Key == null || kv.Key.IsDead)
                    toRemove.Add(kv.Key);
            }

            foreach (var bot in toRemove)
                _teammateCaches.Remove(bot);

            TempListPool.Return(toRemove);
        }

        private void OnMemberAdded(BotOwner teammate)
        {
            if (teammate == null || ReferenceEquals(teammate, _bot) || _teammateCaches.ContainsKey(teammate)) return;
            if (teammate.IsDead || teammate.GetPlayer == null || !teammate.GetPlayer.IsAI) return;

            if (!BotRegistry.TryGetRefactoredOwner(teammate.ProfileId, out var owner))
                return;

            var cache = new BotComponentCache();
            cache.Initialize(teammate);
            cache.SetOwner(owner);
            _teammateCaches[teammate] = cache;
        }

        private void OnMemberRemoved(BotOwner teammate)
        {
            _teammateCaches.Remove(teammate);
        }

        private static float GetSyncJitter(string profileId, int tick)
        {
            int hash = (profileId?.GetHashCode() ?? 0) ^ (tick * 23) ^ 0x1B27C9;
            unchecked
            {
                hash = (int)((uint)(hash ^ (hash >> 15)) * 0x85ebca6bU);
                float frac = ((int)(hash & 0xFFFF)) / 65536f;
                return frac * MaxSyncJitter;
            }
        }

        #endregion
    }
}
