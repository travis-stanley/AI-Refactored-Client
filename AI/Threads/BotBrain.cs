// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Threads
{
	using System;
	using AIRefactored.AI.Combat;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Groups;
	using AIRefactored.AI.Missions;
	using AIRefactored.AI.Movement;
	using AIRefactored.AI.Optimization;
	using AIRefactored.AI.Perception;
	using AIRefactored.AI.Reactions;
	using AIRefactored.Core;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using UnityEngine;

	/// <summary>
	/// Real-time execution engine for AIRefactored bot logic.
	/// Controls subsystem tick order, validity checks, and tick-rate segmentation.
	/// </summary>
	public sealed class BotBrain : MonoBehaviour
	{
		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private BotOwner _bot;
		private Player _player;
		private BotComponentCache _cache;

		private CombatStateMachine _combat;
		private BotMovementController _movement;
		private BotPoseController _pose;
		private BotLookController _look;
		private BotTilt _tilt;
		private BotCornerScanner _corner;
		private BotGroupBehavior _groupBehavior;
		private BotJumpController _jump;
		private BotVisionSystem _vision;
		private BotHearingSystem _hearing;
		private BotPerceptionSystem _perception;
		private HearingDamageComponent _hearingDamage;
		private FlashGrenadeComponent _flashDetector;
		private BotFlashReactionComponent _flashReaction;
		private BotTacticalDeviceController _tactical;
		private BotMissionController _mission;
		private BotGroupSyncCoordinator _groupSync;
		private BotTeamLogic _teamLogic;
		private BotAsyncProcessor _asyncProcessor;
		private BotThreatEscalationMonitor _threatEscalationMonitor;

		private bool _isValid;
		private float _lastWarningTime;
		private float _nextPerceptionTick;
		private float _nextCombatTick;
		private float _nextLogicTick;

		private float PerceptionTickRate => FikaHeadlessDetector.IsHeadless ? 1f / 60f : 1f / 30f;
		private float CombatTickRate => FikaHeadlessDetector.IsHeadless ? 1f / 60f : 1f / 30f;
		private float LogicTickRate => FikaHeadlessDetector.IsHeadless ? 1f / 30f : 1f / 15f;

		/// <summary>
		/// Core runtime tick. Dispatches all subsystems in real-time with tiered segmentation.
		/// </summary>
		public void Tick(float deltaTime)
		{
			try
			{
				if (!enabled || !_isValid || _bot == null || _bot.IsDead || _player == null)
				{
					return;
				}

				Player current = _bot.GetPlayer;
				if (current == null || current.HealthController == null || !current.HealthController.IsAlive)
				{
					_isValid = false;
					Logger.LogWarning("[BotBrain] Bot invalidated at runtime — health or player missing.");
					return;
				}

				float now = Time.time;

				if (_movement == null || _combat == null || _mission == null || _cache == null)
				{
					if (now > _lastWarningTime + 1f)
					{
						Logger.LogWarning("[BotBrain] Tick skipped — missing core system: "
							+ (_movement == null ? "Movement " : "")
							+ (_combat == null ? "Combat " : "")
							+ (_mission == null ? "Mission " : "")
							+ (_cache == null ? "Cache " : ""));
						_lastWarningTime = now;
					}
					return;
				}

				if (now >= _nextPerceptionTick)
				{
					Try(() => _vision?.Tick(now), "Vision");
					Try(() => _hearing?.Tick(now), "Hearing");
					Try(() => _perception?.Tick(deltaTime), "Perception");
					_nextPerceptionTick = now + PerceptionTickRate;
				}

				if (now >= _nextCombatTick)
				{
					Try(() => _combat?.Tick(now), "Combat");
					Try(() => _cache?.Escalation?.Tick(now), "Escalation");
					Try(() => _flashReaction?.Tick(now), "FlashReaction");
					Try(() => _flashDetector?.Tick(now), "FlashDetector");
					Try(() => _groupSync?.Tick(now), "GroupSync");
					Try(() => _teamLogic?.CoordinateMovement(), "TeamLogic");
					Try(() => _threatEscalationMonitor?.Tick(now), "ThreatEscalation");
					_nextCombatTick = now + CombatTickRate;
				}

				if (now >= _nextLogicTick)
				{
					Try(() => _mission?.Tick(now), "Mission");
					Try(() => _hearingDamage?.Tick(deltaTime), "HearingDamage");
					Try(() => _tactical?.Tick(), "Tactical");
					Try(() => _cache?.LootScanner?.Tick(deltaTime), "LootScanner");
					Try(() => _cache?.DeadBodyScanner?.Tick(now), "DeadBodyScanner");
					Try(() => _asyncProcessor?.Tick(now), "AsyncProcessor");
					_nextLogicTick = now + LogicTickRate;
				}

				Try(() => _movement?.Tick(deltaTime), "Movement");
				Try(() => _jump?.Tick(deltaTime), "Jump");
				Try(() => _pose?.Tick(now), "Pose");
				Try(() => _look?.Tick(deltaTime), "Look");
				Try(() => _corner?.Tick(now), "CornerScanner");
				Try(() => _tilt?.ManualUpdate(), "Tilt");
				Try(() => _groupBehavior?.Tick(deltaTime), "GroupBehavior");
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotBrain] Tick error: " + ex);
			}
		}

		private static void Try(Action action, string label)
		{
			try { action(); }
			catch (Exception ex) { Logger.LogError("[BotBrain] " + label + " Tick failed: " + ex); }
		}

		/// <summary>
		/// Initializes the bot brain and all subsystems. Requires authoritative host (client-host or headless).
		/// </summary>
		public void Initialize(BotOwner bot)
		{
			if (!GameWorldHandler.IsLocalHost())
			{
				Logger.LogWarning("[BotBrain] Initialization skipped: not authoritative host.");
				return;
			}

			if (bot == null)
			{
				Logger.LogError("[BotBrain] Initialization failed: null bot.");
				return;
			}

			Player player = bot.GetPlayer;
			if (player == null || !player.IsAI || player.IsYourPlayer || bot.IsDead || player.Profile?.Info == null)
			{
				Logger.LogWarning("[BotBrain] Initialization rejected: invalid or non-AI player.");
				return;
			}

			_bot = bot;
			_player = player;

			try
			{
				string profileId = player.Profile.Id;
				if (!BotRegistry.TryGetRefactoredOwner(profileId, out AIRefactoredBotOwner owner))
				{
					owner = new AIRefactoredBotOwner();
					owner.Initialize(bot);
					BotRegistry.RegisterOwner(profileId, owner);
				}

				_cache = BotComponentCacheRegistry.GetOrCreate(bot);
				_cache.SetOwner(owner);

				_combat = _cache.Combat;
				_movement = _cache.Movement;
				_pose = _cache.PoseController;
				_look = _cache.LookController;
				_tilt = _cache.Tilt;
				_groupBehavior = _cache.GroupBehavior;

				_corner = new BotCornerScanner(bot, _cache);
				_jump = new BotJumpController(bot, _cache);

				_vision = new BotVisionSystem(); _vision.Initialize(_cache);
				_hearing = new BotHearingSystem(); _hearing.Initialize(_cache);
				_perception = new BotPerceptionSystem(); _perception.Initialize(_cache);
				_flashReaction = new BotFlashReactionComponent(); _flashReaction.Initialize(_cache);
				_flashDetector = new FlashGrenadeComponent(); _flashDetector.Initialize(_cache);
				_hearingDamage = new HearingDamageComponent();
				_tactical = _cache.Tactical;
				_mission = new BotMissionController(bot, _cache);
				_groupSync = new BotGroupSyncCoordinator(); _groupSync.Initialize(bot); _groupSync.InjectLocalCache(_cache);
				_asyncProcessor = new BotAsyncProcessor(); _asyncProcessor.Initialize(bot, _cache);
				_teamLogic = new BotTeamLogic(bot);
				_threatEscalationMonitor = new BotThreatEscalationMonitor(); _threatEscalationMonitor.Initialize(bot);

				BotBrainGuardian.Enforce(_player.gameObject);
				_isValid = true;
				enabled = true;

				Logger.LogDebug("[BotBrain] ✅ AI initialized for: " + (_player.Profile.Info.Nickname ?? "Unnamed"));
			}
			catch (Exception ex)
			{
				Logger.LogError("[BotBrain] Initialization failed: " + ex);
				_isValid = false;
			}
		}
	}
}
