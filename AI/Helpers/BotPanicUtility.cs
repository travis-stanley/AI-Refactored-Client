// <auto-generated>
//   AI-Refactored: BotPanicUtility.cs (Beyond Diamond - Max Realism Comms & Contagion Edition)
//   All panic propagation is bulletproof, emotion-driven, and never breaks squad state.
//   Squad delays, composure-based jitter, and fallback immunity support included.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles propagation of panic through bots and squads with delay, jitter, and fallback immunity.
    /// Panic is composure-based, fully isolated, and immune to cascade failures.
    /// </summary>
    public static class BotPanicUtility
    {
        #region Public API

        /// <summary>
        /// Triggers panic on a single bot if valid and eligible.
        /// </summary>
        public static void Trigger(BotComponentCache cache)
        {
            try
            {
                if (IsEligible(cache))
                {
                    cache.PanicHandler.TriggerPanic();
                }
            }
            catch { }
        }

        /// <summary>
        /// Triggers panic across all members of the given group, using delay and personality jitter.
        /// </summary>
        public static void TriggerGroup(List<BotComponentCache> group)
        {
            if (group == null)
                return;

            for (int i = 0; i < group.Count; i++)
            {
                try
                {
                    var cache = group[i];
                    if (!IsEligible(cache))
                        continue;

                    float delay = 0.03f * i + GetPanicJitter(cache.Bot?.ProfileId, i);
                    TriggerDelayedPanic(cache, delay);
                }
                catch { }
            }
        }

        /// <summary>
        /// Triggers panic for all bots near the origin within the given radius.
        /// </summary>
        public static void TriggerNearby(Vector3 origin, float radius)
        {
            if (radius <= 0f)
                return;

            float radiusSqr = radius * radius;
            int order = 0;

            foreach (var cache in BotCacheUtility.AllActiveBots())
            {
                try
                {
                    if (!IsEligible(cache))
                        continue;

                    Vector3 pos = cache.Bot.Position;
                    float dx = pos.x - origin.x;
                    float dy = pos.y - origin.y;
                    float dz = pos.z - origin.z;

                    if ((dx * dx + dy * dy + dz * dz) <= radiusSqr)
                    {
                        float delay = 0.02f * order + GetPanicJitter(cache.Bot?.ProfileId, order);
                        TriggerDelayedPanic(cache, delay);
                        order++;
                    }
                }
                catch { }
            }
        }

        /// <summary>
        /// Safe retrieval of a bot's panic handler.
        /// </summary>
        public static bool TryGet(BotComponentCache cache, out BotPanicHandler panic) =>
            TryGetPanicComponent(cache, out panic);

        public static bool TryGetPanicComponent(BotComponentCache cache, out BotPanicHandler panic)
        {
            if (cache?.PanicHandler != null)
            {
                panic = cache.PanicHandler;
                return true;
            }

            panic = null;
            return false;
        }

        #endregion

        #region Internal Helpers

        private static bool IsEligible(BotComponentCache cache)
        {
            return cache != null &&
                   cache.Bot != null &&
                   !cache.Bot.IsDead &&
                   cache.PanicHandler != null &&
                   !cache.PanicHandler.IsPanicking;
        }

        private static float GetPanicJitter(string profileId, int order)
        {
            int hash = (profileId?.GetHashCode() ?? 0) ^ (order * 37) ^ 0x5E1F1213;
            unchecked
            {
                hash = (hash ^ (hash >> 15)) * 0x6B1F29;
                float frac = (hash & 0xFFF) / 4096f;
                return frac * 0.14f; // ~0 to 0.14s
            }
        }

        private static void TriggerDelayedPanic(BotComponentCache cache, float delay)
        {
            if (cache == null)
                return;

            Task.Run(async () =>
            {
                try
                {
                    int ms = Mathf.Max(0, (int)(delay * 1000f));
                    if (ms > 0)
                        await Task.Delay(ms);

                    if (IsEligible(cache))
                        cache.PanicHandler.TriggerPanic();
                }
                catch { }
            });
        }

        #endregion
    }
}
