// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Threads
{
    using System;
    using System.Reflection;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using HarmonyLib;
    using UnityEngine;

    /// <summary>
    /// Scans bot GameObjects for unauthorized logic and removes all non-AIRefactored MonoBehaviours.
    /// Prevents logic injection by external mods or Harmony patches.
    /// Only runs on the authoritative host (headless, local-host, or client-host).
    /// </summary>
    public static class BotBrainGuardian
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        /// <summary>
        /// Enforces AIRefactored control by destroying any foreign MonoBehaviours on the bot GameObject.
        /// </summary>
        /// <param name="botGameObject">The bot GameObject to sanitize.</param>
        public static void Enforce(GameObject botGameObject)
        {
            if (botGameObject == null || !GameWorldHandler.IsLocalHost())
            {
                return;
            }

            MonoBehaviour[] components = botGameObject.GetComponents<MonoBehaviour>();
            if (components == null || components.Length == 0)
            {
                return;
            }

            for (int i = 0; i < components.Length; i++)
            {
                MonoBehaviour component = components[i];
                if (component == null)
                {
                    continue;
                }

                Type type = component.GetType();
                if (type == typeof(BotBrain) || type == typeof(BotComponentCache))
                {
                    continue;
                }

                string name = type.Name.ToLowerInvariant();
                string ns = type.Namespace != null ? type.Namespace.ToLowerInvariant() : string.Empty;

                try
                {
                    if (IsUnityOrEftSafe(name, ns))
                    {
                        continue;
                    }

                    if (IsConflictingBrain(name, ns) || IsHarmonyPatched(type) || HasSuspiciousMethods(type))
                    {
                        UnityEngine.Object.Destroy(component);
                        Logger.LogWarning("[BotBrainGuardian] ⚠ Removed unauthorized AI logic: " + type.FullName + " from: " + botGameObject.name);
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError("[BotBrainGuardian] Component check failed for " + type.FullName + ": " + ex.Message);
                }
            }
        }

        private static bool IsUnityOrEftSafe(string name, string ns)
        {
            return name == "fullbodybipedik"
                || name == "charactercontrollerspawner"
                || name == "coopbot"
                || name == "simplecharactercontroller"
                || name == "triggercollidersearcher"
                || name == "botpacketsender"
                || name == "botfirearmcontroller"
                || ns.StartsWith("unity")
                || ns.StartsWith("eft")
                || ns.Contains("comfort");
        }

        private static bool IsConflictingBrain(string name, string ns)
        {
            return name.Contains("brain")
                || name.StartsWith("pmc")
                || name.StartsWith("spt")
                || name.StartsWith("lua")
                || name.StartsWith("boss")
                || name.StartsWith("follower")
                || name.StartsWith("assault")
                || name.StartsWith("exusec")
                || ns.Contains("sain")
                || ns.Contains("mod")
                || ns.Contains("spt")
                || ns.Contains("lua")
                || (!ns.Contains("ai-refactored") && !ns.Contains("tarkov"));
        }

        private static bool IsHarmonyPatched(Type type)
        {
            try
            {
                MethodInfo method = type.GetMethod("Update", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                if (method == null)
                {
                    return false;
                }

                Patches patch = Harmony.GetPatchInfo(method);
                return patch != null && patch.Owners != null && patch.Owners.Count > 0;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotBrainGuardian] Harmony patch check failed: " + ex.Message);
                return false;
            }
        }

        private static bool HasSuspiciousMethods(Type type)
        {
            string[] methods = { "Update", "LateUpdate", "FixedUpdate", "Tick" };

            for (int i = 0; i < methods.Length; i++)
            {
                try
                {
                    MethodInfo method = type.GetMethod(methods[i], BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                    if (method != null && method.DeclaringType != typeof(MonoBehaviour))
                    {
                        return true;
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError("[BotBrainGuardian] Reflection error on method '" + methods[i] + "': " + ex.Message);
                }
            }

            return false;
        }
    }
}
