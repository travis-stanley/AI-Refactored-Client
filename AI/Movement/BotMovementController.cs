// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Controls advanced bot movement logic including inertia, smooth look, combat strafe, lean, jump, and flank mechanics.
    /// Designed for natural, player-like behavior and fluid real-time responsiveness.
    /// </summary>
    public sealed class BotMovementController
    {
        #region Constants

        private const float CornerScanInterval = 1.2f;
        private const float InertiaWeight = 8f;
        private const float LeanCooldown = 1.5f;
        private const float LookSmoothSpeed = 6f;
        private const float MaxStuckDuration = 1.5f;
        private const float MinMoveThreshold = 0.05f;
        private const float ScanDistance = 2.5f;
        private const float ScanRadius = 0.25f;
        private const float StuckThreshold = 0.1f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotJumpController _jump;
        private BotMovementTrajectoryPlanner _trajectory;

        private Vector3 _lastVelocity;
        private float _nextLeanAllowed;
        private float _nextScanTime;
        private float _strafeTimer;
        private float _stuckTimer;
        private bool _isStrafingRight;
        private bool _inLootingMode;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.PersonalityProfile == null)
            {
                throw new InvalidOperationException("[BotMovementController] Invalid initialization.");
            }

            _cache = cache;
            _bot = cache.Bot;
            _jump = new BotJumpController(_bot, cache);
            _trajectory = new BotMovementTrajectoryPlanner(_bot, cache);
            _lastVelocity = Vector3.zero;
            _nextScanTime = Time.time;
            _nextLeanAllowed = Time.time;
        }

        #endregion

        #region Public Methods

        public void Tick(float deltaTime)
        {
            if (_bot == null ||
                _cache == null ||
                _bot.GetPlayer == null ||
                !_bot.GetPlayer.IsAI ||
                _bot.IsDead ||
                !_bot.GetPlayer.HealthController.IsAlive ||
                _cache.PanicHandler.IsPanicking)
            {
                return;
            }

            _jump.Tick(deltaTime);

            if (_cache.DoorInteraction != null)
            {
                _cache.DoorInteraction.Tick(Time.time);

                if (_cache.DoorInteraction.IsBlockedByDoor)
                {
                    Logger.LogDebug("[Movement] Door blocked — waiting.");
                    return;
                }
            }

            if (Time.time >= _nextScanTime)
            {
                ScanAhead();
                _nextScanTime = Time.time + CornerScanInterval;
            }

            Vector3 target = _bot.Mover != null ? _bot.Mover.LastTargetPoint(1.0f) : _bot.Position;
            SmoothLookTo(target, deltaTime);
            ApplyInertia(target, deltaTime);

            if (!_inLootingMode &&
                _bot.Memory.GoalEnemy != null &&
                _bot.WeaponManager != null &&
                _bot.WeaponManager.IsReady)
            {
                CombatStrafe(deltaTime);
                TryCombatLean();
                TryFlankAroundEnemy();
            }

            DetectStuck(deltaTime);
        }


        public void EnterLootingMode()
        {
            _inLootingMode = true;
        }

        public void ExitLootingMode()
        {
            _inLootingMode = false;
        }

        #endregion

        #region Internal Logic

        private void ApplyInertia(Vector3 target, float deltaTime)
        {
            Vector3 toTarget = target - _bot.Position;
            toTarget.y = 0f;

            if (toTarget.sqrMagnitude < MinMoveThreshold * MinMoveThreshold)
            {
                return;
            }

            Vector3 modified = _trajectory.ModifyTrajectory(toTarget, deltaTime);
            Vector3 velocity = modified.normalized * 1.65f;

            if (_cache.PersonalityProfile.AggressionLevel > 0.7f)
            {
                velocity *= 1.2f;
            }

            _lastVelocity = Vector3.Lerp(_lastVelocity, velocity, InertiaWeight * deltaTime);
            _bot.GetPlayer.CharacterController.Move(Vector3.MoveTowards(_bot.Position, target, _lastVelocity.magnitude * deltaTime), deltaTime);
        }

        private void SmoothLookTo(Vector3 target, float deltaTime)
        {
            Vector3 direction = target - _bot.Transform.position;
            direction.y = 0f;

            if (direction.sqrMagnitude < 0.01f || (_cache.Tilt._coreTilt && Vector3.Angle(_bot.Transform.forward, direction) > 80f))
            {
                return;
            }

            Quaternion desired = Quaternion.LookRotation(direction);
            _bot.Transform.rotation = Quaternion.Lerp(_bot.Transform.rotation, desired, LookSmoothSpeed * deltaTime);
        }

        private void ScanAhead()
        {
            Vector3 origin = _bot.Position + (Vector3.up * 1.5f);
            Vector3 direction = _bot.LookDirection;

            if (Physics.SphereCast(origin, ScanRadius, direction, out _, ScanDistance, AIRefactoredLayerMasks.VisionBlockers))
            {
                if (_bot.BotTalk != null && UnityEngine.Random.value < 0.2f)
                {
                    _bot.BotTalk.TrySay(EPhraseTrigger.Look);
                }
            }
        }

        private void CombatStrafe(float deltaTime)
        {
            _strafeTimer -= deltaTime;
            if (_strafeTimer <= 0f)
            {
                _isStrafingRight = UnityEngine.Random.value > 0.5f;
                _strafeTimer = UnityEngine.Random.Range(0.4f, 0.7f);
            }

            Vector3 lateral = _isStrafingRight ? _bot.Transform.right : -_bot.Transform.right;
            Vector3 avoid = Vector3.zero;

            BotsGroup group = _bot.BotsGroup;
            if (group != null)
            {
                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner mate = group.Member(i);
                    if (mate != null && mate != _bot && !mate.IsDead)
                    {
                        float dist = Vector3.Distance(_bot.Position, mate.Position);
                        if (dist < 2f && dist > 0.01f)
                        {
                            avoid += (_bot.Position - mate.Position).normalized / dist;
                        }
                    }
                }
            }

            Vector3 dir = (lateral + avoid * 1.2f).normalized;
            float speed = 1.2f + UnityEngine.Random.Range(-0.1f, 0.15f);
            _bot.GetPlayer.CharacterController.Move(dir * speed * deltaTime, deltaTime);
        }

        private void TryCombatLean()
        {
            if (_cache.Tilt == null || Time.time < _nextLeanAllowed)
            {
                return;
            }

            BotPersonalityProfile profile = _cache.PersonalityProfile;
            if (profile.LeaningStyle == LeanPreference.Never || _bot.Memory.GoalEnemy == null)
            {
                return;
            }

            Vector3 origin = _bot.Position + Vector3.up * 1.5f;
            bool wallLeft = Physics.Raycast(origin, -_bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);
            bool wallRight = Physics.Raycast(origin, _bot.Transform.right, 1.5f, AIRefactoredLayerMasks.VisionBlockers);
            Vector3 coverPos = _bot.Memory.BotCurrentCoverInfo != null ? _bot.Memory.BotCurrentCoverInfo.LastCover?.Position ?? Vector3.zero : Vector3.zero;

            if (profile.LeaningStyle == LeanPreference.Conservative && coverPos == Vector3.zero && !wallLeft && !wallRight)
            {
                return;
            }

            if (coverPos != Vector3.zero && !BotCoverHelper.WasRecentlyUsed(coverPos))
            {
                BotCoverHelper.MarkUsed(coverPos);
                float dir = Vector3.Dot((_bot.Position - coverPos).normalized, _bot.Transform.right);
                _cache.Tilt.Set(dir > 0f ? BotTiltType.right : BotTiltType.left);
            }
            else if (wallLeft && !wallRight)
            {
                _cache.Tilt.Set(BotTiltType.right);
            }
            else if (wallRight && !wallLeft)
            {
                _cache.Tilt.Set(BotTiltType.left);
            }
            else
            {
                Vector3 toEnemy = _bot.Memory.GoalEnemy.CurrPosition - _bot.Position;
                float dot = Vector3.Dot(toEnemy.normalized, _bot.Transform.right);
                _cache.Tilt.Set(dot > 0f ? BotTiltType.right : BotTiltType.left);
            }

            _nextLeanAllowed = Time.time + LeanCooldown;
        }

        private void TryFlankAroundEnemy()
        {
            if (_bot.Memory.GoalEnemy == null)
            {
                return;
            }

            float aggression = _cache.PersonalityProfile.AggressionLevel;
            float distance = Vector3.Distance(_bot.Position, _bot.Memory.GoalEnemy.CurrPosition);
            float required = aggression > 0.7f ? 30f : 22f;

            if (distance < required)
            {
                FlankPositionPlanner.Side preferred = FlankCoordinator.GetOptimalFlankSide(_bot, _cache);
                Vector3[] buffer = TempVector3Pool.Rent(1); 
                try
                {
                    if (FlankPositionPlanner.TryFindFlankPosition(_bot.Position, _bot.Memory.GoalEnemy.CurrPosition, out buffer[0], preferred))
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, buffer[0], false);
                        Logger.LogDebug("[Movement] Flank triggered: " + buffer[0]);
                    }
                }
                finally
                {
                    TempVector3Pool.Return(buffer);
                }
            }
        }

        private void DetectStuck(float deltaTime)
        {
            Vector3 target = _bot.Mover != null ? _bot.Mover.LastTargetPoint(1.0f) : _bot.Position;
            if (_inLootingMode || !ValidateNavMeshTarget(target))
            {
                return;
            }

            Vector3 velocity = _bot.GetPlayer.Velocity;
            if (velocity.sqrMagnitude < StuckThreshold * StuckThreshold)
            {
                _stuckTimer += deltaTime;
                if (_stuckTimer > MaxStuckDuration)
                {
                    Vector3[] buffer = TempVector3Pool.Rent(1);
                    try
                    {
                        buffer[0] = target + UnityEngine.Random.insideUnitSphere * 1.0f;
                        buffer[0].y = target.y;
                        BotMovementHelper.SmoothMoveTo(_bot, buffer[0], false);
                        Logger.LogDebug("[Movement] Stuck recovery triggered.");
                    }
                    finally
                    {
                        TempVector3Pool.Return(buffer);
                    }

                    _stuckTimer = 0f;
                }
            }
            else
            {
                _stuckTimer = 0f;
            }
        }


        private bool ValidateNavMeshTarget(Vector3 pos)
        {
            if (NavMesh.SamplePosition(pos, out NavMeshHit hit, 1.5f, NavMesh.AllAreas))
            {
                return (hit.position - pos).sqrMagnitude < 1.0f;
            }

            Logger.LogWarning("[Movement] Invalid NavMesh target: " + pos);
            return false;
        }

        #endregion
    }
}
