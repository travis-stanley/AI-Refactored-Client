// <auto-generated>
//   AI-Refactored: BotTacticalDeviceController.cs (Ultimate Realism – Beyond Diamond Edition)
//   Realism: Flashlight, laser, NVG, and thermal logic is humanized with chaos-bait, ambient awareness, and fog response.
//   Bulletproof: Pooling-optimized, multiplayer and headless safe, null-free and error-isolated.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Controls and manages tactical device toggling for bot AI:
    /// Flashlights, lasers, NVGs, and thermals.
    /// Handles ambient/fog-based logic and chaos-driven baiting.
    /// Fully null-safe, pooling-optimized, and headless/multiplayer compatible.
    /// </summary>
    public sealed class BotTacticalDeviceController
    {
        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _nextDecisionTime;
        private bool _failed;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            _failed = false;
            _nextDecisionTime = 0f;

            try
            {
                if (cache == null || cache.Bot == null)
                {
                    _failed = true;
                    return;
                }

                _bot = cache.Bot;
                _cache = cache;
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] Initialize exception: {ex}");
            }
        }

        #endregion

        #region Tick

        /// <summary>
        /// Main tick. Controls tactical device logic. Bulletproof and pooling-optimized.
        /// </summary>
        public void Tick()
        {
            if (_failed || !CanThink())
                return;

            try
            {
                _nextDecisionTime = Time.time + TacticalConfig.CheckInterval;

                Weapon weapon = _bot.WeaponManager?.CurrentWeapon;
                if (weapon == null)
                    return;

                var devices = TempListPool.Rent<LightComponent>();
                try
                {
                    ScanModsForTacticalDevices(weapon, devices);

                    bool isLowVisibility = IsLowVisibility();
                    float chaosChance = GetChaosBaitChance();
                    bool baitTrigger = UnityEngine.Random.value < chaosChance;
                    bool shouldEnable = isLowVisibility || baitTrigger;

                    for (int i = 0, count = devices.Count; i < count; i++)
                    {
                        LightComponent device = devices[i];
                        if (device != null && device.IsActive != shouldEnable)
                        {
                            device.IsActive = shouldEnable;
                        }
                    }

                    // Chaos-baiting: rapid off-on flash for human-style bait/fake
                    if (baitTrigger)
                    {
                        _nextDecisionTime = Time.time + 1.5f;
                        for (int i = 0, count = devices.Count; i < count; i++)
                        {
                            LightComponent device = devices[i];
                            if (device != null)
                                device.IsActive = false;
                        }
                    }
                }
                finally
                {
                    TempListPool.Return(devices);
                }
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] Tick exception: {ex}");
            }
        }

        #endregion

        #region Logic

        private bool CanThink()
        {
            return !_failed &&
                   _bot != null &&
                   _cache != null &&
                   !_bot.IsDead &&
                   Time.time >= _nextDecisionTime &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   _bot.GetPlayer.IsAI;
        }

        /// <summary>
        /// Returns chaos-bait trigger chance (personality driven, awareness-inverse).
        /// </summary>
        private float GetChaosBaitChance()
        {
            try
            {
                var owner = _cache?.AIRefactoredBotOwner;
                if (owner == null || owner.PersonalityProfile == null)
                    return 0f;

                float baseChaos = owner.PersonalityProfile.ChaosFactor * 0.25f;
                float awarenessMod = 1f - Mathf.Clamp01(owner.PersonalityProfile.Awareness);
                return Mathf.Clamp01(baseChaos * (0.7f + 0.6f * awarenessMod));
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] GetChaosBaitChance exception: {ex}");
                return 0f;
            }
        }

        /// <summary>
        /// True if low-light or fog warrants device enable.
        /// </summary>
        private static bool IsLowVisibility()
        {
            try
            {
                float ambient = RenderSettings.ambientLight.grayscale;
                float fogDensity = RenderSettings.fog ? RenderSettings.fogDensity : 0f;
                return ambient < TacticalConfig.LightThreshold || fogDensity > TacticalConfig.FogThreshold;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Finds all attached tactical devices (light/laser/nvg/thermal) on the weapon, zero-alloc.
        /// </summary>
        private static void ScanModsForTacticalDevices(Weapon weapon, System.Collections.Generic.List<LightComponent> result)
        {
            if (weapon == null || result == null)
                return;

            var slots = weapon.AllSlots;
            if (slots == null)
                return;

            foreach (Slot slot in slots)
            {
                if (slot == null)
                    continue;

                Item mod = slot.ContainedItem;
                if (mod == null || mod.Template == null)
                    continue;

                string name = mod.Template.Name?.ToLowerInvariant();
                if (string.IsNullOrEmpty(name) || !IsTacticalName(name))
                    continue;

                if (mod is FlashlightItemClass flash && flash.Light != null)
                    result.Add(flash.Light);
                else if (mod is TacticalComboItemClass combo && combo.Light != null)
                    result.Add(combo.Light);
                else if (mod is LightLaserItemClass laser && laser.Light != null)
                    result.Add(laser.Light);
            }
        }

        /// <summary>
        /// True if name contains a tactical device keyword.
        /// </summary>
        private static bool IsTacticalName(string name)
        {
            var keywords = TacticalConfig.Keywords;
            for (int i = 0; i < keywords.Length; i++)
                if (name.Contains(keywords[i]))
                    return true;
            return false;
        }

        #endregion

        #region TacticalConfig

        private static class TacticalConfig
        {
            public const float CheckInterval = 2.0f;
            public const float FogThreshold = 0.5f;
            public const float LightThreshold = 0.3f;
            public static readonly string[] Keywords = { "light", "laser", "nvg", "thermal", "flash" };
        }

        #endregion
    }
}
