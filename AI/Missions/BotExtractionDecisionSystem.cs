// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;

    /// <summary>
    /// Decides when a bot should attempt early extraction based on panic, loot value, squad status, isolation, or mobility state.
    /// Decision thresholds scale based on bot personality.
    /// All failures are locally isolated; cannot break or cascade into other systems.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        #region Constants

        private const int MaxStuckRetries = 3;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _log;

        private float _lastMoveUpdateTime;
        private Vector3 _lastPosition;
        private int _stuckRetryCount;
        private bool _hasExtracted;

        #endregion

        #region Constructor

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotExtractionDecisionSystem] Invalid BotOwner reference.");

            _bot = bot;
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _profile = profile ?? throw new ArgumentNullException(nameof(profile));
            _log = Plugin.LoggerInstance;

            _lastPosition = _bot.Position;
            _lastMoveUpdateTime = Time.time;
            _stuckRetryCount = 0;
        }

        #endregion

        #region Public Methods

        public void Tick(float time)
        {
            try
            {
                if (_hasExtracted)
                    return;

                if (ShouldExtract(time))
                {
                    TriggerExtraction();
                    _hasExtracted = true;
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] Tick failed: {ex}");
            }
        }

        public bool ShouldExtract(float now)
        {
            try
            {
                Player player = _bot.GetPlayer;
                if (_bot.IsDead || player == null || !player.IsAI)
                    return false;

                IHealthController health = player.HealthController;
                if (health == null || !health.IsAlive)
                    return false;

                float composure = _cache?.PanicHandler?.GetComposureLevel() ?? 1f;
                float panicThreshold = Mathf.Lerp(0.35f, 0.15f, _profile.Caution);
                if (composure < panicThreshold)
                {
                    _log.LogDebug("[ExtractDecision] Panic threshold triggered → " + _bot.name);
                    return true;
                }

                float lootValue = _cache?.LootScanner?.TotalLootValue ?? 0f;
                float lootThreshold = Mathf.Lerp(85000f, 50000f, _profile.Greed);
                if (lootValue >= lootThreshold)
                {
                    _log.LogDebug("[ExtractDecision] Loot threshold met → " + _bot.name + $" ({lootValue:F0})");
                    return true;
                }

                if (HasSquadWiped())
                {
                    _log.LogDebug("[ExtractDecision] Squad wiped → " + _bot.name);
                    return true;
                }

                float cohesionRadius = Mathf.Lerp(35f, 60f, 1f - _profile.Cohesion);
                if (IsBotIsolated(cohesionRadius))
                {
                    _log.LogDebug("[ExtractDecision] Bot is isolated → " + _bot.name);
                    return true;
                }

                float stuckTimeout = Mathf.Lerp(8f, 18f, 1f - _profile.Caution);
                if (IsBotStuck(now, stuckTimeout))
                {
                    _stuckRetryCount++;
                    if (_stuckRetryCount >= MaxStuckRetries)
                    {
                        _log.LogDebug("[ExtractDecision] Movement failure x" + _stuckRetryCount + " → " + _bot.name);
                        return true;
                    }

                    _log.LogDebug("[ExtractDecision] Stuck detected, triggering fallback (" + _stuckRetryCount + ") → " + _bot.name);
                    BotMovementHelper.ForceFallbackMove(_bot);
                }

                return false;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] ShouldExtract failed: {ex}");
                return false;
            }
        }

        public void TriggerExtraction()
        {
            try
            {
                Player player = _bot.GetPlayer;
                IHealthController health = player?.HealthController;

                if (_bot.IsDead || player == null || !player.IsAI || health == null || !health.IsAlive || _bot.BotState != EBotState.Active)
                {
                    _log.LogWarning("[ExtractDecision] ❌ Extraction aborted — invalid state for " + _bot.name);
                    return;
                }

                if (_cache?.TacticalMemory != null)
                    _cache.TacticalMemory.MarkExtractionStarted();

                // Only native movement
                BotMovementHelper.SmoothMoveToSafeExit(_bot);
                _log.LogDebug("[ExtractDecision] ✅ Extraction initiated for: " + _bot.name);
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] TriggerExtraction failed: {ex}");
            }
        }

        #endregion

        #region Private Helpers

        private bool IsBotStuck(float now, float threshold)
        {
            try
            {
                float distanceMoved = (_bot.Position - _lastPosition).sqrMagnitude;
                if (distanceMoved > 0.4f)
                {
                    _lastPosition = _bot.Position;
                    _lastMoveUpdateTime = now;
                    _stuckRetryCount = 0;
                    return false;
                }

                return now - _lastMoveUpdateTime >= threshold;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] IsBotStuck failed: {ex}");
                return false;
            }
        }

        private bool HasSquadWiped()
        {
            try
            {
                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1)
                    return false; // Solo bots should NOT extract due to squad wipe

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner member = group.Member(i);
                    if (member != null && member != _bot && !member.IsDead)
                        return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] HasSquadWiped failed: {ex}");
                return false;
            }
        }

        private bool IsBotIsolated(float radius)
        {
            try
            {
                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1)
                    return true;

                Vector3 currentPosition = _bot.Position;
                float radiusSqr = radius * radius;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner member = group.Member(i);
                    if (member != null && member != _bot && !member.IsDead)
                    {
                        float distanceSqr = (member.Position - currentPosition).sqrMagnitude;
                        if (distanceSqr < radiusSqr)
                            return false;
                    }
                }

                return true;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] IsBotIsolated failed: {ex}");
                return false;
            }
        }

        #endregion
    }
}
