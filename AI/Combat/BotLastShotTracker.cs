// <auto-generated>
//   AI-Refactored: BotLastShotTracker.cs (Max Realism, Beyond Diamond, May 2025)
//   Tracks incoming/outgoing fire with heat/decay, robust null-guards, ready for squad/suppression expansion.
//   All APIs bulletproofed, allocation-free, AIRefactored-style. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Tracks recent shot and hit interactions for a bot, including body part, direction, and distance.
    /// Informs suppression, retaliation, squad contagion, and fallback logic.
    /// Bulletproof: All logic is strictly null-guarded; errors never propagate.
    /// </summary>
    public sealed class BotLastShotTracker
    {
        #region Constants

        private const float DefaultMemoryWindow = 10f;
        private const float MinMemoryWindow = 2.5f;
        private const float MaxMemoryWindow = 25f;

        #endregion

        #region State

        private string _lastAttackerId = string.Empty;
        private float _lastHitTime = float.NegativeInfinity;
        private EBodyPart _lastHitPart = EBodyPart.Common;
        private float _lastHitDistance = -1f;
        private Vector3 _lastHitDirection = Vector3.zero;

        private string _lastTargetId = string.Empty;
        private float _lastShotTime = float.NegativeInfinity;
        private float _lastShotDistance = -1f;
        private Vector3 _lastShotDirection = Vector3.zero;

        private string _lastSquadSuppressorId = string.Empty;
        private float _lastSquadSuppressedTime = float.NegativeInfinity;

        #endregion

        #region Public API

        /// <summary>
        /// Checks if we recently shot the given profile.
        /// </summary>
        public bool DidRecentlyShoot(string profileId, float now = -1f, float memoryWindow = -1f)
        {
            try
            {
                if (string.IsNullOrEmpty(profileId) || string.IsNullOrEmpty(_lastTargetId))
                    return false;
                if (!string.Equals(_lastTargetId, profileId, StringComparison.Ordinal))
                    return false;
                float time = now >= 0f ? now : Time.time;
                float window = GetMemoryWindow(memoryWindow);
                return time >= _lastShotTime && (time - _lastShotTime) <= window;
            }
            catch { return false; }
        }

        /// <summary>
        /// Checks if we were recently shot by the given profile.
        /// </summary>
        public bool WasRecentlyShotBy(string profileId, float now = -1f, float memoryWindow = -1f)
        {
            try
            {
                if (string.IsNullOrEmpty(profileId) || string.IsNullOrEmpty(_lastAttackerId))
                    return false;
                if (!string.Equals(_lastAttackerId, profileId, StringComparison.Ordinal))
                    return false;
                float time = now >= 0f ? now : Time.time;
                float window = GetMemoryWindow(memoryWindow);
                return time >= _lastHitTime && (time - _lastHitTime) <= window;
            }
            catch { return false; }
        }

        /// <summary>
        /// Checks if we were recently squad-suppressed by the given profile.
        /// </summary>
        public bool WasRecentlySquadSuppressed(string profileId, float now = -1f, float memoryWindow = -1f)
        {
            try
            {
                if (string.IsNullOrEmpty(profileId) || string.IsNullOrEmpty(_lastSquadSuppressorId))
                    return false;
                if (!string.Equals(_lastSquadSuppressorId, profileId, StringComparison.Ordinal))
                    return false;
                float time = now >= 0f ? now : Time.time;
                float window = GetMemoryWindow(memoryWindow);
                return time >= _lastSquadSuppressedTime && (time - _lastSquadSuppressedTime) <= window;
            }
            catch { return false; }
        }

        /// <summary>
        /// Register a new incoming hit (from another profile).
        /// </summary>
        public void RegisterHit(string profileId, EBodyPart hitPart = EBodyPart.Common, float distance = -1f, Vector3 direction = default)
        {
            try
            {
                if (string.IsNullOrEmpty(profileId)) return;
                _lastAttackerId = profileId;
                _lastHitTime = Time.time;
                _lastHitPart = hitPart;
                _lastHitDistance = distance;
                _lastHitDirection = direction;
            }
            catch { }
        }

        /// <summary>
        /// Register a new outgoing shot (to another profile).
        /// </summary>
        public void RegisterShot(string profileId, float distance = -1f, Vector3 direction = default)
        {
            try
            {
                if (string.IsNullOrEmpty(profileId)) return;
                _lastTargetId = profileId;
                _lastShotTime = Time.time;
                _lastShotDistance = distance;
                _lastShotDirection = direction;
            }
            catch { }
        }

        /// <summary>
        /// Register a squad suppression event (from another profile).
        /// </summary>
        public void RegisterSquadSuppressed(string profileId)
        {
            try
            {
                if (string.IsNullOrEmpty(profileId)) return;
                _lastSquadSuppressorId = profileId;
                _lastSquadSuppressedTime = Time.time;
            }
            catch { }
        }

        /// <summary>
        /// Returns a normalized "heat" value for recent incoming hits (0 = cold, 1 = just hit).
        /// </summary>
        public float GetRecentHitHeat(float now = -1f, float memoryWindow = -1f)
        {
            try
            {
                float time = now >= 0f ? now : Time.time;
                float delta = time - _lastHitTime;
                float window = GetMemoryWindow(memoryWindow);
                if (delta > window || delta < 0f) return 0f;
                return 1f - Mathf.Clamp01(delta / window);
            }
            catch { return 0f; }
        }

        /// <summary>
        /// Returns a normalized "heat" value for recent outgoing shots (0 = cold, 1 = just shot).
        /// </summary>
        public float GetRecentShotHeat(float now = -1f, float memoryWindow = -1f)
        {
            try
            {
                float time = now >= 0f ? now : Time.time;
                float delta = time - _lastShotTime;
                float window = GetMemoryWindow(memoryWindow);
                if (delta > window || delta < 0f) return 0f;
                return 1f - Mathf.Clamp01(delta / window);
            }
            catch { return 0f; }
        }

        /// <summary>
        /// Returns a normalized "heat" value for recent squad suppression events (0 = cold, 1 = just suppressed).
        /// </summary>
        public float GetRecentSquadSuppressionHeat(float now = -1f, float memoryWindow = -1f)
        {
            try
            {
                float time = now >= 0f ? now : Time.time;
                float delta = time - _lastSquadSuppressedTime;
                float window = GetMemoryWindow(memoryWindow);
                if (delta > window || delta < 0f) return 0f;
                return 1f - Mathf.Clamp01(delta / window);
            }
            catch { return 0f; }
        }

        /// <summary>
        /// Reset all tracked shot and hit data.
        /// </summary>
        public void Reset()
        {
            _lastAttackerId = string.Empty;
            _lastTargetId = string.Empty;
            _lastHitTime = float.NegativeInfinity;
            _lastShotTime = float.NegativeInfinity;
            _lastHitPart = EBodyPart.Common;
            _lastHitDistance = -1f;
            _lastHitDirection = Vector3.zero;
            _lastShotDistance = -1f;
            _lastShotDirection = Vector3.zero;
            _lastSquadSuppressorId = string.Empty;
            _lastSquadSuppressedTime = float.NegativeInfinity;
        }

        #endregion

        #region Exposed Properties

        public string LastAttackerId => _lastAttackerId;
        public float LastHitTime => _lastHitTime;
        public EBodyPart LastHitPart => _lastHitPart;
        public float LastHitDistance => _lastHitDistance;
        public Vector3 LastHitDirection => _lastHitDirection;
        public string LastTargetId => _lastTargetId;
        public float LastShotTime => _lastShotTime;
        public float LastShotDistance => _lastShotDistance;
        public Vector3 LastShotDirection => _lastShotDirection;
        public string LastSquadSuppressorId => _lastSquadSuppressorId;
        public float LastSquadSuppressedTime => _lastSquadSuppressedTime;

        #endregion

        #region Helpers

        private float GetMemoryWindow(float memoryWindow)
        {
            if (memoryWindow > 0f)
                return Mathf.Clamp(memoryWindow, MinMemoryWindow, MaxMemoryWindow);
            return DefaultMemoryWindow;
        }

        #endregion
    }
}
