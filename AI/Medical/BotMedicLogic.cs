// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Medical
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls bot healing behavior using first aid, surgery, or stimulators.
    /// Supports healing squadmates using internal EFT BotHealAnotherTarget logic.
    /// All failures are locally isolated; medic logic cannot break other subsystems or the mod.
    /// </summary>
    public sealed class BotMedicLogic
    {
        #region Constants

        private const float HealCheckInterval = 1.5f;
        private const float HealSquadRange = 4f;
        private static readonly float HealSquadRangeSqr = HealSquadRange * HealSquadRange;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotComponentCache _cache;
        private readonly BotInjurySystem _injurySystem;
        private readonly BotOwner _bot;

        private BotMedecine _med;
        private float _nextHealCheck;
        private bool _isHealing;
        private bool _isActive = true;

        #endregion

        #region Constructor

        public BotMedicLogic(BotComponentCache cache, BotInjurySystem injurySystem)
        {
            if (cache == null || injurySystem == null || cache.Bot == null)
            {
                _isActive = false;
                Logger.LogError("[BotMedicLogic] Initialization failed: cache, injury system, or bot is null. Disabling medic logic for this bot.");
                return;
            }

            _cache = cache;
            _injurySystem = injurySystem;
            _bot = cache.Bot;
            _nextHealCheck = Time.time;

            try
            {
                // Safe instantiation and event subscription for squad heal logic.
                if (_bot.HealAnotherTarget == null)
                {
                    _bot.HealAnotherTarget = new BotHealAnotherTarget(_bot);
                    _bot.HealAnotherTarget.OnHealAsked += OnHealAsked;
                }
                else
                {
                    _bot.HealAnotherTarget.OnHealAsked -= OnHealAsked;
                    _bot.HealAnotherTarget.OnHealAsked += OnHealAsked;
                }

                if (_bot.HealingBySomebody == null)
                {
                    _bot.HealingBySomebody = new BotHealingBySomebody(_bot);
                }

                _med = _bot.Medecine ?? new BotMedecine(_bot);
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotMedicLogic] Constructor failed: {ex}. Disabling medic logic for this bot.");
            }
        }

        #endregion

        #region Public API

        public void Reset()
        {
            if (!_isActive)
            {
                return;
            }

            try
            {
                _isHealing = false;
                _injurySystem.Reset();
                UnsubscribeFromFirstAid();
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotMedicLogic] Reset() failed: {ex}. Disabling medic logic for this bot.");
            }
        }

        public void Tick(float time)
        {
            if (!_isActive || _isHealing || time < _nextHealCheck)
            {
                return;
            }

            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(_bot) || (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking))
                {
                    return;
                }

                if (_bot.HealAnotherTarget != null && _bot.HealAnotherTarget.IsInProcess)
                {
                    return;
                }

                _nextHealCheck = time + HealCheckInterval;

                _injurySystem.Tick(time);

                if (TryHealSquadmate())
                {
                    return;
                }

                TrySelfHeal();
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotMedicLogic] Tick() failed: {ex}. Disabling medic logic for this bot.");
            }
        }

        #endregion

        #region Healing Logic

        private bool TryHealSquadmate()
        {
            try
            {
                if (_bot.BotsGroup == null)
                {
                    return false;
                }

                Player self = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValidGroupPlayer(self))
                {
                    return false;
                }

                Vector3 selfPos = EFTPlayerUtil.GetPosition(self);
                int count = _bot.BotsGroup.MembersCount;

                for (int i = 0; i < count; i++)
                {
                    BotOwner mate = _bot.BotsGroup.Member(i);
                    if (!EFTPlayerUtil.IsValidBotOwner(mate) || mate == _bot)
                    {
                        continue;
                    }

                    Player target = EFTPlayerUtil.ResolvePlayer(mate);
                    if (!EFTPlayerUtil.IsValidGroupPlayer(target))
                    {
                        continue;
                    }

                    Vector3 targetPos = EFTPlayerUtil.GetPosition(target);
                    float dx = targetPos.x - selfPos.x;
                    float dz = targetPos.z - selfPos.z;
                    if ((dx * dx + dz * dz) > HealSquadRangeSqr)
                    {
                        continue;
                    }

                    IPlayer iTarget = EFTPlayerUtil.AsSafeIPlayer(target);
                    if (iTarget != null)
                    {
                        _bot.HealAnotherTarget.HealAsk(iTarget);
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] TryHealSquadmate() failed: {ex}");
            }

            return false;
        }

        private void TrySelfHeal()
        {
            try
            {
                var firstAid = _med.FirstAid as BotFirstAidClass;
                var surgery = _med.SurgicalKit as GClass473;
                var stim = _med.Stimulators as GClass475;

                if (firstAid != null && firstAid.ShallStartUse())
                {
                    _isHealing = true;
                    TrySay(EPhraseTrigger.StartHeal);
                    UnsubscribeFromFirstAid();
                    firstAid.OnEndApply += OnHealComplete;
                    firstAid.TryApplyToCurrentPart();
                    return;
                }

                if (surgery != null && surgery.ShallStartUse())
                {
                    _isHealing = true;
                    TrySay(EPhraseTrigger.StartHeal);
                    surgery.ApplyToCurrentPart();
                    return;
                }

                if (stim != null && stim.CanUseNow())
                {
                    _isHealing = true;
                    stim.StartApplyToTarget(OnStimComplete);
                }
            }
            catch (Exception ex)
            {
                _isActive = false;
                Logger.LogError($"[BotMedicLogic] TrySelfHeal() failed: {ex}. Disabling medic logic for this bot.");
            }
        }

        #endregion

        #region Callbacks

        private void OnHealAsked(IPlayer target)
        {
            try
            {
                _isHealing = true;
                TrySay(EPhraseTrigger.StartHeal);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] OnHealAsked() failed: {ex}");
            }
        }

        private void OnHealComplete(BotOwner _)
        {
            try
            {
                _isHealing = false;
                _injurySystem.Reset();
                UnsubscribeFromFirstAid();
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] OnHealComplete() failed: {ex}");
            }
        }

        private void OnStimComplete(bool success)
        {
            try
            {
                _isHealing = false;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] OnStimComplete() failed: {ex}");
            }
        }

        #endregion

        #region Utilities

        private void TrySay(EPhraseTrigger trigger)
        {
            try
            {
                if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null)
                {
                    _bot.BotTalk.TrySay(trigger);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] TrySay() failed: {ex}");
            }
        }

        private void UnsubscribeFromFirstAid()
        {
            try
            {
                var fa = _med.FirstAid as BotFirstAidClass;
                if (fa != null)
                {
                    fa.OnEndApply -= OnHealComplete;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMedicLogic] UnsubscribeFromFirstAid() failed: {ex}");
            }
        }

        #endregion
    }
}
