// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Controls squad-based movement offsets to prevent clumping and collisions.
    /// Dynamically spaces bots based on squad size and formation pattern.
    /// </summary>
    public sealed class SquadPathCoordinator
    {
        #region Constants

        private const float BaseSpacing = 2.25f;
        private const float MaxSpacing = 6.5f;
        private const float MinSpacing = 1.25f;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotsGroup _group;
        private Vector3 _cachedOffset;
        private int _lastGroupSize;
        private bool _offsetInitialized;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the offset logic for the given bot.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.Bot.IsDead)
                return;

            _bot = cache.Bot;
            _group = _bot.BotsGroup;

            if (_group == null)
            {
                _bot = null;
                return;
            }

            _cachedOffset = Vector3.zero;
            _offsetInitialized = false;
            _lastGroupSize = -1;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Returns an offset-adjusted destination to reduce clumping.
        /// </summary>
        public Vector3 ApplyOffsetTo(Vector3 sharedDestination)
        {
            return sharedDestination + GetCurrentOffset();
        }

        /// <summary>
        /// Gets the current assigned formation offset.
        /// </summary>
        public Vector3 GetCurrentOffset()
        {
            if (_bot == null || _group == null)
                return Vector3.zero;

            int currentSize = _group.MembersCount;
            if (!_offsetInitialized || currentSize != _lastGroupSize)
            {
                _cachedOffset = ComputeOffset();
                _offsetInitialized = true;
                _lastGroupSize = currentSize;
            }

            return _cachedOffset;
        }

        #endregion

        #region Private Methods

        private Vector3 ComputeOffset()
        {
            if (_bot == null || _group == null || _bot.IsDead || _group.MembersCount < 2)
                return Vector3.zero;

            int index = GetBotIndexInGroup(_bot, _group);
            if (index < 0)
                return Vector3.zero;

            string profileId = _bot.ProfileId;
            if (string.IsNullOrEmpty(profileId))
                return Vector3.zero;

            int squadSize = _group.MembersCount;
            int seed = unchecked(profileId.GetHashCode() ^ (squadSize * 397));
            Random.InitState(seed);

            float baseNoise = Random.Range(-0.4f, 0.4f);
            float spacing = Mathf.Clamp(BaseSpacing + baseNoise, MinSpacing, MaxSpacing);

            float angleStep = 360f / squadSize;
            float angle = (index * angleStep) + Random.Range(-8f, 8f);
            float radians = angle * Mathf.Deg2Rad;

            float x = Mathf.Cos(radians) * spacing;
            float z = Mathf.Sin(radians) * spacing;

            return new Vector3(x, 0f, z);
        }

        private static int GetBotIndexInGroup(BotOwner bot, BotsGroup group)
        {
            if (bot == null || group == null || string.IsNullOrEmpty(bot.ProfileId))
                return -1;

            int count = group.MembersCount;
            for (int i = 0; i < count; i++)
            {
                BotOwner member = group.Member(i);
                if (member != null && !member.IsDead && member.ProfileId == bot.ProfileId)
                {
                    return i;
                }
            }

            return -1;
        }

        #endregion
    }
}
