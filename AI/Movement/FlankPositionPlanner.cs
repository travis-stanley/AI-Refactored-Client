// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Calculates realistic flank positions around enemies.
    /// Uses NavMesh validation and dynamic spacing based on enemy distance and vertical tolerance.
    /// </summary>
    public static class FlankPositionPlanner
    {
        #region Constants

        private const float BaseOffset = 4.0f;
        private const float DistanceVariation = 1.5f;
        private const int MaxAttemptsPerSide = 3;
        private const float MaxDistance = 12f;
        private const float MinDistance = 2f;
        private const float NavSampleRadius = 1.5f;
        private const float OffsetVariation = 0.4f;
        private const float VerticalTolerance = 1.85f;

        #endregion

        #region Public Types

        /// <summary>
        /// Represents a preferred side to flank from relative to the enemy.
        /// </summary>
        public enum Side
        {
            /// <summary>Flank from the enemy's left side.</summary>
            Left,

            /// <summary>Flank from the enemy's right side.</summary>
            Right
        }

        #endregion

        #region Public API

        /// <summary>
        /// Attempts to find a valid flank point on a preferred side of the enemy.
        /// Falls back to the opposite side if preferred side fails.
        /// </summary>
        public static bool TryFindFlankPosition(Vector3 botPos, Vector3 enemyPos, out Vector3 flankPoint, Side preferred)
        {
            flankPoint = Vector3.zero;

            Vector3 toEnemy = enemyPos - botPos;
            toEnemy.y = 0f;

            if (toEnemy.sqrMagnitude < 0.0001f)
            {
                return false;
            }

            toEnemy.Normalize();

            if (TrySide(botPos, toEnemy, preferred, out flankPoint))
            {
                return true;
            }

            Side fallback = preferred == Side.Left ? Side.Right : Side.Left;
            return TrySide(botPos, toEnemy, fallback, out flankPoint);
        }

        /// <summary>
        /// Uses enemy forward vector and bot position to smartly pick a flank side.
        /// </summary>
        public static bool TrySmartFlank(Vector3 botPos, Vector3 enemyPos, Vector3 enemyForward, out Vector3 flankPoint)
        {
            flankPoint = Vector3.zero;

            Vector3 toBot = botPos - enemyPos;
            toBot.y = 0f;

            if (toBot.sqrMagnitude < 0.0001f)
            {
                return false;
            }

            toBot.Normalize();

            float sideDot = Vector3.Dot(Vector3.Cross(enemyForward, Vector3.up), toBot);
            Side side = sideDot >= 0f ? Side.Right : Side.Left;

            return TryFindFlankPosition(botPos, enemyPos, out flankPoint, side);
        }

        #endregion

        #region Internal Logic

        private static bool TrySide(Vector3 origin, Vector3 toEnemy, Side side, out Vector3 result)
        {
            result = Vector3.zero;
            Vector3 perpendicular = Vector3.Cross(Vector3.up, toEnemy) * (side == Side.Left ? -1f : 1f);

            for (int i = 0; i < MaxAttemptsPerSide; i++)
            {
                float lateralOffset = BaseOffset + UnityEngine.Random.Range(-OffsetVariation, OffsetVariation);
                float forwardDistance = UnityEngine.Random.Range(MinDistance, MaxDistance);

                Vector3 candidate = origin + (perpendicular * lateralOffset) + (toEnemy * forwardDistance);

                if (IsValidFlankPoint(candidate, origin, out Vector3 valid))
                {
                    result = valid;
                    return true;
                }
            }

            return false;
        }

        private static bool IsValidFlankPoint(Vector3 candidate, Vector3 origin, out Vector3 final)
        {
            final = Vector3.zero;

            if (!NavMesh.SamplePosition(candidate, out NavMeshHit hit, NavSampleRadius, NavMesh.AllAreas))
            {
                return false;
            }

            float verticalDelta = Mathf.Abs(origin.y - hit.position.y);
            float distanceSqr = (origin - hit.position).sqrMagnitude;

            if (distanceSqr < MinDistance * MinDistance || distanceSqr > MaxDistance * MaxDistance)
            {
                return false;
            }

            if (verticalDelta > VerticalTolerance)
            {
                return false;
            }

            final = hit.position;
            return true;
        }

        #endregion
    }
}
