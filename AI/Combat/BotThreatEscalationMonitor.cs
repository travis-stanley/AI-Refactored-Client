// <auto-generated>
//   AI-Refactored: BotThreatEscalationMonitor.cs (Max Realism, Valid Phrases Only, May 2025)
//   Extreme threat escalation: aggression, comms, panic sync, multi-voice, squad morale collapse, no fallback.
//   Bulletproof: All logic is strictly null-guarded, errors log only, never disables or cascades.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Monitors, escalates, and communicates bot and squad threat level. All logic error-guarded and multiplayer-safe.
    /// </summary>
    public sealed class BotThreatEscalationMonitor
    {
        #region Constants

        private const float CheckInterval = 1.0f;
        private const float PanicDurationThreshold = 4.0f;
        private const float SquadCasualtyThreshold = 0.4f;
        private const float SquadMoraleCollapseThreshold = 0.65f;
        private const float VoiceIntervalMin = 2.5f;
        private const float VoiceIntervalMax = 5.3f;

        private static readonly EPhraseTrigger[] EscalationPhrases = new[]
        {
            EPhraseTrigger.OnFight, EPhraseTrigger.NeedHelp, EPhraseTrigger.UnderFire,
            EPhraseTrigger.Regroup, EPhraseTrigger.Cooperation, EPhraseTrigger.CoverMe,
            EPhraseTrigger.GoForward, EPhraseTrigger.HoldPosition, EPhraseTrigger.FollowMe
        };

        private static readonly EPhraseTrigger[] SquadCollapsePhrases = new[]
        {
            EPhraseTrigger.Regroup, EPhraseTrigger.OnBeingHurt, EPhraseTrigger.NeedHelp,
            EPhraseTrigger.CoverMe, EPhraseTrigger.HoldPosition, EPhraseTrigger.FollowMe,
            EPhraseTrigger.OnFight
        };

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Fields

        private BotOwner _bot;
        private float _panicStartTime = -1f;
        private float _nextCheckTime = -1f;
        private float _lastVoiceTime = -1f;
        private float _nextSquadVoiceTime = -1f;
        private bool _hasEscalated;

        #endregion

        #region Initialization

        public void Initialize(BotOwner botOwner)
        {
            if (botOwner == null)
            {
                Logger.LogError("[BotThreatEscalationMonitor] BotOwner is null in Initialize.");
                return;
            }

            _bot = botOwner;
            _panicStartTime = -1f;
            _nextCheckTime = -1f;
            _lastVoiceTime = -1f;
            _nextSquadVoiceTime = -1f;
            _hasEscalated = false;
        }

        #endregion

        #region Main Tick

        public void Tick(float time)
        {
            if (!IsValid() || time < _nextCheckTime)
                return;

            _nextCheckTime = time + CheckInterval;

            try
            {
                if (!_hasEscalated && ShouldEscalate(time))
                    EscalateBot(time);

                if (SquadMoraleCollapsed())
                    TrySquadCollapseComms(time);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotThreatEscalationMonitor] Tick exception: " + ex);
            }
        }

        #endregion

        #region Public API

        public void NotifyPanicTriggered()
        {
            if (_panicStartTime < 0f)
                _panicStartTime = Time.time;
        }

        #endregion

        #region Escalation Logic

        private bool ShouldEscalate(float time)
        {
            return PanicDurationExceeded(time) || MultipleEnemiesVisible() || SquadHasLostTeammates();
        }

        private bool PanicDurationExceeded(float time) =>
            _panicStartTime >= 0f && (time - _panicStartTime) > PanicDurationThreshold;

        private bool MultipleEnemiesVisible()
        {
            var controller = _bot?.EnemiesController;
            if (controller?.EnemyInfos == null)
                return false;

            int visible = 0;
            foreach (var kv in controller.EnemyInfos)
            {
                if (kv.Value?.IsVisible == true && ++visible >= 2)
                    return true;
            }
            return false;
        }

        private bool SquadHasLostTeammates()
        {
            var group = _bot?.BotsGroup;
            if (group == null || group.MembersCount <= 1)
                return false;

            int dead = 0;
            for (int i = 0; i < group.MembersCount; i++)
                if (group.Member(i)?.IsDead == true)
                    dead++;

            return dead >= Mathf.CeilToInt(group.MembersCount * SquadCasualtyThreshold);
        }

        private bool SquadMoraleCollapsed()
        {
            var group = _bot?.BotsGroup;
            if (group == null || group.MembersCount <= 1)
                return false;

            int dead = 0;
            for (int i = 0; i < group.MembersCount; i++)
                if (group.Member(i)?.IsDead == true)
                    dead++;

            return dead >= Mathf.CeilToInt(group.MembersCount * SquadMoraleCollapseThreshold);
        }

        private void EscalateBot(float time)
        {
            _hasEscalated = true;

            string name = _bot.Profile?.Info?.Nickname ?? "Unknown";
            Logger.LogDebug($"[AIRefactored-Escalation] Escalating bot '{name}'");

            AIOptimizationManager.Reset(_bot);
            AIOptimizationManager.Apply(_bot);

            ApplyEscalationTuning(_bot);
            ApplyPersonalityTuning(_bot);

            if (BotNavHelper.TryGetSafeTarget(_bot, out var navTarget) && IsVectorValid(navTarget))
            {
                if (_bot.Mover != null && !_bot.Mover.IsMoving)
                {
                    float cohesion = BotRegistry.Get(_bot.ProfileId)?.Cohesion ?? 1f;
                    BotMovementHelper.SmoothMoveTo(_bot, navTarget, false, cohesion);
                }
            }

            if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null && time - _lastVoiceTime > VoiceIntervalMin)
            {
                TrySayEscalationPhrase(time);
            }
        }

        private void TrySquadCollapseComms(float time)
        {
            if (!FikaHeadlessDetector.IsHeadless &&
                _bot.BotTalk != null &&
                time - _nextSquadVoiceTime > VoiceIntervalMax)
            {
                try
                {
                    var phrase = SquadCollapsePhrases[UnityEngine.Random.Range(0, SquadCollapsePhrases.Length)];
                    _bot.BotTalk.TrySay(phrase);
                    _nextSquadVoiceTime = time;
                }
                catch (Exception ex)
                {
                    Logger.LogError("[BotThreatEscalationMonitor] Squad collapse comms failed: " + ex);
                }
            }
        }

        private void TrySayEscalationPhrase(float time)
        {
            try
            {
                var phrase = EscalationPhrases[UnityEngine.Random.Range(0, EscalationPhrases.Length)];
                _bot.BotTalk.TrySay(phrase);
                _lastVoiceTime = time;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotThreatEscalationMonitor] Escalation voice failed: " + ex);
            }
        }

        private void ApplyEscalationTuning(BotOwner bot)
        {
            var file = bot?.Settings?.FileSettings;
            if (file == null) return;

            try
            {
                file.Shoot.RECOIL_PER_METER *= 0.82f;
                file.Mind.DIST_TO_FOUND_SQRT *= 1.23f;
                file.Mind.ENEMY_LOOK_AT_ME_ANG *= 0.7f;
                file.Mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 = Mathf.Clamp(file.Mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 + 28f, 0f, 100f);
                file.Look.MAX_VISION_GRASS_METERS += 7f;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotThreatEscalationMonitor] Tuning failed: " + ex);
            }
        }

        private void ApplyPersonalityTuning(BotOwner bot)
        {
            try
            {
                var profile = BotRegistry.Get(bot.ProfileId);
                if (profile == null) return;

                profile.AggressionLevel = Mathf.Clamp01(profile.AggressionLevel + 0.25f);
                profile.Caution = Mathf.Clamp01(profile.Caution - 0.23f);
                profile.SuppressionSensitivity = Mathf.Clamp01(profile.SuppressionSensitivity * 0.7f);
                profile.AccuracyUnderFire = Mathf.Clamp01(profile.AccuracyUnderFire + 0.22f);
                profile.CommunicationLevel = Mathf.Clamp01(profile.CommunicationLevel + 0.22f);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotThreatEscalationMonitor] Personality tuning failed: " + ex);
            }
        }

        #endregion

        #region Validation

        private bool IsValid()
        {
            try
            {
                return _bot != null &&
                       !_bot.IsDead &&
                       _bot.GetPlayer is Player player &&
                       player.IsAI;
            }
            catch { return false; }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z);
        }

        #endregion
    }
}
