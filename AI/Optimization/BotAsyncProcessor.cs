// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All async and optimization routines are bulletproof and fully isolated. Realism Pass: robust async safety, deterministic group sync, personality logic is atomic.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles asynchronous low-frequency logic for bot behavior tuning and squad optimization.
    /// Supports thread-based workloads in headless environments.
    /// Runs only on the authoritative host (headless or client-host).
    /// All failures are fully isolated to the affected bot instance.
    /// </summary>
    public sealed class BotAsyncProcessor
    {
        #region Constants

        private const float InitDelaySeconds = 0.5f;
        private const float ThinkCooldownHeadless = 1.5f;
        private const float ThinkCooldownNormal = 3.5f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private readonly BotOwnerGroupOptimization _groupOptimizer = new BotOwnerGroupOptimization();

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotOwnerStateCache _stateCache;

        private bool _hasInitialized;
        private float _lastThinkTime;

        #endregion

        #region Public API

        /// <summary>
        /// Initializes the async processor for the specified bot.
        /// Bulletproof: errors affect only this bot's processor.
        /// </summary>
        public void Initialize(BotOwner botOwner, BotComponentCache cache)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || botOwner == null || cache == null)
                    return;

                _bot = botOwner;
                _cache = cache;
                _stateCache = new BotOwnerStateCache();
                _hasInitialized = false;
                _lastThinkTime = 0f;

                // Detach task: no cancellation, bulletproof
                Task.Run(async () =>
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromSeconds(InitDelaySeconds)).ConfigureAwait(false);
                        if (!_hasInitialized)
                        {
                            await ApplyInitialPersonalityAsync(botOwner).ConfigureAwait(false);
                        }
                    }
                    catch (Exception ex)
                    {
                        LogWarn("[BotAsyncProcessor] Async init failed: " + ex.Message);
                    }
                });
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAsyncProcessor] Initialize() fatal error: " + ex);
            }
        }

        /// <summary>
        /// Updates bot async logic based on timing and environment.
        /// Bulletproof: all failures are isolated to this bot.
        /// </summary>
        public void Tick(float time)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !_hasInitialized || _bot == null || _bot.IsDead)
                    return;

                try { _stateCache.UpdateBotOwnerStateIfNeeded(_bot); } catch (Exception ex) { LogWarn("[BotAsyncProcessor] StateCache update failed: " + ex.Message); }
                try { TryOptimizeGroup(); } catch (Exception ex) { LogWarn("[BotAsyncProcessor] TryOptimizeGroup failed: " + ex.Message); }

                float cooldown = FikaHeadlessDetector.IsHeadless ? ThinkCooldownHeadless : ThinkCooldownNormal;
                if (time - _lastThinkTime < cooldown)
                    return;

                _lastThinkTime = time;

                if (FikaHeadlessDetector.IsHeadless)
                {
                    // ThreadPool work item for true headless async
                    System.Threading.ThreadPool.QueueUserWorkItem(_ =>
                    {
                        try { Think(); }
                        catch (Exception ex) { LogWarn("[BotAsyncProcessor] Async headless think failed: " + ex.Message); }
                    });
                }
                else
                {
                    try { Think(); }
                    catch (Exception ex) { LogWarn("[BotAsyncProcessor] Think execution failed: " + ex.Message); }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAsyncProcessor] Tick() fatal error: " + ex);
            }
        }

        #endregion

        #region Internal Logic

        private async Task ApplyInitialPersonalityAsync(BotOwner bot)
        {
            try
            {
                if (_hasInitialized || bot == null || bot.Profile == null || bot.Settings == null || bot.Settings.FileSettings == null)
                    return;

                await Task.Yield();

                string profileId = "Unknown";
                try { profileId = bot.Profile?.Id ?? "Unknown"; } catch { }

                if (string.IsNullOrEmpty(profileId))
                    return;

                BotGlobalsMindSettings mind = null;
                try { mind = bot.Settings.FileSettings.Mind; } catch { }
                if (mind == null)
                    return;

                BotPersonalityProfile personality = null;
                try { personality = BotRegistry.Get(profileId); } catch { }
                if (personality == null)
                    return;

                try { mind.PANIC_RUN_WEIGHT = Mathf.Lerp(0.5f, 2.0f, personality.RiskTolerance); } catch { }
                try { mind.PANIC_SIT_WEIGHT = Mathf.Lerp(10.0f, 80.0f, 1f - personality.RiskTolerance); } catch { }
                try { mind.DIST_TO_FOUND_SQRT = Mathf.Lerp(200f, 600f, 1f - personality.Cohesion); } catch { }
                try { mind.FRIEND_AGR_KILL = Mathf.Lerp(0f, 0.4f, personality.AggressionLevel); } catch { }

                LogDebug("[BotAsyncProcessor] ✅ Personality initialized for bot: " + (bot.Profile?.Info?.Nickname ?? "Unknown"));
                _hasInitialized = true;
            }
            catch (Exception ex)
            {
                LogWarn("[BotAsyncProcessor] ApplyInitialPersonalityAsync failed: " + ex.Message);
            }
        }

        private void Think()
        {
            try
            {
                if (_bot == null || _bot.IsDead)
                    return;

                // Simulate human-like random mumble phrases extremely rarely, only on main thread.
                if (UnityEngine.Random.value < 0.008f)
                {
                    BotWorkScheduler.EnqueueToMainThread(() =>
                    {
                        try
                        {
                            EFT.Player p = _bot.GetPlayer;
                            if (p != null)
                                p.Say(EPhraseTrigger.MumblePhrase);
                        }
                        catch (Exception ex)
                        {
                            LogWarn("[BotAsyncProcessor] Mumble dispatch failed: " + ex.Message);
                        }
                    });
                }
            }
            catch (Exception ex)
            {
                LogWarn("[BotAsyncProcessor] Think() exception: " + ex.Message);
            }
        }

        private void TryOptimizeGroup()
        {
            try
            {
                if (_bot == null || _bot.Profile == null || _bot.Profile.Info == null)
                    return;

                string groupId = _bot.Profile.Info.GroupId;
                if (string.IsNullOrEmpty(groupId))
                    return;

                List<BotOwner> squad = null;
                try { squad = BotTeamTracker.GetGroup(groupId); } catch { }
                if (squad != null && squad.Count > 0)
                {
                    try { _groupOptimizer.OptimizeGroupAI(squad); } catch (Exception ex) { LogWarn("[BotAsyncProcessor] Group optimization failed: " + ex.Message); }
                }
            }
            catch (Exception ex)
            {
                LogWarn("[BotAsyncProcessor] TryOptimizeGroup() exception: " + ex.Message);
            }
        }

        #endregion

        #region Logging Helpers

        private static void LogDebug(string msg)
        {
            if (!FikaHeadlessDetector.IsHeadless)
                Logger.LogDebug(msg);
        }

        private static void LogWarn(string msg)
        {
            if (!FikaHeadlessDetector.IsHeadless)
                Logger.LogWarning(msg);
        }

        #endregion
    }
}
