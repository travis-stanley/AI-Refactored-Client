// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using UnityEngine;

    /// <summary>
    /// Spatial grid-based indexing for NavPointData.
    /// Used to accelerate nearby queries over large maps.
    /// </summary>
    public sealed class SpatialNavGrid
    {
        #region Fields

        private readonly float _cellSize;
        private readonly Dictionary<Vector2Int, List<NavPointData>> _grid;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the <see cref="SpatialNavGrid"/> class.
        /// </summary>
        /// <param name="cellSize">Grid cell size in world units (minimum 1.0f).</param>
        public SpatialNavGrid(float cellSize)
        {
            _cellSize = Mathf.Max(1f, cellSize);
            _grid = new Dictionary<Vector2Int, List<NavPointData>>(512);
        }

        #endregion

        #region Public API

        /// <summary>
        /// Clears the entire spatial index.
        /// </summary>
        public void Clear()
        {
            foreach (KeyValuePair<Vector2Int, List<NavPointData>> pair in _grid)
            {
                TempListPool.Return(pair.Value);
            }

            _grid.Clear();
        }

        /// <summary>
        /// Adds a navigation point into the appropriate spatial cell.
        /// </summary>
        /// <param name="point">The point to register.</param>
        public void Register(NavPointData point)
        {
            if (point == null || !IsPositionValid(point.Position))
            {
                return;
            }

            Vector2Int cell = WorldToCell(point.Position);

            if (!_grid.TryGetValue(cell, out List<NavPointData> list))
            {
                list = TempListPool.Rent<NavPointData>();
                _grid[cell] = list;
            }

            for (int i = 0; i < list.Count; i++)
            {
                if (list[i].DistanceSqr(point.Position) < 0.01f)
                {
                    return; // prevent near-duplicates
                }
            }

            list.Add(point);
        }

        /// <summary>
        /// Returns all navigation points within the given radius of a position.
        /// Optionally filter by predicate.
        /// </summary>
        /// <param name="position">Search origin.</param>
        /// <param name="radius">Search radius.</param>
        /// <param name="filter">Optional predicate filter.</param>
        public List<NavPointData> Query(Vector3 position, float radius, Predicate<NavPointData> filter)
        {
            List<NavPointData> result = TempListPool.Rent<NavPointData>();
            if (!IsPositionValid(position))
            {
                return result;
            }

            float radiusSq = radius * radius;
            Vector2Int minCell = WorldToCell(new Vector3(position.x - radius, 0f, position.z - radius));
            Vector2Int maxCell = WorldToCell(new Vector3(position.x + radius, 0f, position.z + radius));

            for (int x = minCell.x; x <= maxCell.x; x++)
            {
                for (int z = minCell.y; z <= maxCell.y; z++)
                {
                    Vector2Int cell = new Vector2Int(x, z);

                    if (!_grid.TryGetValue(cell, out List<NavPointData> bucket))
                    {
                        continue;
                    }

                    for (int i = 0; i < bucket.Count; i++)
                    {
                        NavPointData point = bucket[i];
                        if ((point.Position - position).sqrMagnitude <= radiusSq &&
                            (filter == null || filter(point)))
                        {
                            result.Add(point);
                        }
                    }
                }
            }

            return result;
        }

        #endregion

        #region Internal Helpers

        private Vector2Int WorldToCell(Vector3 pos)
        {
            int x = Mathf.FloorToInt(pos.x / _cellSize);
            int z = Mathf.FloorToInt(pos.z / _cellSize);
            return new Vector2Int(x, z);
        }

        private static bool IsPositionValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) &&
                   !float.IsNaN(pos.y) &&
                   !float.IsNaN(pos.z) &&
                   pos.x > -10000f && pos.x < 10000f &&
                   pos.z > -10000f && pos.z < 10000f;
        }

        #endregion
    }
}
