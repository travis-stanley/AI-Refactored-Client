// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All failures are locally isolated; cannot break or cascade into other systems.
//   Realism Pass: Personality-driven, smoothly-varying chaos; organic avoidance; no robotic movement artifacts.
//   All movement is direction-based—never sets position or teleports.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Modifies a bot’s movement vector by applying chaos wobble, squad staggering offsets,
    /// and teammate collision avoidance. Produces natural movement flow and reduces clustering.
    /// All failures are locally isolated; cannot break or cascade into other systems.
    /// Never directly sets position—modifies only the movement direction.
    /// </summary>
    public sealed class BotMovementTrajectoryPlanner
    {
        #region Constants

        private const float AvoidanceRadius = 2.0f;
        private const float AvoidanceScale = 1.25f;
        private const float ChaosIntervalMin = 0.38f;
        private const float ChaosIntervalMax = 0.52f;
        private const float ChaosRadius = 0.65f;
        private const float SquadOffsetScale = 0.75f;
        private const float VelocityFactor = 1.5f;
        private const float MinMagnitude = 0.0001f;
        private const float ChaosLerpSpeed = 3.8f;
        private const float AvoidanceMissChance = 0.07f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _chaosOffset;
        private Vector3 _targetChaosOffset;
        private float _nextChaosUpdate;

        #endregion

        #region Constructor

        public BotMovementTrajectoryPlanner(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotMovementTrajectoryPlanner] bot is invalid.");
            if (cache == null || bot.GetPlayer == null)
                throw new ArgumentException("[BotMovementTrajectoryPlanner] cache or player is null.");

            _bot = bot;
            _cache = cache;
            _chaosOffset = Vector3.zero;
            _targetChaosOffset = Vector3.zero;
            _nextChaosUpdate = 0f;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Computes a modified movement direction vector for the bot.
        /// Applies chaos, squad offsets, avoidance, and velocity blending.
        /// Always bulletproof, never allocates, never throws, always returns a valid direction.
        /// Never directly sets position—modifies only direction for path-based or controller-based movement.
        /// </summary>
        public Vector3 ModifyTrajectory(Vector3 targetDir, float deltaTime)
        {
            try
            {
                float now = Time.unscaledTime;

                if (now >= _nextChaosUpdate)
                    UpdateTargetChaosOffset(now);

                _chaosOffset = Vector3.Lerp(_chaosOffset, _targetChaosOffset, deltaTime * ChaosLerpSpeed);
                _chaosOffset.y = 0f;

                Vector3 baseDir = (targetDir.sqrMagnitude > MinMagnitude) ? targetDir.normalized : Vector3.forward;
                Vector3 adjusted = baseDir;

                if (_chaosOffset.sqrMagnitude > MinMagnitude)
                    adjusted += _chaosOffset;

                if (_cache.SquadPath != null)
                {
                    Vector3 squadOffset = _cache.SquadPath.GetCurrentOffset();
                    if (squadOffset.sqrMagnitude > MinMagnitude)
                    {
                        squadOffset.y = 0f;
                        adjusted += squadOffset.normalized * SquadOffsetScale;
                    }
                }

                Vector3 avoidVector = ComputeAvoidance();
                if (avoidVector.sqrMagnitude > MinMagnitude)
                {
                    avoidVector.y = 0f;
                    adjusted += avoidVector.normalized * AvoidanceScale;
                }

                Vector3 velocity = Vector3.zero;
                try { velocity = _bot.GetPlayer != null ? _bot.GetPlayer.Velocity : Vector3.zero; } catch { }
                if (velocity.sqrMagnitude > MinMagnitude)
                {
                    velocity.y = 0f;
                    adjusted += velocity.normalized * VelocityFactor;
                }

                // Add tiny variance to break sync artifacts
                adjusted += UnityEngine.Random.insideUnitSphere * 0.01f;
                adjusted.y = 0f;

                return adjusted.sqrMagnitude > MinMagnitude ? adjusted.normalized : baseDir;
            }
            catch
            {
                return Vector3.forward;
            }
        }

        #endregion

        #region Internal Helpers

        private Vector3 ComputeAvoidance()
        {
            try
            {
                if (UnityEngine.Random.value < AvoidanceMissChance)
                    return Vector3.zero;

                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1) return Vector3.zero;

                Vector3 self = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                int count = 0;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner other = group.Member(i);
                    if (other == null || other == _bot || other.IsDead) continue;

                    Vector3 offset = self - other.Position;
                    float dist = offset.magnitude;
                    if (dist < AvoidanceRadius && dist > 0.01f)
                    {
                        offset.y = 0f;
                        repulsion += offset.normalized / dist;
                        count++;
                    }
                }

                return count > 0 ? repulsion / count : Vector3.zero;
            }
            catch
            {
                return Vector3.zero;
            }
        }

        private void UpdateTargetChaosOffset(float now)
        {
            try
            {
                AIRefactoredBotOwner owner = _cache.AIRefactoredBotOwner;
                if (owner == null || owner.PersonalityProfile == null)
                {
                    _targetChaosOffset = Vector3.zero;
                    _nextChaosUpdate = now + UnityEngine.Random.Range(ChaosIntervalMin, ChaosIntervalMax);
                    return;
                }

                float caution = Mathf.Clamp01(owner.PersonalityProfile.Caution);
                float chaosRange = ChaosRadius * (1f - caution);

                float x = UnityEngine.Random.Range(-chaosRange * 0.5f, chaosRange * 0.5f);
                float z = UnityEngine.Random.Range(0.1f, chaosRange);

                _targetChaosOffset = new Vector3(x, 0f, z);
                _nextChaosUpdate = now + UnityEngine.Random.Range(ChaosIntervalMin, ChaosIntervalMax);
            }
            catch
            {
                _targetChaosOffset = Vector3.zero;
                _nextChaosUpdate = now + UnityEngine.Random.Range(ChaosIntervalMin, ChaosIntervalMax);
            }
        }

        #endregion
    }
}
