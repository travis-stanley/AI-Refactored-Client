// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.Runtime
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Bootstrap;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Globally ticks world systems post-initialization using a persistent MonoBehaviour.
    /// Handles world stabilization lifecycle and deferred updates.
    /// </summary>
    public static class WorldTickDispatcher
    {
        #region Fields

        private static GameObject _host;
        private static TickHost _monoHost;
        private static bool _isActive;

        private static ManualLogSource Logger => Plugin.LoggerInstance;

        #endregion

        #region Lifecycle

        /// <summary>
        /// Initializes the world tick dispatcher and attaches update loop.
        /// </summary>
        public static void Initialize()
        {
            if (_isActive || _host != null || _monoHost != null)
            {
                return;
            }

            try
            {
                _host = new GameObject("AIRefactored.WorldTickDispatcher");
                UnityEngine.Object.DontDestroyOnLoad(_host);

                _monoHost = _host.AddComponent<TickHost>();
                _isActive = true;

                Logger.LogDebug("[WorldTickDispatcher] ✅ Host attached and ticking.");
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldTickDispatcher] ❌ Initialization failed: " + ex);
            }
        }

        /// <summary>
        /// Fully resets and destroys dispatcher logic (e.g. on teardown).
        /// </summary>
        public static void Reset()
        {
            if (!_isActive)
            {
                return;
            }

            _isActive = false;

            try
            {
                if (_monoHost != null)
                {
                    UnityEngine.Object.Destroy(_monoHost);
                }

                if (_host != null)
                {
                    UnityEngine.Object.Destroy(_host);
                }

                Logger.LogDebug("[WorldTickDispatcher] 🧹 Shutdown complete.");
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldTickDispatcher] ❌ Error during host destroy: " + ex);
            }

            _monoHost = null;
            _host = null;
        }

        #endregion

        #region Ticking

        /// <summary>
        /// Ticks all world systems for the given frame delta time.
        /// </summary>
        /// <param name="deltaTime">The time delta since the last frame.</param>
        public static void Tick(float deltaTime)
        {
            if (!_isActive || !GameWorldHandler.IsInitialized || !GameWorldHandler.IsHost)
            {
                return;
            }

            try
            {
                WorldBootstrapper.Tick(deltaTime);
            }
            catch (Exception ex)
            {
                Logger.LogError("[WorldTickDispatcher] ❌ Tick error: " + ex);
            }
        }

        #endregion

        #region MonoHost

        /// <summary>
        /// Internal MonoBehaviour host that drives frame-based ticking.
        /// Used in all modes — traditional or headless client.
        /// </summary>
        private sealed class TickHost : MonoBehaviour
        {
            private void Update()
            {
                try
                {
                    Tick(Time.deltaTime);
                }
                catch (Exception ex)
                {
                    Logger.LogError("[WorldTickDispatcher] ❌ Update exception: " + ex);
                }
            }

            private void OnDestroy()
            {
                try
                {
                    Reset();
                }
                catch (Exception ex)
                {
                    Logger.LogError("[WorldTickDispatcher] ❌ OnDestroy failed: " + ex);
                }
            }
        }

        #endregion
    }
}
