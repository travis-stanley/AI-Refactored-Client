// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.Core
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Pools;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Centralized manager for initializing, clearing, and registering temporary pooling systems.
    /// Handles teardown, plugin unload, prewarming, and memory flushes.
    /// </summary>
    public static class TempPoolManager
    {
        #region Fields

        private static readonly List<Action> _registeredCustomClearers = new List<Action>(16);
        private static bool _domainHooked;

        #endregion

        #region Lifecycle

        /// <summary>
        /// Initializes the manager and binds cleanup logic to AppDomain unload.
        /// </summary>
        public static void Initialize()
        {
            if (_domainHooked)
            {
                return;
            }

            _domainHooked = true;

            try
            {
                AppDomain.CurrentDomain.DomainUnload += (_, __) => ClearAll();
            }
            catch
            {
                // IL2CPP or AOT platforms may not support AppDomain events.
            }
        }

        /// <summary>
        /// Registers an external custom pool clear method for global teardown.
        /// </summary>
        /// <param name="clearMethod">Action to execute during ClearAll.</param>
        public static void RegisterCustom(Action clearMethod)
        {
            if (clearMethod == null)
            {
                return;
            }

            if (!_registeredCustomClearers.Contains(clearMethod))
            {
                _registeredCustomClearers.Add(clearMethod);
            }
        }

        #endregion

        #region Pooling

        /// <summary>
        /// Prewarms all known AIRefactored temporary pools to reduce runtime allocation.
        /// </summary>
        public static void PrewarmAll()
        {
            // Generic pooled collections
            TempListPool.Prewarm<int>(16);
            TempListPool.Prewarm<Vector3>(16);
            TempListPool.Prewarm<RaycastHit>(16);
            TempListPool.Prewarm<NavMeshHit>(8);
            TempListPool.Prewarm<Bounds>(8);

            TempHashSetPool.Prewarm<int>(16);
            TempDictionaryPool.Prewarm<string, int>(8);
            TempQueuePool.Prewarm<float>(8);
            TempStackPool.Prewarm<Vector3>(8);

            // Fixed-size pooled arrays
            TempIntArrayPool.Prewarm(32, 8);
            TempVector3Pool.Prewarm(16, 8);
            TempNavPathCornerPool.Prewarm(16, 8);

            // Unity struct pools
            TempBoundsPool.Prewarm(8, 4);
            TempRaycastHitPool.Prewarm(16, 4);
            TempRaycastHitListPool.Prewarm(8);
            TempNavMeshHitPool.Prewarm(8, 4);
            TempRaycastCommandPool.Prewarm(8, 4);
            TempNavMeshPathPool.Prewarm(4);
        }

        /// <summary>
        /// Clears all pooling systems and resets the internal registry state.
        /// </summary>
        public static void ClearAll()
        {
            TempListPool.ClearAll();
            TempHashSetPool.ClearAll();
            TempDictionaryPool.ClearAll();
            TempQueuePool.ClearAll();
            TempStackPool.ClearAll();

            TempIntArrayPool.ClearAll();
            TempVector3Pool.ClearAll();
            TempNavPathCornerPool.ClearAll();

            TempRaycastHitPool.ClearAll();
            TempRaycastHitListPool.ClearAll();
            TempBoundsPool.ClearAll();
            TempNavMeshHitPool.ClearAll();
            TempRaycastCommandPool.ClearAll();
            TempNavMeshPathPool.ClearAll();

            for (int i = 0; i < _registeredCustomClearers.Count; i++)
            {
                try
                {
                    _registeredCustomClearers[i].Invoke();
                }
                catch
                {
                    // Fail silently — custom pool cleanup failed.
                }
            }
        }

        #endregion
    }
}
