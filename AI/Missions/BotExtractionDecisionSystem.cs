// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
//   Bulletproof: All failures are locally isolated, never disables itself, never triggers fallback AI.
//   Realism Pass: Extraction logic is fully human-like, nuanced, and strictly project-valid.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using EFT;
    using EFT.HealthSystem;
    using EFT.Interactive;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using UnityEngine;
    using BepInEx.Logging;
    using AIRefactored.AI.Navigation;

    public sealed class BotExtractionDecisionSystem
    {
        #region Constants

        private const int MaxStuckRetries = 3;
        private const float MaxSearchDistance = 85f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _log;

        private float _lastMoveUpdateTime;
        private Vector3 _lastPosition;
        private int _stuckRetryCount;
        private bool _hasExtracted;

        #endregion

        #region Constructor

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotExtractionDecisionSystem] Invalid BotOwner.");
            _bot = bot;
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _profile = profile ?? throw new ArgumentNullException(nameof(profile));
            _log = Plugin.LoggerInstance;

            _lastPosition = _bot.Position;
            _lastMoveUpdateTime = Time.time;
            _stuckRetryCount = 0;
        }

        #endregion

        #region Public Methods

        public void Tick(float time)
        {
            try
            {
                if (_hasExtracted)
                    return;

                if (ShouldExtract(time))
                {
                    TriggerExtraction();
                    _hasExtracted = true;
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] Tick failed: {ex}");
            }
        }

        public bool ShouldExtract(float now)
        {
            try
            {
                if (_bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.IsAI) return false;
                if (_bot.GetPlayer.HealthController == null || !_bot.GetPlayer.HealthController.IsAlive) return false;

                float composure = _cache?.PanicHandler?.GetComposureLevel() ?? 1f;
                float panicThreshold = Mathf.Lerp(0.35f, 0.15f, _profile.Caution);
                if (composure < panicThreshold)
                {
                    _log.LogDebug("[ExtractDecision] Panic threshold triggered → " + _bot.name);
                    return true;
                }

                float lootValue = _cache?.LootScanner?.TotalLootValue ?? 0f;
                float lootThreshold = Mathf.Lerp(85000f, 50000f, _profile.Greed);
                if (lootValue >= lootThreshold)
                {
                    _log.LogDebug("[ExtractDecision] Loot threshold met → " + _bot.name + $" ({lootValue:F0})");
                    return true;
                }

                if (HasSquadWiped())
                {
                    _log.LogDebug("[ExtractDecision] Squad wiped → " + _bot.name);
                    return true;
                }

                float cohesionRadius = Mathf.Lerp(35f, 60f, 1f - _profile.Cohesion);
                if (IsBotIsolated(cohesionRadius))
                {
                    _log.LogDebug("[ExtractDecision] Bot is isolated → " + _bot.name);
                    return true;
                }

                float stuckTimeout = Mathf.Lerp(8f, 18f, 1f - _profile.Caution);
                if (IsBotStuck(now, stuckTimeout))
                {
                    _stuckRetryCount++;
                    if (_stuckRetryCount >= MaxStuckRetries)
                    {
                        _log.LogDebug("[ExtractDecision] Movement failure x" + _stuckRetryCount + " → " + _bot.name);
                        return true;
                    }
                    BotMovementHelper.ForceFallbackMove(_bot);
                }

                return false;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] ShouldExtract failed: {ex}");
                return false;
            }
        }

        public void TriggerExtraction()
        {
            try
            {
                if (_bot.IsDead || _bot.GetPlayer == null || !_bot.GetPlayer.IsAI ||
                    _bot.GetPlayer.HealthController == null || !_bot.GetPlayer.HealthController.IsAlive)
                {
                    _log.LogWarning("[ExtractDecision] ❌ Extraction aborted — invalid state for " + _bot.name);
                    return;
                }

                _cache?.TacticalMemory?.MarkExtractionStarted();

                Vector3 exfilTarget;
                if (TryFindNearbyExfil(out exfilTarget))
                {
                    // Issue move command to exfil point
                    _bot.Mover?.GoToPoint(exfilTarget, true, 1f);
                    // On the next frame, poll the actual target from the path
                    if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safeTarget))
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, safeTarget, true);
                        _log.LogDebug("[ExtractDecision] ✅ Extraction initiated (exfil found) for: " + _bot.name);
                        return;
                    }
                }
                else
                {
                    // Fallback: move forward, but only through path-based navigation
                    Vector3 forwardTarget = _bot.Position + _bot.LookDirection.normalized * 6f;
                    _bot.Mover?.GoToPoint(forwardTarget, true, 1f);

                    if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safeFallback))
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, safeFallback, true);
                        _log.LogDebug("[ExtractDecision] ✅ Extraction initiated (fallback forward) for: " + _bot.name);
                    }
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] TriggerExtraction failed: {ex}");
            }
        }

        #endregion

        #region Private Helpers

        private bool IsBotStuck(float now, float threshold)
        {
            float moved = (_bot.Position - _lastPosition).sqrMagnitude;
            if (moved > 0.35f)
            {
                _lastPosition = _bot.Position;
                _lastMoveUpdateTime = now;
                _stuckRetryCount = 0;
                return false;
            }

            return now - _lastMoveUpdateTime >= threshold;
        }

        private bool HasSquadWiped()
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return false;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                    return false;
            }

            return true;
        }

        private bool IsBotIsolated(float radius)
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return true;

            Vector3 pos = _bot.Position;
            float radiusSqr = radius * radius;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                {
                    if ((mate.Position - pos).sqrMagnitude < radiusSqr)
                        return false;
                }
            }

            return true;
        }

        private bool TryFindNearbyExfil(out Vector3 exfil)
        {
            exfil = Vector3.zero;
            ExfiltrationPoint[] points = UnityEngine.Object.FindObjectsOfType<ExfiltrationPoint>();
            Vector3 pos = _bot.Position;
            float bestDist = MaxSearchDistance * MaxSearchDistance + 1f;
            bool found = false;

            foreach (ExfiltrationPoint point in points)
            {
                if (point == null || !point.enabled)
                    continue;

                float dist = (point.transform.position - pos).sqrMagnitude;
                if (dist <= MaxSearchDistance * MaxSearchDistance && dist < bestDist)
                {
                    exfil = point.transform.position;
                    bestDist = dist;
                    found = true;
                }
            }

            return found;
        }

        #endregion
    }
}
