// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Memory
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using UnityEngine;

    /// <summary>
    /// Tracks enemy sightings and cleared tactical zones.
    /// Prevents over-investigation, supports fallback, and enables squad memory sync.
    /// </summary>
    public sealed class BotTacticalMemory
    {
        #region Constants

        private const float ClearedMemoryDuration = 10f;
        private const float GridSnapSize = 0.5f;
        private const float MaxMemoryTime = 14f;
        private const float PositionToleranceSqr = 0.25f;

        #endregion

        #region Fields

        private readonly Dictionary<Vector3, float> _clearedSpots = new Dictionary<Vector3, float>(32, new Vector3EqualityComparer());
        private readonly Dictionary<string, SeenEnemyRecord> _enemyMemoryById = new Dictionary<string, SeenEnemyRecord>(4, StringComparer.OrdinalIgnoreCase);
        private readonly List<SeenEnemyRecord> _enemyMemoryList = new List<SeenEnemyRecord>(4);

        private BotComponentCache _cache;
        private bool _extractionStarted;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            if (cache != null)
            {
                _cache = cache;
            }
        }

        #endregion

        #region Memory Management

        public void CullExpired()
        {
            float now = Time.time;

            for (int i = _enemyMemoryList.Count - 1; i >= 0; i--)
            {
                if (now - _enemyMemoryList[i].TimeSeen > MaxMemoryTime)
                {
                    _enemyMemoryList.RemoveAt(i);
                }
            }

            List<string> expired = TempListPool.Rent<string>();
            foreach (KeyValuePair<string, SeenEnemyRecord> kvp in _enemyMemoryById)
            {
                if (now - kvp.Value.TimeSeen > MaxMemoryTime)
                {
                    expired.Add(kvp.Key);
                }
            }

            for (int i = 0; i < expired.Count; i++)
            {
                _enemyMemoryById.Remove(expired[i]);
            }

            TempListPool.Return(expired);
        }

        public void ClearAll()
        {
            _enemyMemoryList.Clear();
            _enemyMemoryById.Clear();
            _clearedSpots.Clear();
            _extractionStarted = false;
        }

        #endregion

        #region Enemy Memory

        public void RecordEnemyPosition(Vector3 position, string tag, string enemyId)
        {
            if (_cache == null || _cache.IsBlinded || (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking))
            {
                return;
            }

            float now = Time.time;
            Vector3 gridPos = SnapToGrid(position);
            string finalTag = string.IsNullOrEmpty(tag) ? "Generic" : tag.Trim();

            if (!string.IsNullOrEmpty(enemyId))
            {
                string cleanId = enemyId.Trim();
                if (cleanId.Length > 0)
                {
                    _enemyMemoryById[cleanId] = new SeenEnemyRecord(gridPos, now, finalTag);
                }
            }

            for (int i = 0; i < _enemyMemoryList.Count; i++)
            {
                if ((gridPos - _enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                {
                    _enemyMemoryList[i] = new SeenEnemyRecord(gridPos, now, finalTag);
                    return;
                }
            }

            _enemyMemoryList.Add(new SeenEnemyRecord(gridPos, now, finalTag));
        }

        public Vector3 GetRecentEnemyMemory()
        {
            float now = Time.time;
            float latestTime = -1f;
            Vector3 freshestPosition = Vector3.zero;

            for (int i = 0; i < _enemyMemoryList.Count; i++)
            {
                SeenEnemyRecord record = _enemyMemoryList[i];
                if (now - record.TimeSeen <= MaxMemoryTime && record.TimeSeen > latestTime)
                {
                    latestTime = record.TimeSeen;
                    freshestPosition = record.Position;
                }
            }

            return freshestPosition;
        }

        public string GetMostRecentEnemyId()
        {
            float now = Time.time;
            float latestTime = -1f;
            string latestId = string.Empty;

            foreach (KeyValuePair<string, SeenEnemyRecord> kvp in _enemyMemoryById)
            {
                if (now - kvp.Value.TimeSeen <= MaxMemoryTime && kvp.Value.TimeSeen > latestTime)
                {
                    latestTime = kvp.Value.TimeSeen;
                    latestId = kvp.Key;
                }
            }

            return latestId;
        }

        public List<SeenEnemyRecord> GetAllMemory()
        {
            return _enemyMemoryList;
        }

        public void SyncMemory(Vector3 position)
        {
            RecordEnemyPosition(position, "AllyEcho", string.Empty);
        }

        public void ShareMemoryWith(List<BotComponentCache> teammates)
        {
            if (teammates == null || teammates.Count == 0 || _cache == null || _cache.Bot == null)
            {
                return;
            }

            for (int i = 0; i < _enemyMemoryList.Count; i++)
            {
                SeenEnemyRecord record = _enemyMemoryList[i];

                for (int j = 0; j < teammates.Count; j++)
                {
                    BotComponentCache mate = teammates[j];
                    if (mate == null || mate.Bot == null || mate.Bot == _cache.Bot)
                    {
                        continue;
                    }

                    BotTacticalMemory memory = mate.TacticalMemory;
                    if (memory != null)
                    {
                        memory.SyncMemory(record.Position);
                    }
                }
            }
        }

        #endregion

        #region Zone Memory

        public void MarkCleared(Vector3 position)
        {
            _clearedSpots[SnapToGrid(position)] = Time.time;
        }

        public bool WasRecentlyCleared(Vector3 position)
        {
            Vector3 gridPos = SnapToGrid(position);
            return _clearedSpots.TryGetValue(gridPos, out float lastTime) && Time.time - lastTime < ClearedMemoryDuration;
        }

        public bool IsZoneUnsafe(Vector3 position)
        {
            if (_cache == null || _cache.Bot == null || _cache.Bot.Profile == null)
            {
                return false;
            }

            float now = Time.time;
            Vector3 gridPos = SnapToGrid(position);

            for (int i = 0; i < _enemyMemoryList.Count; i++)
            {
                if ((gridPos - _enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                {
                    return true;
                }
            }

            foreach (KeyValuePair<Vector3, float> kvp in _clearedSpots)
            {
                if ((kvp.Key - gridPos).sqrMagnitude < PositionToleranceSqr && now - kvp.Value < ClearedMemoryDuration)
                {
                    return true;
                }
            }

            string mapId = GameWorldHandler.TryGetValidMapName();
            return mapId.Length > 0 && BotMemoryStore.IsPositionInDangerZone(mapId, position);
        }

        public void MarkExtractionStarted()
        {
            _extractionStarted = true;
        }

        public bool IsExtracting()
        {
            return _extractionStarted;
        }

        #endregion

        #region Utility

        private static Vector3 SnapToGrid(Vector3 pos)
        {
            return new Vector3(
                Mathf.Round(pos.x / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.y / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.z / GridSnapSize) * GridSnapSize);
        }

        #endregion

        #region Types

        public struct SeenEnemyRecord
        {
            public Vector3 Position;
            public float TimeSeen;
            public string Tag;

            public SeenEnemyRecord(Vector3 position, float time, string tag)
            {
                Position = position;
                TimeSeen = time;
                Tag = tag;
            }
        }

        private sealed class Vector3EqualityComparer : IEqualityComparer<Vector3>
        {
            public bool Equals(Vector3 a, Vector3 b)
            {
                return (a - b).sqrMagnitude < PositionToleranceSqr;
            }

            public int GetHashCode(Vector3 v)
            {
                unchecked
                {
                    int hash = 17;
                    hash = (hash * 23) + Mathf.RoundToInt(v.x * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.y * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.z * 10f);
                    return hash;
                }
            }
        }

        #endregion
    }
}
