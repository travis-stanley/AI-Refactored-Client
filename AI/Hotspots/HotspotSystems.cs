// <auto-generated>
//   AI-Refactored: HotspotSystem.cs (Beyond Diamond Tactical Nav Edition – Squad-Aware Hotspot Patrol)
//   Full support for tactical personality-aware movement between hotspots with fallback, error shielding, and BotBrain integration.
//   All movement is NavMesh validated. Damage feedback is panic-routed. Fully compliant with Squad, FIKA, and Multiplayer.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Hotspots
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using Comfort.Common;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;

    /// <summary>
    /// Drives bot navigation between tactical hotspots. Supports route and defense behavior.
    /// Bulletproof: all logic is personality-validated and panic-aware. No cascading errors.
    /// </summary>
    public sealed class HotspotSystem
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
        private static readonly List<BotOwner> BotList = new List<BotOwner>(64);

        private readonly Dictionary<BotOwner, HotspotSession> _sessions = new Dictionary<BotOwner, HotspotSession>(64);

        public void Initialize()
        {
            _sessions.Clear();
            string map = GameWorldHandler.TryGetValidMapName();
            HotspotRegistry.Initialize(map ?? string.Empty);
        }

        public void Tick()
        {
            try
            {
                BotsController ctrl = Singleton<BotsController>.Instance;
                if (ctrl?.Bots?.BotOwners == null)
                    return;

                BotList.Clear();
                BotList.AddRange(ctrl.Bots.BotOwners);

                foreach (var bot in BotList)
                {
                    if (!EFTPlayerUtil.IsValidBotOwner(bot) || bot.GetPlayer.IsYourPlayer)
                        continue;

                    try
                    {
                        if (!_sessions.TryGetValue(bot, out var session))
                        {
                            session = TryAssignRoute(bot);
                            if (session != null)
                                _sessions[bot] = session;
                        }

                        session?.Tick();
                    }
                    catch { }
                }
            }
            catch { }
        }

        private HotspotSession TryAssignRoute(BotOwner bot)
        {
            try
            {
                var profile = BotRegistry.Get(bot.ProfileId);
                if (profile == null)
                    return null;

                var all = HotspotRegistry.GetAll();
                if (all == null || all.Count == 0)
                    return null;

                List<HotspotRegistry.Hotspot> pool = HotspotRegistry.QueryNearby(bot.Position, 150f, null) ?? new List<HotspotRegistry.Hotspot>(all);

                if (pool.Count == 0)
                    pool = new List<HotspotRegistry.Hotspot>(all);

                bool defend = profile.Personality == PersonalityType.Camper ||
                              (profile.Personality == PersonalityType.Cautious && UnityEngine.Random.value < 0.5f);

                if (defend)
                {
                    var point = pool[UnityEngine.Random.Range(0, pool.Count)];
                    return new HotspotSession(bot, new List<HotspotRegistry.Hotspot> { point }, true);
                }

                int count = UnityEngine.Random.Range(2, 4);
                List<HotspotRegistry.Hotspot> route = new List<HotspotRegistry.Hotspot>(count);
                HashSet<int> used = new HashSet<int>();

                while (route.Count < count && used.Count < pool.Count)
                {
                    int index = UnityEngine.Random.Range(0, pool.Count);
                    if (used.Add(index))
                        route.Add(pool[index]);
                }

                return new HotspotSession(bot, route, false);
            }
            catch (Exception ex)
            {
                Logger.LogWarning($"[HotspotSystem] Route assignment error: {ex.Message}");
                return null;
            }
        }

        #region HotspotSession

        private sealed class HotspotSession
        {
            private const float BaseDefendRadius = 7f;
            private const float DamageCooldown = 6f;

            private readonly BotOwner _bot;
            private readonly BotComponentCache _cache;
            private readonly List<HotspotRegistry.Hotspot> _route;
            private readonly bool _isDefender;

            private int _index;
            private float _lastHitTime;
            private float _nextSwitchTime;

            public HotspotSession(BotOwner bot, List<HotspotRegistry.Hotspot> route, bool isDefender)
            {
                _bot = bot;
                _route = route;
                _isDefender = isDefender;
                _cache = BotCacheUtility.GetCache(bot);
                _index = 0;
                _lastHitTime = -999f;
                _nextSwitchTime = Time.time + GetSwitchTime();

                try
                {
                    if (_bot.GetPlayer?.HealthController is HealthControllerClass hc)
                        hc.ApplyDamageEvent += OnDamage;
                }
                catch { }
            }

            public void Tick()
            {
                if (!EFTPlayerUtil.IsValidBotOwner(_bot) || _route.Count == 0 || _bot.GetPlayer.IsYourPlayer)
                    return;

                if (_bot.Memory?.GoalEnemy != null || Time.time - _lastHitTime < DamageCooldown)
                    return;

                Vector3 dest = _route[_index].Position;

                if (_isDefender)
                {
                    float radius = BaseDefendRadius * Mathf.Clamp(1f + (1f - (_cache?.PanicHandler?.GetComposureLevel() ?? 1f)), 1f, 2.1f);
                    if (Vector3.Distance(_bot.Position, dest) > radius)
                        BotMovementHelper.SmoothMoveTo(_bot, dest);
                }
                else
                {
                    if (Time.time >= _nextSwitchTime || Vector3.Distance(_bot.Position, dest) < 2f)
                    {
                        _index = (_index + 1) % _route.Count;
                        _nextSwitchTime = Time.time + GetSwitchTime();
                    }

                    BotMovementHelper.SmoothMoveTo(_bot, AddJitter(dest));
                }
            }

            private Vector3 AddJitter(Vector3 basePos)
            {
                var profile = _cache?.AIRefactoredBotOwner?.PersonalityProfile;
                if (profile == null)
                    return basePos;

                float chaos = profile.ChaosFactor;
                Vector3 jitter = Vector3.zero;

                if (profile.IsFrenzied)
                    jitter = UnityEngine.Random.insideUnitSphere * 2.25f;
                else if (profile.IsSilentHunter)
                    jitter = UnityEngine.Random.insideUnitSphere * 0.3f;
                else if (chaos > 0.35f)
                    jitter = new Vector3(Mathf.Sin(Time.time), 0f, Mathf.Cos(Time.time)) * chaos;

                jitter.y = 0f;
                return basePos + jitter;
            }

            private float GetSwitchTime()
            {
                try
                {
                    var profile = BotRegistry.Get(_bot.ProfileId);
                    if (profile == null)
                        return 100f;

                    float chaos = Mathf.Clamp01(1f + profile.ChaosFactor * 0.6f);

                    switch (profile.Personality)
                    {
                        case PersonalityType.Camper:
                        case PersonalityType.Stoic:
                        case PersonalityType.Sentinel:
                            return 200f * chaos;
                        case PersonalityType.Methodical:
                        case PersonalityType.Supportive:
                            return 160f * chaos;
                        case PersonalityType.Balanced:
                        case PersonalityType.Vigilante:
                            return 100f * chaos;
                        case PersonalityType.Aggressive:
                        case PersonalityType.Hunter:
                            return 60f * chaos;
                        case PersonalityType.Frenzied:
                        case PersonalityType.Reckless:
                            return UnityEngine.Random.Range(45f, 90f) * chaos;
                        case PersonalityType.Dumb:
                        case PersonalityType.Fearful:
                            return 45f * chaos;
                        default:
                            return 100f * chaos;
                    }
                }
                catch
                {
                    return 100f;
                }
            }

            private void OnDamage(EBodyPart part, float dmg, DamageInfoStruct info)
            {
                try
                {
                    _lastHitTime = Time.time;
                    _cache?.PanicHandler?.TriggerPanic();
                }
                catch { }
            }
        }

        #endregion
    }
}
