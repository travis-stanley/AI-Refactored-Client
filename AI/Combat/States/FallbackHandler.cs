// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles suppression fallback, retreat routing, and cover movement during engagements.
    /// Bulletproof: All failures are isolated; only this handler disables itself and triggers vanilla fallback if required.
    /// </summary>
    public sealed class FallbackHandler : IDisposable
    {
        #region Constants

        private const float MinArrivalDistance = 2.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _currentFallbackPath;

        private Vector3 _fallbackTarget;
        private bool _isFallbackMode;

        #endregion

        #region Constructor

        public FallbackHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _fallbackTarget = _bot != null ? _bot.Position : Vector3.zero;
            _currentFallbackPath = TempListPool.Rent<Vector3>();

            if (_cache == null || _bot == null)
            {
                BotFallbackUtility.Trigger(this, _bot, "Null Bot or cache during initialization.");
                _isFallbackMode = true;
            }
            else
            {
                _isFallbackMode = false;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Gets the current fallback target position.
        /// </summary>
        public Vector3 GetFallbackPosition()
        {
            return _fallbackTarget;
        }

        /// <summary>
        /// Gets the fallback position, or the provided default if path is invalid.
        /// </summary>
        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos)
        {
            return HasValidFallbackPath() ? _fallbackTarget : defaultPos;
        }

        /// <summary>
        /// True if the fallback path is valid and nontrivial.
        /// </summary>
        public bool HasValidFallbackPath()
        {
            return _currentFallbackPath.Count >= 2 && IsVectorValid(_fallbackTarget);
        }

        /// <summary>
        /// Sets the fallback target, if valid.
        /// </summary>
        public void SetFallbackTarget(Vector3 target)
        {
            if (_isFallbackMode)
                return;

            if (!IsVectorValid(target))
            {
                BotFallbackUtility.Trigger(this, _bot, "Ignored fallback target with invalid vector.");
                return;
            }

            _fallbackTarget = target;
        }

        /// <summary>
        /// Sets the fallback path using a list of valid points.
        /// </summary>
        public void SetFallbackPath(List<Vector3> path)
        {
            if (_isFallbackMode)
                return;

            if (path == null || path.Count < 2)
            {
                BotFallbackUtility.Trigger(this, _bot, "Rejected fallback path: path too short.");
                return;
            }

            _currentFallbackPath.Clear();

            for (int i = 0; i < path.Count; i++)
            {
                Vector3 point = path[i];
                if (IsVectorValid(point))
                {
                    _currentFallbackPath.Add(point);
                }
            }

            if (_currentFallbackPath.Count >= 2)
            {
                _fallbackTarget = _currentFallbackPath[_currentFallbackPath.Count - 1];
            }
            else
            {
                BotFallbackUtility.Trigger(this, _bot, "Final fallback path was invalid.");
            }
        }

        /// <summary>
        /// Returns true if fallback should be used right now.
        /// </summary>
        public bool ShallUseNow(float time)
        {
            if (_isFallbackMode)
                return false;

            return !_cache.IsFallbackMode &&
                   _bot != null &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        /// <summary>
        /// Determines if fallback should be triggered due to suppression.
        /// </summary>
        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            if (_isFallbackMode)
                return false;

            return _cache.Suppression != null &&
                   _cache.Suppression.IsSuppressed() &&
                   (now - lastStateChangeTime) >= minStateDuration;
        }

        /// <summary>
        /// Tick update: drives fallback movement and cover, triggers patrol on arrival.
        /// </summary>
        public void Tick(float time, Action<CombatState, float> forceState)
        {
            if (_isFallbackMode || _cache.IsFallbackMode || _bot == null || !IsVectorValid(_fallbackTarget))
                return;

            try
            {
                Player player = _bot.GetPlayer;
                if (!EFTPlayerUtil.IsValid(player))
                {
                    BotFallbackUtility.Trigger(this, _bot, "Tick skipped: bot player invalid.");
                    return;
                }

                if (_bot.Mover != null)
                {
                    try
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, _fallbackTarget);
                        BotCoverHelper.TrySetStanceFromNearbyCover(_cache, _fallbackTarget);
                    }
                    catch (Exception ex)
                    {
                        BotFallbackUtility.Trigger(this, _bot, "SmoothMoveTo or stance logic failed.", ex);
                        _isFallbackMode = true;
                        BotFallbackUtility.FallbackToEFTLogic(_bot);
                        return;
                    }
                }
                else
                {
                    BotFallbackUtility.Trigger(this, _bot, "BotMover missing. Fallback to EFT AI.");
                    _isFallbackMode = true;
                    BotFallbackUtility.FallbackToEFTLogic(_bot);
                    return;
                }

                if (Vector3.Distance(_bot.Position, _fallbackTarget) < MinArrivalDistance)
                {
                    forceState?.Invoke(CombatState.Patrol, time);

                    if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null)
                    {
                        try { _bot.BotTalk.TrySay(EPhraseTrigger.NeedHelp); }
                        catch { /* no-op */ }
                    }
                }
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "General Tick exception.", ex);
                _isFallbackMode = true;
            }
        }

        /// <summary>
        /// Returns true if fallback state is still active.
        /// </summary>
        public bool IsActive()
        {
            if (_isFallbackMode)
                return false;

            return _bot != null &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        /// <summary>
        /// Cancels fallback and clears any cached path.
        /// </summary>
        public void Cancel()
        {
            if (_isFallbackMode)
                return;

            _fallbackTarget = (_bot != null) ? _bot.Position : Vector3.zero;
            _currentFallbackPath.Clear();
        }

        /// <summary>
        /// Releases pooled resources.
        /// </summary>
        public void Dispose()
        {
            TempListPool.Return(_currentFallbackPath);
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Validates a Vector3 for fallback/AI purposes.
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) &&
                   !float.IsNaN(v.y) &&
                   !float.IsNaN(v.z) &&
                   v != Vector3.zero;
        }

        #endregion
    }
}
