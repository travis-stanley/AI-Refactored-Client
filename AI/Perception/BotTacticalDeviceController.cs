// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI, never break the stack.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.InventoryLogic;
    using UnityEngine;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Controls and manages tactical device toggling for bot AI:
    /// Flashlights, lasers, NVGs, and thermals.
    /// Handles ambient/fog-based logic and chaos-driven baiting,
    /// ensuring full headless and multiplayer safety.
    /// </summary>
    public sealed class BotTacticalDeviceController
    {
        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _nextDecisionTime;
        private bool _failed; // disables this subsystem on hard error

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the controller for the provided bot component cache.
        /// </summary>
        /// <param name="cache">The bot's runtime component cache.</param>
        public void Initialize(BotComponentCache cache)
        {
            try
            {
                _failed = false;
                if (cache == null || cache.Bot == null)
                {
                    _failed = true;
                    return;
                }

                _bot = cache.Bot;
                _cache = cache;
                _nextDecisionTime = 0f;
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] Initialize exception: {ex}");
            }
        }

        #endregion

        #region Tick

        /// <summary>
        /// Updates tactical device logic. Must be called every frame by BotBrain.
        /// Fully allocation- and null-safe, with pooling and headless/multiplayer support.
        /// </summary>
        public void Tick()
        {
            if (_failed || !CanThink())
            {
                return;
            }

            try
            {
                _nextDecisionTime = Time.time + TacticalConfig.CheckInterval;

                Weapon weapon = _bot.WeaponManager != null ? _bot.WeaponManager.CurrentWeapon : null;
                if (weapon == null)
                {
                    return;
                }

                List<LightComponent> devices = TempListPool.Rent<LightComponent>();
                try
                {
                    ScanModsForTacticalDevices(weapon, devices);

                    bool isLowVisibility = IsLowVisibility();
                    float chaosChance = GetChaosBaitChance();
                    bool baitTrigger = Random.value < chaosChance;
                    bool shouldEnable = isLowVisibility || baitTrigger;

                    for (int i = 0, count = devices.Count; i < count; i++)
                    {
                        LightComponent device = devices[i];
                        if (device != null && device.IsActive != shouldEnable)
                        {
                            device.IsActive = shouldEnable;
                        }
                    }

                    // If chaos bait is triggered, flash the lights briefly, then force-off for bait
                    if (baitTrigger)
                    {
                        _nextDecisionTime = Time.time + 1.5f;
                        for (int i = 0, count = devices.Count; i < count; i++)
                        {
                            LightComponent device = devices[i];
                            if (device != null)
                            {
                                device.IsActive = false;
                            }
                        }
                    }
                }
                finally
                {
                    TempListPool.Return(devices);
                }
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] Tick exception: {ex}");
            }
        }

        #endregion

        #region Logic

        /// <summary>
        /// Determines if tactical device logic should run this frame.
        /// </summary>
        private bool CanThink()
        {
            return !_failed
                && _bot != null
                && _cache != null
                && !_bot.IsDead
                && Time.time >= _nextDecisionTime
                && EFTPlayerUtil.IsValid(_bot.GetPlayer)
                && _bot.GetPlayer.IsAI;
        }

        /// <summary>
        /// Computes bait/chaos chance from the bot's personality and awareness.
        /// </summary>
        private float GetChaosBaitChance()
        {
            try
            {
                var owner = _cache != null ? _cache.AIRefactoredBotOwner : null;
                if (owner == null)
                {
                    return 0f;
                }

                BotPersonalityProfile profile = owner.PersonalityProfile;
                if (profile == null)
                    return 0f;

                // Awareness slightly reduces chaos chance for smarter bots (realism)
                float baseChaos = profile.ChaosFactor * 0.25f;
                float awarenessMod = 1f - Mathf.Clamp01(profile.Awareness); // High awareness, less baiting
                return Mathf.Clamp01(baseChaos * (0.7f + 0.6f * awarenessMod));
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] GetChaosBaitChance exception: {ex}");
                return 0f;
            }
        }

        /// <summary>
        /// Returns true if the environment is considered low-visibility.
        /// </summary>
        private static bool IsLowVisibility()
        {
            try
            {
                float ambient = RenderSettings.ambientLight.grayscale;
                float fogDensity = RenderSettings.fog ? RenderSettings.fogDensity : 0f;
                return ambient < TacticalConfig.LightThreshold || fogDensity > TacticalConfig.FogThreshold;
            }
            catch
            {
                // On RenderSettings/graphics API error, default to false (safe for headless)
                return false;
            }
        }

        /// <summary>
        /// Adds all valid tactical devices on the weapon to the result list.
        /// </summary>
        private static void ScanModsForTacticalDevices(Weapon weapon, List<LightComponent> result)
        {
            if (weapon == null || result == null)
            {
                return;
            }

            var slots = weapon.AllSlots;
            if (slots == null)
            {
                return;
            }

            foreach (Slot slot in slots)
            {
                if (slot == null)
                {
                    continue;
                }

                Item mod = slot.ContainedItem;
                if (mod == null || mod.Template == null)
                {
                    continue;
                }

                string name = mod.Template.Name?.ToLowerInvariant();
                if (string.IsNullOrEmpty(name) || !IsTacticalName(name))
                {
                    continue;
                }

                if (mod is FlashlightItemClass flash && flash.Light != null)
                {
                    result.Add(flash.Light);
                }
                else if (mod is TacticalComboItemClass combo && combo.Light != null)
                {
                    result.Add(combo.Light);
                }
                else if (mod is LightLaserItemClass laser && laser.Light != null)
                {
                    result.Add(laser.Light);
                }
            }
        }

        /// <summary>
        /// Checks if the mod name contains tactical keywords.
        /// </summary>
        private static bool IsTacticalName(string name)
        {
            var keywords = TacticalConfig.Keywords;
            for (int i = 0, count = keywords.Length; i < count; i++)
            {
                if (name.Contains(keywords[i]))
                {
                    return true;
                }
            }
            return false;
        }

        #endregion

        #region TacticalConfig

        /// <summary>
        /// Static tactical device config for thresholds and keywords.
        /// </summary>
        private static class TacticalConfig
        {
            public const float CheckInterval = 2.0f;
            public const float FogThreshold = 0.5f;
            public const float LightThreshold = 0.3f;

            public static readonly string[] Keywords = { "light", "laser", "nvg", "thermal", "flash" };
        }

        #endregion
    }
}
