// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using UnityEngine;

    /// <summary>
    /// Evaluates directional exposure to high-intensity light sources like flashlights and flares.
    /// Used by AI vision systems for flashblindness detection, light evasion, and behavioral reactions.
    /// Bulletproof: all logic is null-guarded and outputs are safe and deterministic.
    /// </summary>
    public static class FlashLightUtils
    {
        /// <summary>
        /// Returns a visibility score between 0 and 1 based on angle and distance to flashlight.
        /// Combines frontal alignment and proximity to determine severity of exposure.
        /// </summary>
        public static float CalculateFlashScore(Transform lightTransform, Transform botHeadTransform, float maxDistance = 20f)
        {
            try
            {
                if (lightTransform == null || botHeadTransform == null)
                    return 0f;

                Vector3 toLight = lightTransform.position - botHeadTransform.position;
                float distance = toLight.magnitude;

                if (distance < 0.01f || distance > maxDistance || float.IsNaN(distance))
                    return 0f;

                // Frontal alignment (1=directly in front, 0=behind)
                float alignmentFactor = Mathf.Clamp01(Vector3.Dot(botHeadTransform.forward, toLight.normalized));
                // Closer lights are more intense
                float distanceFactor = 1f - Mathf.Clamp01(distance / maxDistance);

                if (float.IsNaN(alignmentFactor) || float.IsNaN(distanceFactor))
                    return 0f;

                // Boost for extreme frontal hits to model how sudden flash can shock
                if (alignmentFactor > 0.93f && distance < maxDistance * 0.7f)
                    return Mathf.Clamp01(alignmentFactor * 1.18f * distanceFactor);

                return alignmentFactor * distanceFactor;
            }
            catch
            {
                return 0f;
            }
        }

        /// <summary>
        /// Calculates the normalized frontal exposure to a flashlight.
        /// </summary>
        public static float GetFlashIntensityFactor(Transform lightTransform, Transform botHeadTransform)
        {
            try
            {
                if (lightTransform == null || botHeadTransform == null)
                    return 0f;

                Vector3 toLight = lightTransform.position - botHeadTransform.position;
                float dot = Vector3.Dot(botHeadTransform.forward, toLight.normalized);

                if (float.IsNaN(dot))
                    return 0f;

                return Mathf.Clamp01(dot);
            }
            catch
            {
                return 0f;
            }
        }

        /// <summary>
        /// Determines whether the bot is facing a light source within a dangerous exposure cone.
        /// </summary>
        public static bool IsBlindingLight(Transform lightTransform, Transform botHeadTransform, float angleThreshold = 30f)
        {
            try
            {
                if (lightTransform == null || botHeadTransform == null)
                    return false;

                Vector3 toLight = lightTransform.position - botHeadTransform.position;
                float angle = Vector3.Angle(botHeadTransform.forward, toLight);

                if (float.IsNaN(angle))
                    return false;

                return angle <= angleThreshold;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Determines if the flashlight is pointing toward the target within the specified angle threshold.
        /// </summary>
        public static bool IsFacingTarget(Transform source, Transform target, float angleThreshold = 30f)
        {
            try
            {
                if (source == null || target == null)
                    return false;

                Vector3 toTarget = target.position - source.position;
                float angle = Vector3.Angle(source.forward, toTarget);

                if (float.IsNaN(angle))
                    return false;

                return angle <= angleThreshold;
            }
            catch
            {
                return false;
            }
        }
    }
}
