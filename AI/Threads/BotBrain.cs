// <auto-generated>
//   AI-Refactored: BotBrain.cs (Beyond Diamond – Headless Hardened Edition, June 2025)
//   Fixes headless stutter/teleportation by fully validating cache/owner on init.
//   Bulletproof: no null propagation, all ticks gated, full parity for headless/client/server.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Threads
{
	using System;
	using AIRefactored.AI.Combat;
	using AIRefactored.AI.Combat.States;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Groups;
	using AIRefactored.AI.Looting;
	using AIRefactored.AI.Medical;
	using AIRefactored.AI.Memory;
	using AIRefactored.AI.Missions;
	using AIRefactored.AI.Movement;
	using AIRefactored.AI.Navigation;
	using AIRefactored.AI.Optimization;
	using AIRefactored.AI.Perception;
	using AIRefactored.AI.Reactions;
	using AIRefactored.Core;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using UnityEngine;

	public sealed class BotBrain : MonoBehaviour
	{
		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private BotOwner _bot;
		private Player _player;
		private BotComponentCache _cache;

		private CombatStateMachine _combat;
		private BotMovementController _movement;
		private BotPoseController _pose;
		private BotLookController _look;
		private BotTilt _tilt;
		private BotCornerScanner _corner;
		private BotGroupBehavior _groupBehavior;
		private BotJumpController _jump;
		private BotVisionSystem _vision;
		private BotHearingSystem _hearing;
		private BotPerceptionSystem _perception;
		private HearingDamageComponent _hearingDamage;
		private FlashGrenadeComponent _flashDetector;
		private BotFlashReactionComponent _flashReaction;
		private BotTacticalDeviceController _tactical;
		private BotMissionController _mission;
		private BotGroupSyncCoordinator _groupSync;
		private BotTeamLogic _teamLogic;
		private BotAsyncProcessor _asyncProcessor;
		private BotThreatEscalationMonitor _threatEscalationMonitor;
		private BotInjurySystem _injury;
		private BotDeadBodyScanner _deadBodyScanner;
		private BotLootScanner _lootScanner;
		private BotLootDecisionSystem _lootDecisionSystem;
		private BotSuppressionReactionComponent _suppression;
		private BotPanicHandler _panic;
		private BotLastShotTracker _lastShotTracker;
		private BotGroupComms _groupComms;
		private FallbackHandler _fallbackHandler;
		private SquadPathCoordinator _squadPath;
		private BotOwnerPathfindingCache _pathing;
		private BotDoorInteractionSystem _doorInteraction;
		private BotTacticalMemory _tacticalMemory;
		private TrackedEnemyVisibility _trackedVisibility;

		private float _nextPerceptionTick;
		private float _nextCombatTick;
		private float _nextLogicTick;
		private float _now;

		private const float DefaultPerceptionHz = 30f;
		private const float DefaultCombatHz = 30f;
		private const float DefaultLogicHz = 10f;

		private float PerceptionTickRate => 1f / DefaultPerceptionHz;
		private float CombatTickRate => 1f / DefaultCombatHz;
		private float LogicTickRate => 1f / DefaultLogicHz;

		public void Initialize(BotOwner bot)
		{
			if (bot == null)
			{
				Logger.LogError("[BotBrain] Init failed: null BotOwner.");
				enabled = false;
				return;
			}

			_bot = bot;
			_player = bot.GetPlayer;

			if (_player == null || !_player.IsAI || _player.IsYourPlayer || bot.IsDead || _player.Profile?.Info == null)
			{
				Logger.LogWarning("[BotBrain] Init rejected: invalid AI player.");
				enabled = false;
				return;
			}

			_cache = BotComponentCacheRegistry.GetOrCreate(bot);
			if (_cache == null || _cache.AIRefactoredBotOwner == null || !_cache.AIRefactoredBotOwner.IsInitialized || !_cache.IsReady)
			{
				Logger.LogWarning("[BotBrain] Init failed: cache/owner not ready.");
				enabled = false;
				return;
			}

			_cache.SetOwner(_cache.AIRefactoredBotOwner);

			_combat = _cache.Combat;
			_movement = _cache.Movement;
			_pose = _cache.PoseController;
			_look = _cache.Look;
			_tilt = _cache.Tilt;
			_groupBehavior = _cache.GroupBehavior;
			_jump = new BotJumpController(bot, _cache);
			_corner = new BotCornerScanner(); _corner.Initialize(bot, _cache);
			_vision = new BotVisionSystem(); _vision.Initialize(_cache);
			_hearing = new BotHearingSystem(); _hearing.Initialize(_cache);
			_perception = new BotPerceptionSystem(); _perception.Initialize(_cache);
			_flashReaction = new BotFlashReactionComponent(); _flashReaction.Initialize(_cache);
			_flashDetector = new FlashGrenadeComponent(); _flashDetector.Initialize(_cache);
			_hearingDamage = new HearingDamageComponent();
			_tactical = _cache.Tactical;
			_mission = new BotMissionController(bot, _cache);
			_groupSync = new BotGroupSyncCoordinator(); _groupSync.Initialize(bot); _groupSync.InjectLocalCache(_cache);
			_teamLogic = new BotTeamLogic(bot);
			_asyncProcessor = new BotAsyncProcessor(); _asyncProcessor.Initialize(bot, _cache);
			_threatEscalationMonitor = new BotThreatEscalationMonitor(); _threatEscalationMonitor.Initialize(bot);
			_injury = _cache.InjurySystem;
			_deadBodyScanner = _cache.DeadBodyScanner;
			_lootScanner = _cache.LootScanner;
			_lootDecisionSystem = _cache.LootDecisionSystem;
			_suppression = _cache.Suppression;
			_panic = _cache.PanicHandler;
			_lastShotTracker = _cache.LastShotTracker;
			_groupComms = _cache.GroupComms;
			_fallbackHandler = _cache.Fallback;
			_squadPath = _cache.SquadPath;
			_pathing = _cache.Pathing;
			_doorInteraction = _cache.DoorInteraction;
			_tacticalMemory = _cache.TacticalMemory;
			_trackedVisibility = _cache.VisibilityTracker;

			_now = Time.time;
			_nextPerceptionTick = _now;
			_nextCombatTick = _now;
			_nextLogicTick = _now;

			BotBrainGuardian.Enforce(_player.gameObject);
			enabled = true;

			Logger.LogDebug("[BotBrain] ✅ Initialized for bot: " + (_player.Profile?.Info?.Nickname ?? "Unnamed"));
		}

		public void Tick(float deltaTime)
		{
			if (!enabled || _bot == null || _player == null || _bot.IsDead || _player.HealthController == null || !_player.HealthController.IsAlive)
				return;

			_now = Time.time;

			SafeTick(_movement, m => m.Tick(deltaTime), "Movement", true);
			SafeTick(_pose, p => p.Tick(_now), "Pose");
			SafeTick(_look, l => l.Tick(deltaTime), "Look");
			SafeTick(_jump, j => j.Tick(deltaTime), "Jump");
			SafeTick(_corner, c => c.Tick(_now), "CornerScanner");
			SafeTick(_tilt, t => t.ManualUpdate(), "Tilt");
			SafeTick(_groupBehavior, g => g.Tick(deltaTime), "GroupBehavior");

			if (_now >= _nextPerceptionTick)
			{
				SafeTick(_vision, v => v.Tick(_now), "Vision");
				SafeTick(_hearing, h => h.Tick(_now), "Hearing");
				SafeTick(_perception, p => p.Tick(_now), "Perception");
				_nextPerceptionTick = _now + PerceptionTickRate;
			}
			if (_now >= _nextCombatTick)
			{
				SafeTick(_combat, c => c.Tick(_now), "Combat");
				SafeTick(_threatEscalationMonitor, e => e.Tick(_now), "Escalation");
				SafeTick(_flashReaction, f => f.Tick(_now), "FlashReaction");
				SafeTick(_flashDetector, f => f.Tick(_now), "FlashDetector");
				SafeTick(_groupSync, g => g.Tick(_now), "GroupSync");
				SafeTick(_teamLogic, t => t.CoordinateMovement(), "TeamLogic");
				_nextCombatTick = _now + CombatTickRate;
			}
			if (_now >= _nextLogicTick)
			{
				SafeTick(_mission, m => m.Tick(_now), "Mission");
				SafeTick(_hearingDamage, h => h.Tick(deltaTime), "HearingDamage");
				SafeTick(_tactical, t => t.Tick(), "Tactical");
				SafeTick(_injury, i => i.Tick(_now), "InjurySystem");
				SafeTick(_lootScanner, l => l.Tick(deltaTime), "LootScanner");
				SafeTick(_lootDecisionSystem, d => d.Tick(_now), "LootDecisionSystem");
				SafeTick(_deadBodyScanner, d => d.Tick(_now), "DeadBodyScanner");
				SafeTick(_asyncProcessor, a => a.Tick(_now), "AsyncProcessor");
				SafeTick(_doorInteraction, d => d.Tick(_now), "DoorInteraction");
				SafeTick(_squadPath, s => s.Tick(_now), "SquadPath");
				SafeTick(_pathing, p => p.Tick(_now), "Pathing");
				SafeTick(_tacticalMemory, t => t.Tick(_now), "TacticalMemory");
				_nextLogicTick = _now + LogicTickRate;
			}

			if (_combat != null && _combat.IsInCombatState() && _fallbackHandler?.IsActive() == true)
			{
				SafeTick(_fallbackHandler, f => f.Tick(deltaTime, _now, null), "FallbackHandler");
			}
		}

		private static void SafeTick<T>(T obj, Action<T> tick, string label, bool warn = false) where T : class
		{
			try
			{
				if (obj != null) tick(obj);
				else if (warn) Logger.LogWarning($"[BotBrain] {label} subsystem missing.");
			}
			catch (Exception ex)
			{
				Logger.LogWarning($"[BotBrain] {label} Tick failed: {ex}");
			}
		}
	}
}
