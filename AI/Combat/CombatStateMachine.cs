// <auto-generated>
//   AI-Refactored: CombatStateMachine.cs (Beyond Diamond, BotMovementHelper-Only Edition, June 2025)
//   All state, fallback, and patrol logic uses ONLY BotMovementHelper and FallbackHandler.
//   No direct use of BotOwner.Mover, NavMeshAgent, or any position/destination assignment.
//   Squad-safe, error-guarded, helper-pooled, ticked only by BotBrain. Fully SPT/FIKA/vanilla compatible.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using AIRefactored.AI.Combat.States;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// State machine for all bot combat, fallback, engage, investigate, and patrol logic.
    /// All movement is strictly routed through BotMovementHelper/FallbackHandler; no direct mover or nav calls.
    /// Squad-aware, helper-pooled, robust, multiplayer/headless safe, and max realism.
    /// </summary>
    public sealed class CombatStateMachine
    {
        #region Constants

        private const float MinTransitionDelay = 0.4f;
        private const float PatrolMinDuration = 1.25f;
        private const float PatrolCooldown = 12.0f;
        private const float ReentryCooldown = 3.0f;

        #endregion

        #region Fields

        private BotComponentCache _cache;
        private BotOwner _bot;

        private AttackHandler _attack;
        private EngageHandler _engage;
        private FallbackHandler _fallback;
        private InvestigateHandler _investigate;
        private PatrolHandler _patrol;
        private EchoCoordinator _echo;

        private Vector3 _lastKnownEnemyPos;
        private bool _hasKnownEnemy;
        private float _lastStateChangeTime;
        private bool _initialized;

        #endregion

        #region Properties

        public Vector3 LastKnownEnemyPos => _lastKnownEnemyPos;
        public float LastStateChangeTime => _lastStateChangeTime;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache componentCache)
        {
            if (componentCache?.Bot == null)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Initialization failed: null references.");
                _initialized = false;
                return;
            }

            _cache = componentCache;
            _bot = componentCache.Bot;

            _fallback = componentCache.Fallback ?? new FallbackHandler(componentCache);
            _patrol = new PatrolHandler(componentCache, PatrolMinDuration, PatrolCooldown);
            _investigate = new InvestigateHandler(componentCache);
            _engage = new EngageHandler(componentCache);
            _attack = new AttackHandler(componentCache);
            _echo = new EchoCoordinator(componentCache);

            _lastKnownEnemyPos = Vector3.zero;
            _hasKnownEnemy = false;
            _lastStateChangeTime = 0f;
            _initialized = true;
        }

        #endregion

        #region Public API

        public bool IsInCombatState()
        {
            try
            {
                return _initialized &&
                    (_fallback?.IsActive() == true ||
                     _engage?.IsEngaging() == true ||
                     _investigate?.IsInvestigating() == true ||
                     _cache?.ThreatSelector?.CurrentTarget != null);
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError("[CombatStateMachine] Exception in IsInCombatState: " + ex);
                return false;
            }
        }

        public void NotifyDamaged()
        {
            if (!_initialized || _fallback == null) return;
            float now = Time.time;
            if (NeedsFallbackNow(now))
            {
                AssignFallbackIfNeeded(now);
                TrySay(EPhraseTrigger.OnBeingHurt);
                _lastStateChangeTime = now;
            }
        }

        public void NotifyEchoInvestigate()
        {
            if (!_initialized || _investigate == null) return;
            float now = Time.time;
            if (_investigate.ShallUseNow(now, _lastStateChangeTime))
            {
                _lastStateChangeTime = now;
                TrySay(EPhraseTrigger.Cooperation);
            }
        }

        /// <summary>
        /// Ticked by BotBrain only. Handles all state transitions, movement, fallback, and attack logic.
        /// </summary>
        public void Tick(float now)
        {
            if (!_initialized || _bot == null || _bot.IsDead || !EFTPlayerUtil.IsValid(_bot.GetPlayer)) return;

            if (now - _lastStateChangeTime < MinTransitionDelay)
                return;

            if (TryReenterCombatState(now))
            {
                _lastStateChangeTime = now;
                return;
            }

            if (ShouldTriggerSuppressedFallback(now))
            {
                AssignFallbackIfNeeded(now);
                TrySay(EPhraseTrigger.OnBeingHurt);
                _echo?.EchoFallbackToSquad(_fallback.GetFallbackPosition());
                _lastStateChangeTime = now;
                return;
            }

            if (NeedsFallbackNow(now))
            {
                AssignFallbackIfNeeded(now);
                // Fallback movement is always handled by FallbackHandler (which uses BotMovementHelper internally)
                _fallback.Tick(0f, now, SetLastStateChangeTime);
                return;
            }

            Player enemy = _cache?.ThreatSelector?.CurrentTarget;
            if (EFTPlayerUtil.IsValid(enemy))
            {
                _lastKnownEnemyPos = EFTPlayerUtil.GetPosition(enemy);
                _hasKnownEnemy = true;

                if (!string.IsNullOrEmpty(enemy.ProfileId))
                    _cache?.TacticalMemory?.RecordEnemyPosition(_lastKnownEnemyPos, "Combat", enemy.ProfileId);

                if (_bot.Mover != null && !_bot.Mover.Sprinting)
                    _bot.Sprint(true);

                _echo?.EchoSpottedEnemyToSquad(_lastKnownEnemyPos);
            }

            if (_engage?.ShallUseNow() == true)
            {
                if (_engage.CanAttack())
                    _attack?.Tick(now);
                else
                    _engage.Tick();

                _lastStateChangeTime = now;
                return;
            }

            if (_investigate?.ShallUseNow(now, _lastStateChangeTime) == true)
            {
                Vector3 target = _investigate.GetInvestigateTarget(_hasKnownEnemy ? _lastKnownEnemyPos : Vector3.zero);
                if (target != Vector3.zero)
                {
                    _investigate.Investigate(target);
                    _lastStateChangeTime = now;
                }
                return;
            }

            // Patrol always uses SmoothMoveToSafe and never direct move.
            _patrol?.Tick(now);
        }

        /// <summary>
        /// Triggers a fallback retreat for this bot to the specified position (helper-only movement).
        /// </summary>
        public void TriggerFallback(Vector3 fallbackPos, float now)
        {
            if (!_initialized || _fallback == null) return;
            _fallback.SetFallbackTarget(fallbackPos, now);
            TrySay(EPhraseTrigger.OnLostVisual);
            _lastStateChangeTime = now;
        }

        /// <summary>
        /// Tries to set the stance/pose from nearby cover (helper only, error-guarded).
        /// </summary>
        public void TrySetStanceFromNearbyCover(Vector3 pos)
        {
            try { _cache?.PoseController?.TrySetStanceFromNearbyCover(pos); }
            catch (Exception ex) { Plugin.LoggerInstance.LogError("[CombatStateMachine] TrySetStanceFromNearbyCover: " + ex); }
        }

        #endregion

        #region Internal Logic

        private bool NeedsFallbackNow(float now) => _fallback != null && _fallback.IsActive();

        /// <summary>
        /// Assigns fallback path/target using FallbackHandler and BotMovementHelper (never direct move).
        /// </summary>
        private void AssignFallbackIfNeeded(float now)
        {
            if (_fallback == null || _fallback.IsActive())
                return;

            Vector3 dir = _bot.LookDirection.sqrMagnitude > 0.01f ? -_bot.LookDirection.normalized : Vector3.back;
            Vector3 fallback = !BotNavHelper.TryGetSafeTarget(_bot, out var safe) || !IsVectorValid(safe)
                ? _bot.Position + dir * 5f
                : safe;

            if (fallback.y < -2.5f || !IsVectorValid(fallback)) fallback = _bot.Position;

            var path = TempListPool.Rent<Vector3>();
            path.Clear(); path.Add(_bot.Position); path.Add(fallback);

            // All movement is handled via FallbackHandler (which uses BotMovementHelper).
            _fallback.SetFallbackPath(path, now);
            _fallback.SetFallbackTarget(fallback, now);
            TrySetStanceFromNearbyCover(fallback);

            TempListPool.Return(path);
        }

        private bool ShouldTriggerSuppressedFallback(float now)
        {
            if (_cache?.PanicHandler == null || _fallback == null) return false;
            float c = _cache.PanicHandler.GetComposureLevel();
            float delay = Mathf.Lerp(0.75f, 1.5f, 1f - c);
            return _cache.PanicHandler.ShouldTriggerSuppressedFallback(_fallback, now, _lastStateChangeTime, delay);
        }

        /// <summary>
        /// Allows immediate reentry into combat if enemy or squad conditions met (no direct move/teleport).
        /// </summary>
        private bool TryReenterCombatState(float now)
        {
            if (_fallback == null || !_fallback.IsActive()) return false;

            if (_cache?.ThreatSelector?.CurrentTarget != null)
            {
                _fallback.Cancel();
                TrySay(EPhraseTrigger.OnEnemyConversation);
                return true;
            }

            if (_cache?.GroupSync?.IsSquadReady() == true)
            {
                Vector3 self = _bot.Position;
                var squad = _cache.GroupSync.GetTeammates();
                for (int i = 0; i < squad.Count; i++)
                {
                    var mate = squad[i];
                    if (mate != null && !mate.IsDead && mate != _bot && Vector3.Distance(mate.Position, self) < 12f)
                    {
                        _fallback.Cancel();
                        TrySay(EPhraseTrigger.Cooperation);
                        return true;
                    }
                }
            }

            if (now - _lastStateChangeTime > ReentryCooldown)
            {
                _fallback.Cancel();
                TrySay(EPhraseTrigger.Ready);
                return true;
            }

            return false;
        }

        private void SetLastStateChangeTime(CombatState _, float time) => _lastStateChangeTime = time;

        private void TrySay(EPhraseTrigger phrase)
        {
            try { _bot?.BotTalk?.TrySay(phrase); } catch { }
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero && v.y > -2.5f;
        }

        #endregion
    }
}
