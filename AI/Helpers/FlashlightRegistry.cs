// <auto-generated>
//   AI-Refactored: FlashlightRegistry.cs (Beyond Diamond, Helper-Only Positional Queries)
//   All bot/head positional queries must use only EFTPlayerUtil or approved AIRefactored helpers.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Tracks and exposes active tactical flashlights in the scene.
    /// Used by AI perception systems for flashblindness, evasion, and visual panic triggers.
    /// Bulletproof: errors are local and never break the bot, fallback, or system logic.
    /// </summary>
    public static class FlashlightRegistry
    {
        #region Constants

        private const float AngleThreshold = 60f;
        private const float ExposureConeAngle = 35f;
        private const float EyeRayBias = 0.22f;
        private const float IntensityThreshold = 1.5f;
        private const float MaxExposureDistance = 28f;

        #endregion

        #region Static State

        private static readonly List<Light> ActiveLights = new List<Light>(32);
        private static readonly List<Vector3> LastKnownFlashPositions = new List<Vector3>(32);

        #endregion

        #region Public API

        public static IEnumerable<Light> GetActiveFlashlights()
        {
            ActiveLights.Clear();
            LastKnownFlashPositions.Clear();

            try
            {
                Light[] lights = UnityEngine.Object.FindObjectsOfType<Light>();
                for (int i = 0; i < lights.Length; i++)
                {
                    Light light = lights[i];
                    if (IsValidTacticalLight(light))
                    {
                        Transform t = light.transform;
                        if (t != null)
                        {
                            ActiveLights.Add(light);
                            LastKnownFlashPositions.Add(t.position);
                        }
                    }
                }
            }
            catch { }

            return ActiveLights;
        }

        public static IReadOnlyList<Vector3> GetLastKnownFlashlightPositions()
        {
            return LastKnownFlashPositions;
        }

        public static bool IsExposingBot(Player player, out Light blindingLight, float customMaxDist = MaxExposureDistance)
        {
            blindingLight = null;
            if (!EFTPlayerUtil.IsValid(player))
                return false;

            try
            {
                Vector3 botPos = EFTPlayerUtil.GetPosition(player);
                Vector3 eyePos = botPos + (Vector3.up * EyeRayBias);

                for (int i = 0; i < ActiveLights.Count; i++)
                {
                    Light light = ActiveLights[i];
                    if (!IsValidTacticalLight(light))
                        continue;

                    Transform lightTf = light.transform;
                    if (lightTf == null)
                        continue;

                    Vector3 toBot = eyePos - lightTf.position;
                    float dist = toBot.magnitude;
                    if (dist > customMaxDist)
                        continue;

                    float angle = Vector3.Angle(lightTf.forward, toBot);
                    if (angle > ExposureConeAngle)
                        continue;

                    Vector3 origin = lightTf.position;
                    Vector3 dir = toBot.normalized;

                    try
                    {
                        if (Physics.Raycast(origin, dir, out RaycastHit hit, dist + 0.1f, LayerMaskClass.HighPolyWithTerrainMaskAI))
                        {
                            Transform pTransform = player.Transform?.Original;
                            if (pTransform != null &&
                                (hit.transform == pTransform || (hit.collider != null && hit.collider.gameObject == pTransform.gameObject)))
                            {
                                blindingLight = light;
                                return true;
                            }
                        }
                        else if (angle < (ExposureConeAngle * 0.5f) && dist < 4.5f)
                        {
                            blindingLight = light;
                            return true;
                        }
                    }
                    catch { }
                }
            }
            catch { }

            return false;
        }

        public static bool IsFlickeringFlashlightActive()
        {
            return false;
        }

        #endregion

        #region Internal

        private static bool IsValidTacticalLight(Light light)
        {
            try
            {
                return light != null &&
                       light.enabled &&
                       light.type == LightType.Spot &&
                       light.intensity >= IntensityThreshold &&
                       light.spotAngle <= AngleThreshold &&
                       light.gameObject.activeInHierarchy;
            }
            catch
            {
                return false;
            }
        }

        #endregion
    }
}
