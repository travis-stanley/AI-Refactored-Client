// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System.Collections.Generic;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using Unity.AI.Navigation;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Caches NavMesh paths and fallback scoring for individual bots.
    /// Optimizes retreat and navigation behaviors with smart path reuse and avoidance heuristics.
    /// </summary>
    public sealed class BotOwnerPathfindingCache
    {
        #region Constants

        private const float BlockCheckHeight = 1.2f;
        private const float BlockCheckMargin = 0.5f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly Dictionary<string, float> _coverWeights = new Dictionary<string, float>(64);
        private readonly Dictionary<string, List<Vector3>> _fallbackCache = new Dictionary<string, List<Vector3>>(64);
        private readonly Dictionary<string, List<Vector3>> _pathCache = new Dictionary<string, List<Vector3>>(64);

        private BotTacticalMemory _tacticalMemory;

        #endregion

        #region Public API

        public void BroadcastRetreat(BotOwner bot, Vector3 point)
        {
            if (!IsAIBot(bot) || bot.BotsGroup == null)
            {
                return;
            }

            string map = GameWorldHandler.TryGetValidMapName();
            if (map.Length > 0)
            {
                BotMemoryStore.AddDangerZone(map, point, DangerTriggerType.Panic, 5f);
            }
        }

        public void Clear()
        {
            _pathCache.Clear();
            _fallbackCache.Clear();
        }

        public float GetCoverWeight(string mapId, Vector3 pos)
        {
            string key = mapId + "_" + RoundVector3ToKey(pos);
            return _coverWeights.TryGetValue(key, out float value) ? value : 1f;
        }

        public void RegisterCoverNode(string mapId, Vector3 pos, float score)
        {
            string key = mapId + "_" + RoundVector3ToKey(pos);
            if (!_coverWeights.ContainsKey(key))
            {
                _coverWeights[key] = Mathf.Clamp(score, 0.1f, 10f);
            }
        }

        public void SetTacticalMemory(BotTacticalMemory memory)
        {
            _tacticalMemory = memory;
        }

        public List<Vector3> GetOptimizedPath(BotOwner bot, Vector3 destination)
        {
            if (!IsAIBot(bot))
            {
                var direct = TempListPool.Rent<Vector3>();
                direct.Add(destination);
                return direct;
            }

            string id = bot.Profile?.Id;
            if (string.IsNullOrEmpty(id))
            {
                var fallback = TempListPool.Rent<Vector3>();
                fallback.Add(destination);
                return fallback;
            }

            string key = id + "_" + destination.ToString("F2");
            if (_pathCache.TryGetValue(key, out List<Vector3> cached) && !IsPathBlocked(cached))
            {
                return cached;
            }

            List<Vector3> path = BuildNavPath(bot.Position, destination);
            _pathCache[key] = path;
            return path;
        }

        public bool TryGetValidPath(BotOwner bot, Vector3 destination, out List<Vector3> path)
        {
            path = GetOptimizedPath(bot, destination);
            return path.Count >= 2 && !IsPathBlocked(path);
        }

        public List<Vector3> GetFallbackPath(BotOwner bot, Vector3 threatDirection)
        {
            string id = bot.Profile?.Id;
            if (string.IsNullOrEmpty(id))
            {
                return TempListPool.Rent<Vector3>();
            }

            Vector3 origin = bot.Position;
            Vector3 fallbackTarget = origin - threatDirection.normalized * 8f;
            string key = id + "_fb_" + HashVecDir(origin, threatDirection);

            if (_fallbackCache.TryGetValue(key, out List<Vector3> cached) && cached.Count > 1 && !IsPathBlocked(cached))
            {
                return cached;
            }

            List<Vector3> candidates = NavPointRegistry.QueryNearby(origin, 25f, pos => NavPointRegistry.GetTag(pos) == "fallback");

            try
            {
                for (int i = 0; i < candidates.Count; i++)
                {
                    var single = TempListPool.Rent<Vector3>();
                    try
                    {
                        single.Add(candidates[i]);
                        if (IsPathInClearedZone(single))
                        {
                            continue;
                        }

                        List<Vector3> navPath = BuildNavPath(origin, candidates[i]);
                        if (navPath.Count > 1 && !IsPathBlocked(navPath))
                        {
                            _fallbackCache[key] = navPath;
                            return navPath;
                        }
                    }
                    finally
                    {
                        TempListPool.Return(single);
                    }
                }
            }
            finally
            {
                TempListPool.Return(candidates);
            }

            List<Vector3> fallback = BuildNavPath(origin, fallbackTarget);
            if (fallback.Count > 1 && !IsPathBlocked(fallback) && !IsPathInClearedZone(fallback))
            {
                _fallbackCache[key] = fallback;
                return fallback;
            }

            return TempListPool.Rent<Vector3>();
        }

        #endregion

        #region Internal Helpers

        private static bool IsAIBot(BotOwner bot)
        {
            Player player = bot?.GetPlayer;
            return player != null && player.IsAI && !player.IsYourPlayer;
        }

        private static string RoundVector3ToKey(Vector3 v)
        {
            return v.x.ToString("F1") + "_" + v.y.ToString("F1") + "_" + v.z.ToString("F1");
        }

        private static string HashVecDir(Vector3 pos, Vector3 dir)
        {
            Vector3 hashVec = pos + dir.normalized * 2f;
            return hashVec.x.ToString("F1") + "_" + hashVec.y.ToString("F1") + "_" + hashVec.z.ToString("F1");
        }

        private List<Vector3> BuildNavPath(Vector3 origin, Vector3 target)
        {
            NavMeshPath navPath = TempNavMeshPathPool.Rent();
            bool valid = NavMesh.CalculatePath(origin, target, NavMesh.AllAreas, navPath);

            if (valid && navPath.status == NavMeshPathStatus.PathComplete)
            {
                List<Vector3> result = TempListPool.Rent<Vector3>();
                result.AddRange(navPath.corners);
                TempNavMeshPathPool.Return(navPath);
                return result;
            }

            List<Vector3> fallback = TempListPool.Rent<Vector3>();
            fallback.Add(origin);
            fallback.Add(target);
            TempNavMeshPathPool.Return(navPath);
            return fallback;
        }

        private bool IsPathBlocked(List<Vector3> path)
        {
            if (path.Count < 2)
            {
                return false;
            }

            Vector3 origin = path[0] + Vector3.up * BlockCheckHeight;
            Vector3 target = path[1];
            Vector3 direction = (target - path[0]).normalized;
            float distance = Vector3.Distance(path[0], target) + BlockCheckMargin;

            RaycastHit hit;
            if (Physics.Raycast(origin, direction, out hit, distance, AIRefactoredLayerMasks.DoorColliderMask))
            {
                if (AIRefactoredLayerMasks.IsDoorLayer(hit.collider.gameObject.layer))
                {
                    var navPath = TempNavMeshPathPool.Rent();
                    bool blocked = !NavMesh.CalculatePath(origin, target, NavMesh.AllAreas, navPath) || navPath.status != NavMeshPathStatus.PathComplete;
                    TempNavMeshPathPool.Return(navPath);
                    return blocked;
                }
            }

            return false;
        }

        private bool IsPathInClearedZone(List<Vector3> path)
        {
            if (_tacticalMemory == null || path.Count == 0)
            {
                return false;
            }

            for (int i = 0; i < path.Count; i++)
            {
                if (_tacticalMemory.WasRecentlyCleared(path[i]))
                {
                    return true;
                }
            }

            return false;
        }

        #endregion
    }
}
