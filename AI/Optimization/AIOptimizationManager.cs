// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
//   Failures in optimization routines must never break other AI systems or the bot itself.
//   Realism Pass: Micro-randomized escalation, personality-driven adjustment (from AIRefactoredBotOwner/BotRegistry), and strict safety.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Manages runtime optimization routines for AI bots.
    /// Provides centralized access to performance tuning, reset, and escalation routines.
    /// Designed to improve tactical behavior and reduce simulation overhead.
    /// Only runs on the authoritative host (headless, local-host, or client-host).
    /// All failures are locally isolated; no exceptions or errors propagate beyond the affected bot.
    /// </summary>
    public static class AIOptimizationManager
    {
        #region Constants

        private const float EscalationCooldownTime = 10f;
        private const float EscalationRandomVariance = 0.09f;

        #endregion

        #region Fields

        private static readonly BotAIOptimization Optimizer = new BotAIOptimization();
        private static readonly Dictionary<int, bool> BotOptimizationState = new Dictionary<int, bool>(128);
        private static readonly Dictionary<int, float> LastEscalationTimes = new Dictionary<int, float>(128);
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Applies optimization logic to a bot if eligible.
        /// Fully bulletproof: if optimization fails, only disables for that bot, never affects others.
        /// </summary>
        /// <param name="bot">BotOwner to optimize.</param>
        public static void Apply(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                if (BotOptimizationState.TryGetValue(id, out bool alreadyOptimized) && alreadyOptimized)
                    return;

                try
                {
                    Optimizer.Optimize(bot);
                    BotOptimizationState[id] = true;
                }
                catch (Exception ex)
                {
                    BotOptimizationState[id] = false;
                    Logger.LogError("[AIOptimizationManager] Optimization failed for bot " + GetName(bot) + ": " + ex);
                }
            }
            catch (Exception outer)
            {
                Logger.LogError("[AIOptimizationManager] Apply() fatal error: " + outer);
            }
        }

        /// <summary>
        /// Resets a bot's optimizations if previously applied.
        /// Isolated: failures affect only this bot.
        /// </summary>
        /// <param name="bot">BotOwner to reset.</param>
        public static void Reset(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                if (!BotOptimizationState.TryGetValue(id, out bool wasOptimized) || !wasOptimized)
                    return;

                try
                {
                    Optimizer.ResetOptimization(bot);
                    BotOptimizationState[id] = false;
                }
                catch (Exception ex)
                {
                    Logger.LogError("[AIOptimizationManager] Reset failed for bot " + GetName(bot) + ": " + ex);
                    BotOptimizationState[id] = false;
                }
            }
            catch (Exception outer)
            {
                Logger.LogError("[AIOptimizationManager] Reset() fatal error: " + outer);
            }
        }

        /// <summary>
        /// Escalates bot threat perception and responsiveness, subject to cooldown.
        /// Failures are locally contained and logged.
        /// </summary>
        /// <param name="bot">BotOwner to escalate.</param>
        public static void TriggerEscalation(BotOwner bot)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(bot))
                    return;

                int id = bot.GetInstanceID();
                float now = Time.time;

                if (LastEscalationTimes.TryGetValue(id, out float lastTime) && (now - lastTime) < EscalationCooldownTime)
                    return;

                BotGlobalsMindSettings mind = null;
                try
                {
                    mind = GetMindSettings(bot);
                }
                catch (Exception ex)
                {
                    Logger.LogError("[AIOptimizationManager] Escalation aborted (mind settings fetch failed) for bot " + GetName(bot) + ": " + ex);
                    return;
                }

                if (mind == null)
                {
                    Logger.LogWarning("[AIOptimizationManager] Escalation aborted: missing mind settings for bot: " + GetName(bot));
                    return;
                }

                try
                {
                    // Personality profile: cache then registry fallback (using string Profile.Id)
                    float aggression = 0.5f;
                    float caution = 0.5f;
                    BotComponentCache cache = null;

                    string profileId = bot?.Profile?.Id;
                    if (!string.IsNullOrEmpty(profileId))
                        BotComponentCacheRegistry.TryGet(profileId, out cache);

                    var profile = cache?.AIRefactoredBotOwner?.PersonalityProfile ?? (!string.IsNullOrEmpty(profileId) ? BotRegistry.Get(profileId) : null);

                    if (profile != null)
                    {
                        aggression = Mathf.Clamp01(profile.AggressionLevel);
                        caution = Mathf.Clamp01(profile.Caution);
                    }

                    float variance = 1f + UnityEngine.Random.Range(-EscalationRandomVariance, EscalationRandomVariance);

                    // Threat perception (distance)
                    mind.DIST_TO_FOUND_SQRT = Mathf.Clamp(mind.DIST_TO_FOUND_SQRT * (1.25f + aggression * 0.1f) * variance, 180f, 800f);

                    // Responsiveness (angle)
                    mind.ENEMY_LOOK_AT_ME_ANG = Mathf.Clamp(mind.ENEMY_LOOK_AT_ME_ANG * (0.7f - caution * 0.07f) * variance, 5f, 60f);

                    // Chance to run on damage
                    mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 = Mathf.Clamp(
                        mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100 + 20f + aggression * 10f - caution * 5f,
                        0f, 100f);

                    LastEscalationTimes[id] = now;
                }
                catch (Exception ex)
                {
                    Logger.LogError("[AIOptimizationManager] Escalation adjustment failed for bot " + GetName(bot) + ": " + ex);
                }
            }
            catch (Exception outer)
            {
                Logger.LogError("[AIOptimizationManager] TriggerEscalation() fatal error: " + outer);
            }
        }

        #endregion

        #region Internal Helpers

        private static bool IsValid(BotOwner bot)
        {
            return bot != null &&
                   bot.GetPlayer != null &&
                   bot.GetPlayer.IsAI &&
                   !bot.IsDead;
        }

        private static string GetName(BotOwner bot)
        {
            try
            {
                return bot?.Profile?.Info?.Nickname ?? "Unknown";
            }
            catch
            {
                return "Unknown";
            }
        }

        private static BotGlobalsMindSettings GetMindSettings(BotOwner bot)
        {
            if (bot == null || bot.Settings == null || bot.Settings.FileSettings == null)
                return null;
            return bot.Settings.FileSettings.Mind;
        }

        #endregion
    }
}
