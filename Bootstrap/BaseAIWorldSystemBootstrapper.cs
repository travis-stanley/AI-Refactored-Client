// <auto-generated>
//   AI-Refactored: BaseAIWorldSystemBootstrapper.cs (Beyond Diamond – Isolation & Bulletproof Fallback Edition)
//   SYSTEMATICALLY MANAGED. All failures are strictly localized; no cascade, no disables outside local scope.
//   Compliant with: Ultimate Realism, Headless/Client Parity, Error Isolation, and Robust Cleanup standards.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Core
{
    using System;
    using AIRefactored.Bootstrap;
    using AIRefactored.Core;
    using BepInEx.Logging;

    /// <summary>
    /// Abstract base for all world-level AIRefactored systems.
    /// Provides hard isolation, bulletproof lifecycle, and local failover—never cascades, never disables global AI.
    /// </summary>
    public abstract class BaseAIWorldSystemBootstrapper : IAIWorldSystemBootstrapper
    {
        #region Internal State

        private volatile bool _hasFailed;

        #endregion

        #region Lifecycle

        /// <summary>
        /// Initializes the system at its required phase. All exceptions are strictly localized.
        /// </summary>
        public virtual void Initialize()
        {
            if (_hasFailed)
                return;

            try
            {
                OnInitialize();
            }
            catch (Exception ex)
            {
                _hasFailed = true;
                Plugin.LoggerInstance?.LogError("[BaseAIWorldSystem] Initialize error in " + GetType().Name + ": " + ex);
                OnFailover();
            }
        }

        /// <summary>
        /// Override with system-specific initialization logic.
        /// </summary>
        protected virtual void OnInitialize() { }

        /// <summary>
        /// Ticked by WorldBootstrapper or controller if ready. All exceptions are contained.
        /// </summary>
        /// <param name="deltaTime">Elapsed time since last tick.</param>
        public virtual void Tick(float deltaTime)
        {
            if (_hasFailed)
                return;

            try
            {
                OnTick(deltaTime);
            }
            catch (Exception ex)
            {
                _hasFailed = true;
                Plugin.LoggerInstance?.LogError("[BaseAIWorldSystem] Tick error in " + GetType().Name + ": " + ex);
                OnFailover();
            }
        }

        /// <summary>
        /// Override with per-frame/tick system logic.
        /// </summary>
        /// <param name="deltaTime">Elapsed time since last tick.</param>
        protected virtual void OnTick(float deltaTime) { }

        /// <summary>
        /// Handles teardown/cleanup at raid end. All exceptions are contained and do not propagate.
        /// </summary>
        public virtual void OnRaidEnd()
        {
            if (_hasFailed)
                return;

            try
            {
                Cleanup();
            }
            catch (Exception ex)
            {
                _hasFailed = true;
                Plugin.LoggerInstance?.LogError("[BaseAIWorldSystem] OnRaidEnd error in " + GetType().Name + ": " + ex);
                OnFailover();
            }
        }

        /// <summary>
        /// Override for per-system teardown and memory cleanup logic.
        /// </summary>
        protected virtual void Cleanup() { }

        /// <summary>
        /// Returns true if the system is ready and not failed. Ticked only if true.
        /// </summary>
        public virtual bool IsReady()
        {
            return !_hasFailed && OnIsReady();
        }

        /// <summary>
        /// Override for custom gating logic (e.g. dependency on other systems or world state).
        /// </summary>
        protected virtual bool OnIsReady() => true;

        /// <summary>
        /// Phase required for world bootstrapper to initialize this system. Override if different phase is needed.
        /// </summary>
        public virtual WorldPhase RequiredPhase() => WorldPhase.PostInit;

        /// <summary>
        /// Called on fatal/local error; disables only this system. Never escalate, never affect global mod state.
        /// </summary>
        protected virtual void OnFailover()
        {
            // Override in subclass to perform local fallback/disable/cleanup.
            // Do NOT escalate. All failures are strictly local to this system.
        }

        /// <summary>
        /// Returns true if this system is permanently failed and will never tick again.
        /// </summary>
        public bool IsFailed => _hasFailed;

        #endregion
    }
}
