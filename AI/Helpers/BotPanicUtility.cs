// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All panic propagation is bulletproof, organic, and never blocks the group.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Utility class for resolving and triggering panic behavior in bots and squads.
    /// Used by flash, suppression, auditory, and damage systems to propagate fear.
    /// Bulletproof: all failures are local, no cascade or cross-bot error is possible.
    /// </summary>
    public static class BotPanicUtility
    {
        #region Public API

        /// <summary>
        /// Triggers panic on a single bot if valid and eligible.
        /// </summary>
        public static void Trigger(BotComponentCache cache)
        {
            try
            {
                if (IsEligible(cache))
                {
                    cache.PanicHandler.TriggerPanic();
                }
            }
            catch
            {
                // Never propagate error; skip only this bot
            }
        }

        /// <summary>
        /// Triggers panic across an entire squad or cache group,
        /// using staggered human-like delays for realism.
        /// All failures are local; one bot's error cannot affect the rest.
        /// </summary>
        public static void TriggerGroup(List<BotComponentCache> group)
        {
            if (group == null)
                return;

            for (int i = 0; i < group.Count; i++)
            {
                try
                {
                    var cache = group[i];
                    // Staggered group panic (simulate squadmate lag/hesitation)
                    if (IsEligible(cache))
                    {
                        float delay = 0.03f * i + GetPanicJitter(cache.Bot?.ProfileId, i);
                        TriggerDelayedPanic(cache, delay);
                    }
                }
                catch
                {
                    // Never break group iteration
                }
            }
        }

        /// <summary>
        /// Triggers panic in all bots within a radius of the given origin,
        /// using staggered delays for realism.
        /// All failures are local; each bot handled independently.
        /// </summary>
        public static void TriggerNearby(Vector3 origin, float radius)
        {
            if (radius <= 0f)
                return;

            float radiusSqr = radius * radius;
            int panicOrder = 0;

            foreach (BotComponentCache cache in BotCacheUtility.AllActiveBots())
            {
                try
                {
                    if (!IsEligible(cache))
                        continue;

                    Vector3 pos = cache.Bot.Position;
                    float dx = pos.x - origin.x;
                    float dy = pos.y - origin.y;
                    float dz = pos.z - origin.z;
                    float distSqr = (dx * dx) + (dy * dy) + (dz * dz);

                    if (distSqr <= radiusSqr)
                    {
                        float delay = 0.02f * panicOrder + GetPanicJitter(cache.Bot?.ProfileId, panicOrder);
                        TriggerDelayedPanic(cache, delay);
                        panicOrder++;
                    }
                }
                catch
                {
                    // Never break; continue other bots
                }
            }
        }

        /// <summary>
        /// Legacy alias for TryGetPanicComponent.
        /// </summary>
        public static bool TryGet(BotComponentCache cache, out BotPanicHandler panic)
        {
            return TryGetPanicComponent(cache, out panic);
        }

        /// <summary>
        /// Attempts to retrieve the panic handler from a bot’s component cache.
        /// </summary>
        public static bool TryGetPanicComponent(BotComponentCache cache, out BotPanicHandler panic)
        {
            if (cache != null && cache.PanicHandler != null)
            {
                panic = cache.PanicHandler;
                return true;
            }

            panic = null;
            return false;
        }

        #endregion

        #region Internal Helpers

        /// <summary>
        /// Returns true if cache and panic handler are present, bot is alive, and not already panicking.
        /// </summary>
        private static bool IsEligible(BotComponentCache cache)
        {
            return cache != null &&
                   cache.Bot != null &&
                   !cache.Bot.IsDead &&
                   cache.PanicHandler != null &&
                   !cache.PanicHandler.IsPanicking;
        }

        /// <summary>
        /// Deterministic per-bot, per-order jitter for panic delays.
        /// Prevents robotic, perfectly-synchronized reactions.
        /// </summary>
        private static float GetPanicJitter(string profileId, int order)
        {
            int hash = (profileId?.GetHashCode() ?? 0) ^ (order * 31) ^ unchecked((int)0xACD1423B);
            unchecked
            {
                hash = (int)((hash ^ (hash >> 15)) * 0x6B1F29);
                float frac = (hash & 0xFFF) / 4096f;
                return frac * 0.13f; // [0, ~0.13]
            }
        }

        /// <summary>
        /// Triggers panic on this bot after the given delay (in seconds), async/safe.
        /// </summary>
        private static void TriggerDelayedPanic(BotComponentCache cache, float delay)
        {
            if (cache == null)
                return;
            Task.Run(async () =>
            {
                try
                {
                    int ms = Mathf.Max(0, (int)(delay * 1000f));
                    if (ms > 0)
                        await Task.Delay(ms);
                    if (IsEligible(cache))
                        cache.PanicHandler.TriggerPanic();
                }
                catch
                {
                    // Never break async thread
                }
            });
        }

        #endregion
    }
}
