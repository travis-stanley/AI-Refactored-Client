// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All diagnostics and optimization routines are bulletproof and fully isolated.
//   Realism Pass: Fully null-guarded, robust, cooldown-aware, and strictly side-effect-free for live bots.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Logs and verifies runtime bot AI settings like reaction thresholds, run chance, and role assignment.
    /// Used during development to confirm bot configuration consistency and behavioral tuning.
    /// Only runs on the authoritative instance (headless, local-host, or client-host).
    /// All failures are strictly isolated to the affected bot.
    /// </summary>
    public sealed class BotAIOptimization
    {
        #region Constants

        private const float OptimizationLogCooldown = 5f;

        #endregion

        #region Fields

        private readonly Dictionary<string, bool> _optimizationApplied = new Dictionary<string, bool>(64, StringComparer.OrdinalIgnoreCase);
        private static readonly Dictionary<int, float> LastOptimizationLogs = new Dictionary<int, float>(64);
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public API

        /// <summary>
        /// Logs current optimization-relevant settings for the bot (once per bot ID).
        /// Hardened: failures only affect the current bot and are logged.
        /// </summary>
        /// <param name="botOwner">The bot owner instance to optimize and log.</param>
        public void Optimize(BotOwner botOwner)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(botOwner))
                    return;

                string profileId = "Unknown";
                try { profileId = botOwner?.Profile?.Id ?? "Unknown"; } catch { }

                if (_optimizationApplied.TryGetValue(profileId, out bool alreadyApplied) && alreadyApplied)
                {
                    if (!ShouldLogOptimization(botOwner))
                        return;
                    Logger.LogDebug("[BotAIOptimization] Optimization already applied for bot: " + profileId);
                    return;
                }

                try { LogCognition(botOwner); } catch (Exception ex) { Logger.LogError("[BotAIOptimization] LogCognition failed: " + ex); }
                try { LogMind(botOwner); } catch (Exception ex) { Logger.LogError("[BotAIOptimization] LogMind failed: " + ex); }
                try { LogRole(botOwner); } catch (Exception ex) { Logger.LogError("[BotAIOptimization] LogRole failed: " + ex); }

                _optimizationApplied[profileId] = true;
                Logger.LogDebug("[BotAIOptimization] Applied optimization for bot: " + profileId);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] Optimize() fatal error: " + ex);
            }
        }

        /// <summary>
        /// Allows re-logging this bot by clearing its logged flag.
        /// Fully isolated; errors are logged but cannot break the system.
        /// </summary>
        /// <param name="botOwner">The bot owner instance to reset.</param>
        public void ResetOptimization(BotOwner botOwner)
        {
            try
            {
                if (!GameWorldHandler.IsLocalHost() || !IsValid(botOwner))
                    return;

                string profileId = "Unknown";
                try { profileId = botOwner?.Profile?.Id ?? "Unknown"; } catch { }

                _optimizationApplied[profileId] = false;
                Logger.LogDebug("[BotAIOptimization] Reset optimization for bot: " + profileId);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] ResetOptimization() fatal error: " + ex);
            }
        }

        #endregion

        #region Private Helpers

        private static bool IsValid(BotOwner bot)
        {
            try
            {
                return bot != null &&
                       bot.GetPlayer != null &&
                       bot.GetPlayer.IsAI &&
                       !bot.IsDead &&
                       bot.Profile != null &&
                       bot.Settings != null &&
                       bot.Settings.FileSettings != null;
            }
            catch
            {
                return false;
            }
        }

        private static bool ShouldLogOptimization(BotOwner bot)
        {
            try
            {
                int id = bot != null ? bot.GetInstanceID() : 0;
                float now = Time.time;

                if (LastOptimizationLogs.TryGetValue(id, out float last) && now - last < OptimizationLogCooldown)
                    return false;

                LastOptimizationLogs[id] = now;
                return true;
            }
            catch
            {
                return true;
            }
        }

        private static void LogCognition(BotOwner bot)
        {
            try
            {
                string name = bot?.Profile?.Info?.Nickname ?? "Unknown";
                BotGlobalLookData look = bot?.Settings?.FileSettings?.Look;

                if (look == null)
                {
                    Logger.LogWarning("[BotDiagnostics][Cognition] " + name + " → No Look config found.");
                    return;
                }

                Logger.LogDebug("[BotDiagnostics][Cognition] " + name +
                                " → MAX_VISION_GRASS_METERS=" + look.MAX_VISION_GRASS_METERS.ToString("F1") +
                                ", ENEMY_LIGHT_ADD=" + look.ENEMY_LIGHT_ADD.ToString("F1"));
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] LogCognition exception: " + ex);
            }
        }

        private static void LogMind(BotOwner bot)
        {
            try
            {
                string name = bot?.Profile?.Info?.Nickname ?? "Unknown";
                BotGlobalsMindSettings mind = bot?.Settings?.FileSettings?.Mind;

                if (mind == null)
                {
                    Logger.LogWarning("[BotDiagnostics][Mind] " + name + " → No Mind config found.");
                    return;
                }

                Logger.LogDebug("[BotDiagnostics][Mind] " + name +
                                " → MIN_DAMAGE_SCARE=" + mind.MIN_DAMAGE_SCARE.ToString("F1") +
                                ", CHANCE_TO_RUN_CAUSE_DAMAGE_0_100=" + mind.CHANCE_TO_RUN_CAUSE_DAMAGE_0_100.ToString("F0") + "%");
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] LogMind exception: " + ex);
            }
        }

        private static void LogRole(BotOwner bot)
        {
            try
            {
                string name = bot?.Profile?.Info?.Nickname ?? "Unknown";
                WildSpawnType role = WildSpawnType.assault;
                try { role = bot?.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault; } catch { }
                Logger.LogDebug("[BotDiagnostics][Role] " + name + " → ProfileRole=" + role);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotAIOptimization] LogRole exception: " + ex);
            }
        }

        #endregion
    }
}
