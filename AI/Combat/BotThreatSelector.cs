// <auto-generated>
//   AI-Refactored: BotThreatSelector.cs (Max Realism Edition, May 2025)
//   Selects/prioritizes threats using live data, memory, personality, and squad logic.
//   Bulletproof: All failures locally isolated, no fallback AI, never disables, always multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Combat
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Selects and prioritizes enemy threats for a bot, factoring in memory, squad, and real-time data.
    /// All logic is null-guarded and headless/client safe. No disables, no fallback AI, no allocs on hot path.
    /// </summary>
    public sealed class BotThreatSelector
    {
        #region Constants

        private const float EvaluateCooldown = 0.31f;
        private const float MaxDistance = 120f;
        private const float SwitchCooldown = 2.2f;
        private const float SwitchThreshold = 10.2f;

        private const float SquadAssistBonus = 12.5f;
        private const float CloseDistanceBonus = 14f;
        private const float LineOfSightBonus = 19.7f;
        private const float VisibleRecentBonus = 8.6f;
        private const float SuppressionPenalty = 12.9f;
        private const float PanicPenalty = 20f;

        #endregion

        #region Fields

        private readonly BotComponentCache _cache;
        private readonly BotOwner _bot;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _logger;

        private float _nextEvalTime;
        private float _lastSwitchTime;
        private Player _target;

        #endregion

        #region Properties

        public Player CurrentTarget => _target;

        #endregion

        #region Constructor

        public BotThreatSelector(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null || cache.AIRefactoredBotOwner == null)
                throw new ArgumentException("[BotThreatSelector] Cache or owner null.");

            _cache = cache;
            _bot = cache.Bot;
            _profile = cache.AIRefactoredBotOwner.PersonalityProfile;
            _logger = Plugin.LoggerInstance;
        }

        #endregion

        #region Tick

        public void Tick(float time)
        {
            if (time < _nextEvalTime || _bot == null || _bot.IsDead)
                return;

            _nextEvalTime = time + EvaluateCooldown;

            List<Player> players = GameWorldHandler.GetAllAlivePlayers();
            if (players == null || players.Count == 0)
                return;

            Player best = null;
            float bestScore = float.MinValue;

            for (int i = 0; i < players.Count; i++)
            {
                Player candidate = players[i];
                if (!EFTPlayerUtil.IsValid(candidate) || !IsProperEnemy(_bot, candidate))
                    continue;

                float score = ScoreTarget(candidate, time);
                if (score > bestScore)
                {
                    best = candidate;
                    bestScore = score;
                }
            }

            if (best == null)
            {
                TryFallbackFromMemory(time);
                return;
            }

            if (_target == null)
            {
                SetTarget(best, time);
                return;
            }

            float currentScore = ScoreTarget(_target, time);
            float cooldown = SwitchCooldown * (1f - _profile.AggressionLevel);
            if (bestScore > currentScore + SwitchThreshold && time > _lastSwitchTime + cooldown)
            {
                SetTarget(best, time);
            }
        }

        #endregion

        #region Scoring

        private float ScoreTarget(Player candidate, float time)
        {
            Vector3 pos = EFTPlayerUtil.GetPosition(candidate);
            float dist = Vector3.Distance(_bot.Position, pos);
            if (dist > MaxDistance) return float.MinValue;

            float score = MaxDistance - dist;

            if (dist < 12f)
                score += CloseDistanceBonus;

            if (_bot.BotsGroup != null)
            {
                int count = _bot.BotsGroup.MembersCount;
                for (int i = 0; i < count; i++)
                {
                    BotOwner mate = _bot.BotsGroup.Member(i);
                    if (mate != null && mate != _bot && !mate.IsDead &&
                        mate.Memory?.GoalEnemy?.Person?.ProfileId == candidate.ProfileId)
                    {
                        score += SquadAssistBonus;
                    }
                }
            }

            EnemyInfo info = GetEnemyInfo(candidate);
            if (info != null && info.IsVisible)
            {
                score += LineOfSightBonus;
                if (time - info.PersonalLastSeenTime < 2.4f)
                    score += VisibleRecentBonus;
            }

            if (_cache.Suppression?.IsSuppressed() == true)
                score -= SuppressionPenalty;
            if (_cache.PanicHandler?.IsPanicking == true)
                score -= PanicPenalty;

            return score;
        }

        private EnemyInfo GetEnemyInfo(Player player)
        {
            if (_bot?.EnemiesController?.EnemyInfos == null || player == null)
                return null;

            foreach (var kv in _bot.EnemiesController.EnemyInfos)
            {
                if (kv.Key is Player enemy && enemy.ProfileId == player.ProfileId)
                    return kv.Value;
            }

            if (_bot.Memory?.GoalEnemy?.Person?.ProfileId == player.ProfileId)
                return _bot.Memory.GoalEnemy;

            return null;
        }

        #endregion

        #region Fallback Logic

        private void TryFallbackFromMemory(float time)
        {
            string id = _cache?.TacticalMemory?.GetMostRecentEnemyId();
            if (string.IsNullOrEmpty(id))
                return;

            Player fallback = EFTPlayerUtil.ResolvePlayerById(id);
            if (EFTPlayerUtil.IsValid(fallback) && IsProperEnemy(_bot, fallback))
                SetTarget(fallback, time);
        }

        private void SetTarget(Player player, float time)
        {
            _target = player;
            _lastSwitchTime = time;

            if (_cache.TacticalMemory != null)
                _cache.TacticalMemory.RecordEnemyPosition(EFTPlayerUtil.GetPosition(player), "Threat", player.ProfileId);

            if (_cache.Movement != null && !_bot.Mover.IsMoving)
            {
                if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 safePos) && IsVectorValid(safePos))
                    BotMovementHelper.SmoothMoveToSafe(_bot, safePos, slow: false, cohesion: 1f);
            }
        }

        public string GetTargetProfileId() => _target?.ProfileId ?? string.Empty;

        public void ResetTarget() => _target = null;

        #endregion

        #region Helpers

        private static bool IsProperEnemy(BotOwner self, Player candidate)
        {
            if (self == null || candidate == null || candidate.ProfileId == self.ProfileId)
                return false;

            EPlayerSide selfSide = self.GetPlayer?.Side ?? EPlayerSide.Savage;
            EPlayerSide otherSide = candidate.Side;

            if (selfSide != otherSide)
                return true;

            string selfGroup = self.GetPlayer?.Profile?.Info?.GroupId ?? "";
            string otherGroup = candidate.Profile?.Info?.GroupId ?? "";

            return selfGroup != otherGroup;
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) &&
                   Mathf.Abs(v.x) < 10000f && Mathf.Abs(v.y) < 10000f && Mathf.Abs(v.z) < 10000f;
        }

        #endregion
    }
}
