// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Helpers
{
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Movement;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Utility for scoring, checking, and tracking tactical cover positions.
    /// Supports memory cooldown, real cover posture analysis, and multiplayer-safe validation.
    /// </summary>
    public static class BotCoverHelper
    {
        #region Constants

        private const float MemoryDuration = 20f;
        private const float MaxValidDistanceSqr = 16f;

        #endregion

        #region Static Memory

        private static readonly Dictionary<string, float> CoverMemory = new Dictionary<string, float>(128);

        #endregion

        #region Cover Type Checks

        public static bool IsLowCover(CustomNavigationPoint point) => point != null && point.CoverLevel == CoverLevel.Sit;

        public static bool IsProneCover(CustomNavigationPoint point) => point != null && point.CoverLevel == CoverLevel.Lay;

        public static bool IsStandingCover(CustomNavigationPoint point) => point != null && point.CoverLevel == CoverLevel.Stay;

        public static bool IsLowCover(NavPointData point) => point.IsCover && point.ElevationBand == "Mid";

        public static bool IsProneCover(NavPointData point) => point.IsCover && point.ElevationBand == "Low";

        public static bool IsStandingCover(NavPointData point) => point.IsCover && point.ElevationBand == "High";

        #endregion

        #region Cover Memory Usage

        public static void MarkUsed(CustomNavigationPoint point)
        {
            if (point != null) CoverMemory[GetKey(point.Position)] = Time.time;
        }

        public static void MarkUsed(NavPointData point) => CoverMemory[GetKey(point.Position)] = Time.time;

        public static void MarkUsed(Vector3 position) => CoverMemory[GetKey(position)] = Time.time;

        public static bool WasRecentlyUsed(CustomNavigationPoint point)
        {
            if (point == null) return false;
            float last;
            return CoverMemory.TryGetValue(GetKey(point.Position), out last) && (Time.time - last) < MemoryDuration;
        }

        public static bool WasRecentlyUsed(NavPointData point)
        {
            float last;
            return CoverMemory.TryGetValue(GetKey(point.Position), out last) && (Time.time - last) < MemoryDuration;
        }

        public static bool WasRecentlyUsed(Vector3 position)
        {
            float last;
            return CoverMemory.TryGetValue(GetKey(position), out last) && (Time.time - last) < MemoryDuration;
        }

        #endregion

        #region Pose Application

        public static void TrySetStanceFromNearbyCover(BotComponentCache cache, Vector3 position)
        {
            if (cache == null || cache.PoseController == null) return;

            BotPoseController controller = cache.PoseController;
            List<NavPointData> points = NavPointRegistry.QueryNearby(position, 4f, null);

            for (int i = 0; i < points.Count; i++)
            {
                NavPointData point = points[i];
                if (!point.IsCover) continue;

                float dx = point.Position.x - position.x;
                float dy = point.Position.y - position.y;
                float dz = point.Position.z - position.z;
                float distSqr = (dx * dx) + (dy * dy) + (dz * dz);

                if (distSqr > MaxValidDistanceSqr) continue;

                if (IsProneCover(point))
                {
                    controller.SetProne(true);
                    return;
                }

                if (IsLowCover(point))
                {
                    controller.SetCrouch(true);
                    return;
                }
            }
        }

        #endregion

        #region Cover Scoring

        public static float Score(CustomNavigationPoint point, Vector3 botPos, Vector3 threatPos)
        {
            float distBot = Vector3.Distance(botPos, point.Position);
            float distThreat = Vector3.Distance(threatPos, point.Position);
            float angle = Vector3.Angle(threatPos - point.Position, botPos - point.Position);

            float bonus = 0.5f;
            if (IsProneCover(point)) bonus = 1.25f;
            else if (IsLowCover(point)) bonus = 1.0f;
            else if (IsStandingCover(point)) bonus = 0.85f;

            float threatFactor = Mathf.Clamp01(distThreat / 20f);
            float angleFactor = Mathf.Clamp01(angle / 180f);

            return (bonus + threatFactor + angleFactor) / (1f + distBot * 0.15f);
        }

        public static float Score(NavPointData point, Vector3 botPos, Vector3 threatPos)
        {
            float distBot = Vector3.Distance(botPos, point.Position);
            float distThreat = Vector3.Distance(threatPos, point.Position);
            float angle = Vector3.Angle(threatPos - point.Position, botPos - point.Position);

            float bonus = 0.5f;
            if (IsProneCover(point)) bonus = 1.25f;
            else if (IsLowCover(point)) bonus = 1.0f;
            else if (IsStandingCover(point)) bonus = 0.85f;

            float threatFactor = Mathf.Clamp01(distThreat / 20f);
            float angleFactor = Mathf.Clamp01(angle / 180f);

            return (bonus + threatFactor + angleFactor) / (1f + distBot * 0.15f);
        }

        #endregion

        #region Cover Validation

        public static bool IsValidCoverPoint(CustomNavigationPoint point, BotOwner bot, bool requireFree, bool preferIndoor)
        {
            if (point == null || bot == null)
            {
                return false;
            }

            if (requireFree && !point.IsFreeById(bot.Id))
            {
                return false;
            }

            if (point.IsSpotted)
            {
                return false;
            }

            if (preferIndoor && !point.IsGoodInsideBuilding)
            {
                return false;
            }

            return true;
        }

        #endregion

        #region Internal Helpers

        private static string GetKey(Vector3 position)
        {
            int x = Mathf.RoundToInt(position.x);
            int y = Mathf.RoundToInt(position.y);
            int z = Mathf.RoundToInt(position.z);
            return x + "_" + y + "_" + z;
        }

        #endregion
    }
}
