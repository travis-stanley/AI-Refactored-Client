// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Memory
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Tracks enemy sightings and cleared tactical zones.
    /// Prevents over-investigation, supports fallback, and enables squad memory sync.
    /// All errors are locally isolated; no method can break the bot or mod.
    /// </summary>
    public sealed class BotTacticalMemory
    {
        #region Constants

        private const float ClearedMemoryDuration = 10f;
        private const float GridSnapSize = 0.5f;
        private const float MaxMemoryTime = 14f;
        private const float PositionToleranceSqr = 0.25f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly Dictionary<Vector3, float> _clearedSpots = new Dictionary<Vector3, float>(32, new Vector3EqualityComparer());
        private readonly Dictionary<string, SeenEnemyRecord> _enemyMemoryById = new Dictionary<string, SeenEnemyRecord>(4, StringComparer.OrdinalIgnoreCase);
        private readonly List<SeenEnemyRecord> _enemyMemoryList = new List<SeenEnemyRecord>(4);

        private BotComponentCache _cache;
        private bool _extractionStarted;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            try
            {
                _cache = cache;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] Initialize failed: {ex}");
            }
        }

        #endregion

        #region Memory Management

        public void CullExpired()
        {
            try
            {
                float now = Time.time;

                for (int i = _enemyMemoryList.Count - 1; i >= 0; i--)
                {
                    if (now - _enemyMemoryList[i].TimeSeen > MaxMemoryTime)
                    {
                        _enemyMemoryList.RemoveAt(i);
                    }
                }

                List<string> expired = TempListPool.Rent<string>();
                foreach (var pair in _enemyMemoryById)
                {
                    if (now - pair.Value.TimeSeen > MaxMemoryTime)
                    {
                        expired.Add(pair.Key);
                    }
                }

                for (int i = 0; i < expired.Count; i++)
                {
                    _enemyMemoryById.Remove(expired[i]);
                }

                TempListPool.Return(expired);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] CullExpired failed: {ex}");
            }
        }

        public void ClearAll()
        {
            try
            {
                _enemyMemoryList.Clear();
                _enemyMemoryById.Clear();
                _clearedSpots.Clear();
                _extractionStarted = false;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] ClearAll failed: {ex}");
            }
        }

        #endregion

        #region Enemy Recording

        public void RecordEnemyPosition(Vector3 position, string tag, string enemyId)
        {
            try
            {
                if (_cache == null || _cache.IsBlinded || (_cache.PanicHandler?.IsPanicking == true)) return;

                float now = Time.time;
                Vector3 gridPos = SnapToGrid(position);
                string finalTag = string.IsNullOrEmpty(tag) ? "Generic" : tag.Trim();

                if (!string.IsNullOrEmpty(enemyId))
                {
                    string cleanId = enemyId.Trim();
                    if (cleanId.Length > 0)
                    {
                        _enemyMemoryById[cleanId] = new SeenEnemyRecord(gridPos, now, finalTag);
                    }
                }

                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    if ((gridPos - _enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                    {
                        _enemyMemoryList[i] = new SeenEnemyRecord(gridPos, now, finalTag);
                        return;
                    }
                }

                _enemyMemoryList.Add(new SeenEnemyRecord(gridPos, now, finalTag));
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] RecordEnemyPosition failed: {ex}");
            }
        }

        public Vector3 GetRecentEnemyMemory()
        {
            try
            {
                float now = Time.time;
                float latest = -1f;
                Vector3 result = Vector3.zero;

                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    SeenEnemyRecord record = _enemyMemoryList[i];
                    if (now - record.TimeSeen <= MaxMemoryTime && record.TimeSeen > latest)
                    {
                        latest = record.TimeSeen;
                        result = record.Position;
                    }
                }

                return result;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] GetRecentEnemyMemory failed: {ex}");
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Returns the most recently seen enemy's ID, or empty if none. Safe for use in threat fallback logic.
        /// </summary>
        public string GetMostRecentEnemyId()
        {
            try
            {
                float now = Time.time;
                float latest = -1f;
                string result = string.Empty;

                foreach (var pair in _enemyMemoryById)
                {
                    if (now - pair.Value.TimeSeen <= MaxMemoryTime && pair.Value.TimeSeen > latest)
                    {
                        latest = pair.Value.TimeSeen;
                        result = pair.Key;
                    }
                }

                return result;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] GetMostRecentEnemyId failed: {ex}");
                return string.Empty;
            }
        }

        public List<SeenEnemyRecord> GetAllMemory()
        {
            return _enemyMemoryList;
        }

        public void SyncMemory(Vector3 position)
        {
            try
            {
                RecordEnemyPosition(position, "AllyEcho", string.Empty);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] SyncMemory failed: {ex}");
            }
        }

        public void ShareMemoryWith(List<BotComponentCache> teammates)
        {
            try
            {
                if (teammates == null || teammates.Count == 0 || _cache?.Bot == null)
                {
                    return;
                }

                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    SeenEnemyRecord record = _enemyMemoryList[i];
                    for (int j = 0; j < teammates.Count; j++)
                    {
                        BotComponentCache mate = teammates[j];
                        if (mate?.Bot != null && mate.Bot != _cache.Bot)
                        {
                            mate.TacticalMemory?.SyncMemory(record.Position);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] ShareMemoryWith failed: {ex}");
            }
        }

        #endregion

        #region Tactical Evaluation

        public void MarkCleared(Vector3 position)
        {
            try
            {
                _clearedSpots[SnapToGrid(position)] = Time.time;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] MarkCleared failed: {ex}");
            }
        }

        public bool WasRecentlyCleared(Vector3 position)
        {
            try
            {
                Vector3 grid = SnapToGrid(position);
                return _clearedSpots.TryGetValue(grid, out float lastTime) &&
                       (Time.time - lastTime < ClearedMemoryDuration);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] WasRecentlyCleared failed: {ex}");
                return false;
            }
        }

        public bool IsZoneUnsafe(Vector3 position)
        {
            try
            {
                if (_cache?.Bot?.Profile == null) return false;

                float now = Time.time;
                Vector3 grid = SnapToGrid(position);

                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    if ((grid - _enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                    {
                        return true;
                    }
                }

                foreach (var kv in _clearedSpots)
                {
                    if ((kv.Key - grid).sqrMagnitude < PositionToleranceSqr &&
                        (now - kv.Value) < ClearedMemoryDuration)
                    {
                        return true;
                    }
                }

                string mapId = GameWorldHandler.TryGetValidMapName();
                return mapId.Length > 0 && BotMemoryStore.IsPositionInDangerZone(mapId, position);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] IsZoneUnsafe failed: {ex}");
                return false;
            }
        }

        public void MarkExtractionStarted()
        {
            try
            {
                _extractionStarted = true;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] MarkExtractionStarted failed: {ex}");
            }
        }

        public bool IsExtracting()
        {
            try
            {
                return _extractionStarted;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] IsExtracting failed: {ex}");
                return false;
            }
        }

        #endregion

        #region Utilities

        private static Vector3 SnapToGrid(Vector3 pos)
        {
            return new Vector3(
                Mathf.Round(pos.x / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.y / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.z / GridSnapSize) * GridSnapSize);
        }

        #endregion

        #region Nested Types

        public struct SeenEnemyRecord
        {
            public Vector3 Position;
            public float TimeSeen;
            public string Tag;

            public SeenEnemyRecord(Vector3 position, float time, string tag)
            {
                Position = position;
                TimeSeen = time;
                Tag = tag;
            }
        }

        private sealed class Vector3EqualityComparer : IEqualityComparer<Vector3>
        {
            public bool Equals(Vector3 a, Vector3 b)
            {
                return (a - b).sqrMagnitude < PositionToleranceSqr;
            }

            public int GetHashCode(Vector3 v)
            {
                unchecked
                {
                    int hash = 17;
                    hash = (hash * 23) + Mathf.RoundToInt(v.x * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.y * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.z * 10f);
                    return hash;
                }
            }
        }

        #endregion
    }
}
