// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Realism: Flashlight, laser, NVG, and thermal logic is humanized with chaos-bait, ambient awareness, and fog response.
//   Bulletproof: Pooling-optimized, multiplayer and headless safe, null-free and error-isolated.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.InventoryLogic;
    using UnityEngine;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Controls and manages tactical device toggling for bot AI:
    /// Flashlights, lasers, NVGs, and thermals.
    /// Handles ambient/fog-based logic and chaos-driven baiting.
    /// Fully null-safe, pooling-optimized, and headless/multiplayer compatible.
    /// </summary>
    public sealed class BotTacticalDeviceController
    {
        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _nextDecisionTime;
        private bool _failed;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            _failed = false;
            _nextDecisionTime = 0f;

            try
            {
                if (cache == null || cache.Bot == null)
                {
                    _failed = true;
                    return;
                }

                _bot = cache.Bot;
                _cache = cache;
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] Initialize exception: {ex}");
            }
        }

        #endregion

        #region Tick

        public void Tick()
        {
            if (_failed || !CanThink())
                return;

            try
            {
                _nextDecisionTime = Time.time + TacticalConfig.CheckInterval;

                Weapon weapon = _bot.WeaponManager?.CurrentWeapon;
                if (weapon == null)
                    return;

                List<LightComponent> devices = TempListPool.Rent<LightComponent>();
                try
                {
                    ScanModsForTacticalDevices(weapon, devices);

                    bool isLowVisibility = IsLowVisibility();
                    float chaosChance = GetChaosBaitChance();
                    bool baitTrigger = Random.value < chaosChance;
                    bool shouldEnable = isLowVisibility || baitTrigger;

                    for (int i = 0, count = devices.Count; i < count; i++)
                    {
                        LightComponent device = devices[i];
                        if (device != null && device.IsActive != shouldEnable)
                        {
                            device.IsActive = shouldEnable;
                        }
                    }

                    if (baitTrigger)
                    {
                        _nextDecisionTime = Time.time + 1.5f;
                        for (int i = 0, count = devices.Count; i < count; i++)
                        {
                            LightComponent device = devices[i];
                            if (device != null)
                            {
                                device.IsActive = false;
                            }
                        }
                    }
                }
                finally
                {
                    TempListPool.Return(devices);
                }
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] Tick exception: {ex}");
            }
        }

        #endregion

        #region Logic

        private bool CanThink()
        {
            return !_failed &&
                   _bot != null &&
                   _cache != null &&
                   !_bot.IsDead &&
                   Time.time >= _nextDecisionTime &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   _bot.GetPlayer.IsAI;
        }

        private float GetChaosBaitChance()
        {
            try
            {
                var owner = _cache?.AIRefactoredBotOwner;
                if (owner == null || owner.PersonalityProfile == null)
                    return 0f;

                float baseChaos = owner.PersonalityProfile.ChaosFactor * 0.25f;
                float awarenessMod = 1f - Mathf.Clamp01(owner.PersonalityProfile.Awareness);
                return Mathf.Clamp01(baseChaos * (0.7f + 0.6f * awarenessMod));
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotTacticalDeviceController] GetChaosBaitChance exception: {ex}");
                return 0f;
            }
        }

        private static bool IsLowVisibility()
        {
            try
            {
                float ambient = RenderSettings.ambientLight.grayscale;
                float fogDensity = RenderSettings.fog ? RenderSettings.fogDensity : 0f;
                return ambient < TacticalConfig.LightThreshold || fogDensity > TacticalConfig.FogThreshold;
            }
            catch
            {
                return false;
            }
        }

        private static void ScanModsForTacticalDevices(Weapon weapon, List<LightComponent> result)
        {
            if (weapon == null || result == null)
                return;

            var slots = weapon.AllSlots;
            if (slots == null)
                return;

            foreach (Slot slot in slots)
            {
                if (slot == null)
                    continue;

                Item mod = slot.ContainedItem;
                if (mod == null || mod.Template == null)
                    continue;

                string name = mod.Template.Name?.ToLowerInvariant();
                if (string.IsNullOrEmpty(name) || !IsTacticalName(name))
                    continue;

                if (mod is FlashlightItemClass flash && flash.Light != null)
                {
                    result.Add(flash.Light);
                }
                else if (mod is TacticalComboItemClass combo && combo.Light != null)
                {
                    result.Add(combo.Light);
                }
                else if (mod is LightLaserItemClass laser && laser.Light != null)
                {
                    result.Add(laser.Light);
                }
            }
        }

        private static bool IsTacticalName(string name)
        {
            string[] keywords = TacticalConfig.Keywords;
            for (int i = 0; i < keywords.Length; i++)
            {
                if (name.Contains(keywords[i]))
                    return true;
            }
            return false;
        }

        #endregion

        #region TacticalConfig

        private static class TacticalConfig
        {
            public const float CheckInterval = 2.0f;
            public const float FogThreshold = 0.5f;
            public const float LightThreshold = 0.3f;

            public static readonly string[] Keywords = { "light", "laser", "nvg", "thermal", "flash" };
        }

        #endregion
    }
}
