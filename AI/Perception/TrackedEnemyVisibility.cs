// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using UnityEngine;

    /// <summary>
    /// Tracks enemy bone visibility from the bot's perspective.
    /// Simulates partial body exposure, confidence decay, ambient occlusion, and motion weighting.
    /// </summary>
    public sealed class TrackedEnemyVisibility
    {
        #region Constants

        private const float BoneVisibilityDuration = 0.5f;
        private const float LinecastSlack = 0.15f;

        private static readonly Vector3 EyeOffset = new Vector3(0f, 1.4f, 0f);

        #endregion

        #region Fields

        private readonly Transform _botOrigin;
        private readonly Dictionary<string, BoneInfo> _visibleBones = new Dictionary<string, BoneInfo>(8);

        #endregion

        #region Constructor

        /// <summary>
        /// Constructs a new bone visibility tracker for the given bot origin transform.
        /// </summary>
        /// <param name="botOrigin">The bot's eye or head transform (never null).</param>
        public TrackedEnemyVisibility(Transform botOrigin)
        {
            _botOrigin = botOrigin;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets whether the bot has enough visual data to estimate a threat confidently.
        /// </summary>
        public bool HasEnoughData
        {
            get { return _visibleBones.Count >= 2; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Returns true if any bones are currently visible and unexpired.
        /// </summary>
        public bool CanSeeAny()
        {
            CleanExpired(Time.time);
            return _visibleBones.Count > 0;
        }

        /// <summary>
        /// Returns true if the bot has line of sight to the given bone, with slack for near-misses.
        /// </summary>
        /// <param name="boneName">Bone key (e.g. "Head").</param>
        public bool CanShootTo(string boneName)
        {
            BoneInfo info;
            if (!_visibleBones.TryGetValue(boneName, out info))
            {
                return false;
            }

            float now = Time.time;
            if (now - info.Timestamp > BoneVisibilityDuration)
            {
                return false;
            }

            Vector3 eye = _botOrigin.position + EyeOffset;
            float dist = Vector3.Distance(eye, info.Position);

            return !Physics.Linecast(eye, info.Position, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask)
                   || hit.distance >= dist - LinecastSlack;
        }

        /// <summary>
        /// Updates visibility data for the given bone.
        /// </summary>
        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition)
        {
            _visibleBones[boneName] = new BoneInfo(worldPosition, Time.time);
        }

        /// <summary>
        /// Updates bone visibility, including motion bonus and ambient occlusion penalty.
        /// </summary>
        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition, float motionBonus, float ambientOcclusionFactor)
        {
            float now = Time.time;
            float extra = Mathf.Clamp(motionBonus, 0f, 0.4f);
            float penalty = Mathf.Lerp(0f, 0.2f, 1f - ambientOcclusionFactor);
            float timestamp = now + extra - penalty;

            _visibleBones[boneName] = new BoneInfo(worldPosition, timestamp);
        }

        /// <summary>
        /// Gradually decays all confidence values by the specified amount.
        /// </summary>
        public void DecayConfidence(float decayAmount)
        {
            float now = Time.time;
            List<string> keys = TempListPool.Rent<string>();
            try
            {
                foreach (KeyValuePair<string, BoneInfo> kv in _visibleBones)
                {
                    keys.Add(kv.Key);
                }

                for (int i = 0; i < keys.Count; i++)
                {
                    string key = keys[i];
                    BoneInfo info = _visibleBones[key];
                    float decayed = Mathf.Max(0f, info.Timestamp - decayAmount);
                    _visibleBones[key] = new BoneInfo(info.Position, decayed);
                }
            }
            finally
            {
                TempListPool.Return(keys);
            }

            CleanExpired(now);
        }

        /// <summary>
        /// Gets the overall visibility confidence as a [0,1] value.
        /// </summary>
        public float GetOverallConfidence()
        {
            CleanExpired(Time.time);
            return Mathf.Clamp01(_visibleBones.Count / 8f);
        }

        /// <summary>
        /// Returns the current count of exposed bones.
        /// </summary>
        public int ExposedBoneCount()
        {
            CleanExpired(Time.time);
            return _visibleBones.Count;
        }

        /// <summary>
        /// Resets all bone visibility data.
        /// </summary>
        public void Clear()
        {
            _visibleBones.Clear();
        }

        #endregion

        #region Internal Methods

        /// <summary>
        /// Removes expired bone data.
        /// </summary>
        private void CleanExpired(float now)
        {
            List<string> expired = TempListPool.Rent<string>();
            try
            {
                foreach (KeyValuePair<string, BoneInfo> kv in _visibleBones)
                {
                    if (now - kv.Value.Timestamp > BoneVisibilityDuration)
                    {
                        expired.Add(kv.Key);
                    }
                }

                for (int i = 0; i < expired.Count; i++)
                {
                    _visibleBones.Remove(expired[i]);
                }
            }
            finally
            {
                TempListPool.Return(expired);
            }
        }

        #endregion

        #region Structs

        private struct BoneInfo
        {
            public readonly Vector3 Position;
            public readonly float Timestamp;

            public BoneInfo(Vector3 pos, float ts)
            {
                Position = pos;
                Timestamp = ts;
            }
        }

        #endregion
    }
}
