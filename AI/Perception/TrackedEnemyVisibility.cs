// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
//   All perception logic is bulletproof and strictly null-guarded.
// </auto-generated>

namespace AIRefactored.AI.Perception
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using UnityEngine;

    /// <summary>
    /// Tracks enemy bone visibility from the bot's perspective.
    /// Simulates partial body exposure, confidence decay, ambient occlusion, and motion weighting.
    /// </summary>
    public sealed class TrackedEnemyVisibility
    {
        #region Constants

        private const float BoneVisibilityDuration = 0.5f;
        private const float LinecastSlack = 0.15f;
        private static readonly Vector3 EyeOffset = new Vector3(0f, 1.4f, 0f);

        #endregion

        #region Fields

        private readonly Transform _botOrigin;
        private readonly Dictionary<string, BoneInfo> _visibleBones = new Dictionary<string, BoneInfo>(8);

        #endregion

        #region Constructor

        /// <summary>
        /// Constructs a new bone visibility tracker for the given bot origin transform.
        /// </summary>
        public TrackedEnemyVisibility(Transform botOrigin)
        {
            _botOrigin = botOrigin;
        }

        #endregion

        #region Public Properties

        /// <summary>
        /// Gets whether the bot has enough visual data to estimate a threat confidently.
        /// </summary>
        public bool HasEnoughData => _visibleBones.Count >= 2;

        #endregion

        #region Public Methods

        public bool CanSeeAny()
        {
            try
            {
                CleanExpired(Time.time);
                return _visibleBones.Count > 0;
            }
            catch
            {
                return false;
            }
        }

        public bool CanShootTo(string boneName)
        {
            try
            {
                if (_botOrigin == null || string.IsNullOrEmpty(boneName))
                    return false;

                if (!_visibleBones.TryGetValue(boneName, out BoneInfo info))
                    return false;

                float now = Time.time;
                if (now - info.Timestamp > BoneVisibilityDuration)
                    return false;

                Vector3 eye = _botOrigin.position + EyeOffset;
                float dist = Vector3.Distance(eye, info.Position);

                return !Physics.Linecast(eye, info.Position, out RaycastHit hit, AIRefactoredLayerMasks.LineOfSightMask)
                    || hit.distance >= dist - LinecastSlack;
            }
            catch
            {
                return false;
            }
        }

        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition)
        {
            try
            {
                if (_botOrigin == null || string.IsNullOrEmpty(boneName))
                    return;

                _visibleBones[boneName] = new BoneInfo(worldPosition, Time.time);
            }
            catch { }
        }

        public void UpdateBoneVisibility(string boneName, Vector3 worldPosition, float motionBonus, float ambientOcclusionFactor)
        {
            try
            {
                if (_botOrigin == null || string.IsNullOrEmpty(boneName))
                    return;

                float now = Time.time;
                float bonus = Mathf.Clamp(motionBonus, 0f, 0.4f);
                float penalty = Mathf.Lerp(0f, 0.2f, 1f - ambientOcclusionFactor);
                float timestamp = now + bonus - penalty;

                _visibleBones[boneName] = new BoneInfo(worldPosition, timestamp);
            }
            catch { }
        }

        public void DecayConfidence(float decayAmount)
        {
            float now = Time.time;
            List<string> keys = TempListPool.Rent<string>();
            try
            {
                foreach (var kv in _visibleBones)
                    keys.Add(kv.Key);

                for (int i = 0; i < keys.Count; i++)
                {
                    string key = keys[i];
                    BoneInfo info = _visibleBones[key];
                    float decayedTime = Mathf.Max(0f, info.Timestamp - decayAmount);
                    _visibleBones[key] = new BoneInfo(info.Position, decayedTime);
                }

                CleanExpired(now);
            }
            catch { }
            finally
            {
                TempListPool.Return(keys);
            }
        }

        public float GetOverallConfidence()
        {
            try
            {
                CleanExpired(Time.time);
                return Mathf.Clamp01(_visibleBones.Count / 8f);
            }
            catch
            {
                return 0f;
            }
        }

        public int ExposedBoneCount()
        {
            try
            {
                CleanExpired(Time.time);
                return _visibleBones.Count;
            }
            catch
            {
                return 0;
            }
        }

        public void Clear()
        {
            try
            {
                _visibleBones.Clear();
            }
            catch { }
        }

        #endregion

        #region Internal Methods

        private void CleanExpired(float now)
        {
            List<string> expired = TempListPool.Rent<string>();
            try
            {
                foreach (var kv in _visibleBones)
                {
                    if (now - kv.Value.Timestamp > BoneVisibilityDuration)
                        expired.Add(kv.Key);
                }

                for (int i = 0; i < expired.Count; i++)
                {
                    _visibleBones.Remove(expired[i]);
                }
            }
            catch { }
            finally
            {
                TempListPool.Return(expired);
            }
        }

        #endregion

        #region Structs

        private struct BoneInfo
        {
            public readonly Vector3 Position;
            public readonly float Timestamp;

            public BoneInfo(Vector3 pos, float ts)
            {
                Position = pos;
                Timestamp = ts;
            }
        }

        #endregion
    }
}
