// <auto-generated>
//   AI-Refactored: BotLootDecisionSystem.cs (Beyond Diamond Squad-Aware Edition)
//   Human-realistic, squad-aware, greed-driven looting logic with arbitration, cooldowns, memory, and voice comms.
//   All errors are isolated. No fallback disables. All logic is externally BotBrain-ticked.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Looting
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using EFT.Interactive;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Fully humanized looting system: greed, impatience, squad arbitration, memory, and voice integration.
    /// 100% managed via BotBrain. No self-tick, no fallback AI, no vanilla overrides.
    /// </summary>
    public sealed class BotLootDecisionSystem
    {
        #region Constants

        private const float MaxLootDistance = 22f;
        private const float HighValueThreshold = 25000f;
        private const float LootCooldown = 14f;
        private const float ClaimCooldown = 17f;
        private const float BlockRadius = 4.2f;
        private const float SnatchDelta = 8000f;
        private const int MaxMemory = 32;
        private const float VoiceCooldown = 4.5f;

        #endregion

        #region Fields

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotGroupComms _comms;
        private readonly LinkedList<string> _recentLooted = new LinkedList<string>();
        private readonly Dictionary<string, float> _squadClaims = new Dictionary<string, float>(16);

        private float _nextLootTime;
        private float _lastClaimTime;
        private float _lastVoiceTime;
        private string _currentClaimId;
        private bool _isActive;

        private static ManualLogSource Log => Plugin.LoggerInstance;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _comms = cache?.GroupComms;
            _isActive = _bot != null;
            if (!_isActive)
                Log.LogError("[BotLootDecisionSystem] Disabled due to null bot or cache.");
        }

        #endregion

        #region Tick

        public void Tick(float deltaTime)
        {
            if (!_isActive) return;

            float now = Time.time;
            var expired = TempListPool.Rent<string>();
            foreach (var kv in _squadClaims)
                if (now >= kv.Value)
                    expired.Add(kv.Key);
            for (int i = 0; i < expired.Count; i++)
                _squadClaims.Remove(expired[i]);
            TempListPool.Return(expired);

            while (_recentLooted.Count > MaxMemory)
                _recentLooted.RemoveFirst();
        }

        #endregion

        #region Decision Logic

        public bool ShouldLootNow()
        {
            if (!_isActive || _bot == null || _bot.IsDead || Time.time < _nextLootTime)
                return false;

            try
            {
                if (_cache.PanicHandler?.IsPanicking == true) return false;
                if (_bot.Memory?.GoalEnemy != null) return false;
                if (_bot.EnemiesController?.EnemyInfos?.Count > 0) return false;

                if (_bot.BotsGroup != null)
                {
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    {
                        BotOwner mate = _bot.BotsGroup.Member(i);
                        if (mate == null || mate == _bot || mate.IsDead) continue;
                        float dist = Vector3.Distance(_bot.Position, mate.Position);
                        if (mate.Memory?.GoalEnemy != null && dist < 16f)
                            return false;
                        if (IsSquadmateLootingSameContainer(mate, out _) && dist < BlockRadius)
                        {
                            var p = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;
                            if (p.Greed > 0.73f && UnityEngine.Random.value < 0.21f) { Say(EPhraseTrigger.OnFirstContact); continue; }
                            if (p.AggressionLevel > 0.65f && UnityEngine.Random.value < 0.13f) { Say(EPhraseTrigger.LootGeneric); continue; }
                            Say(EPhraseTrigger.HoldPosition);
                            return false;
                        }
                    }
                }

                float threshold = Mathf.Lerp(HighValueThreshold * 0.77f, HighValueThreshold * 1.12f, _cache.PersonalityProfile?.Greed ?? 0.5f);
                return _cache.LootScanner?.TotalLootValue >= threshold;
            }
            catch (Exception ex)
            {
                _isActive = false;
                Log.LogError($"[BotLootDecisionSystem] ShouldLootNow() failed: {ex}");
                return false;
            }
        }

        public Vector3 GetLootDestination()
        {
            if (!_isActive || _cache?.LootScanner == null) return Vector3.zero;

            try
            {
                float bestValue = 0f;
                Vector3 best = Vector3.zero;
                string bestId = null;
                float closest = float.MaxValue;
                var containers = LootRegistry.GetAllContainers();
                var p = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;
                float greedBias = Mathf.Lerp(0.75f, 1.15f, p.Greed);

                for (int i = 0; i < containers.Count; i++)
                {
                    var c = containers[i];
                    if (c == null || c.transform == null || !c.enabled) continue;
                    string id = c.Id;
                    if (string.IsNullOrWhiteSpace(id) || WasRecentlyLooted(id) || IsContainerClaimedBySquad(id)) continue;

                    Vector3 pos = c.transform.position;
                    float dist = Vector3.Distance(_bot.Position, pos);
                    if (dist > MaxLootDistance) continue;

                    float val = EstimateValue(c) * greedBias;
                    if (_squadClaims.TryGetValue(id, out float until) && Time.time < until)
                    {
                        float claimMin = val - SnatchDelta;
                        if (p.Greed > 0.83f && val > claimMin && UnityEngine.Random.value < 0.18f)
                        {
                            Say(EPhraseTrigger.OnEnemyConversation);
                            ReleaseClaim(id);
                        }
                        else continue;
                    }

                    if (val > bestValue || (Mathf.Approximately(val, bestValue) && dist < closest))
                    {
                        bestValue = val;
                        best = pos;
                        bestId = id;
                        closest = dist;
                    }
                }

                if (bestValue > 0f && bestId != null)
                {
                    Claim(bestId);
                    return best;
                }

                return Vector3.zero;
            }
            catch (Exception ex)
            {
                _isActive = false;
                Log.LogError($"[BotLootDecisionSystem] GetLootDestination() failed: {ex}");
                return Vector3.zero;
            }
        }

        public void MarkLooted(string lootId)
        {
            if (!_isActive || string.IsNullOrWhiteSpace(lootId)) return;

            try
            {
                if (_recentLooted.Count >= MaxMemory) _recentLooted.RemoveFirst();
                _recentLooted.AddLast(lootId.Trim());
                _nextLootTime = Time.time + LootCooldown;
                ReleaseClaim(lootId);
            }
            catch (Exception ex)
            {
                _isActive = false;
                Log.LogError($"[BotLootDecisionSystem] MarkLooted() failed: {ex}");
            }
        }

        public bool WasRecentlyLooted(string lootId)
        {
            if (!_isActive || string.IsNullOrWhiteSpace(lootId)) return false;
            try
            {
                string id = lootId.Trim();
                foreach (string entry in _recentLooted)
                    if (entry == id) return true;
                return false;
            }
            catch (Exception ex)
            {
                _isActive = false;
                Log.LogError($"[BotLootDecisionSystem] WasRecentlyLooted() failed: {ex}");
                return false;
            }
        }

        #endregion

        #region Arbitration Logic

        private void Claim(string lootId)
        {
            if (string.IsNullOrWhiteSpace(lootId)) return;
            float until = Time.time + ClaimCooldown;
            _squadClaims[lootId] = until;
            _currentClaimId = lootId;
            _lastClaimTime = Time.time;
            Say(EPhraseTrigger.LootGeneric);
        }

        private void ReleaseClaim(string lootId)
        {
            if (string.IsNullOrWhiteSpace(lootId)) return;
            _squadClaims.Remove(lootId);
            if (_currentClaimId == lootId) _currentClaimId = null;
            Say(EPhraseTrigger.LootGeneric);
        }

        private bool IsContainerClaimedBySquad(string lootId)
        {
            return _squadClaims.TryGetValue(lootId, out float until) && Time.time < until;
        }

        private bool IsSquadmateLootingSameContainer(BotOwner mate, out string lootedId)
        {
            lootedId = null;
            if (mate == null || mate.IsDead) return false;
            var cache = mate.GetComponent<BotComponentCache>();
            if (cache?.LootDecisionSystem == null) return false;

            foreach (var kv in cache.LootDecisionSystem._squadClaims)
            {
                if (Time.time < kv.Value)
                {
                    lootedId = kv.Key;
                    return true;
                }
            }

            return false;
        }

        private void Say(EPhraseTrigger phrase)
        {
            if (_comms == null || Time.time - _lastVoiceTime < VoiceCooldown) return;
            _comms.Say(phrase);
            _lastVoiceTime = Time.time;
        }

        #endregion

        #region Value Estimation

        private static float EstimateValue(LootableContainer container)
        {
            if (container?.ItemOwner?.RootItem == null)
                return 0f;

            List<Item> items = null;
            try
            {
                float total = 0f;
                items = TempListPool.Rent<Item>();
                container.ItemOwner.RootItem.GetAllItemsNonAlloc(items);

                for (int i = 0; i < items.Count; i++)
                {
                    var item = items[i];
                    if (item?.Template?.CreditsPrice > 0f)
                        total += item.Template.CreditsPrice;
                }

                return total;
            }
            catch (Exception ex)
            {
                Log.LogError($"[BotLootDecisionSystem] EstimateValue() failed: {ex}");
                return 0f;
            }
            finally
            {
                if (items != null) TempListPool.Return(items);
            }
        }

        #endregion
    }
}
