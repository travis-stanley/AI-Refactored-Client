// <auto-generated>
//   AI-Refactored: BotMovementController.cs (Critical Ultra-Realism Teleport-Fix Edition, June 2025)
//   SYSTEMATICALLY MANAGED. 100% native EFT nav, move/throttle-safe, squad/cover/lean/anticipation/human error, helper-integrated.
//   All movement only issues new destination when needed. No per-tick MoveTo, no teleport, no skating. 
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Ultimate-realism, anti-teleport, anti-skate, strictly move-cached controller for all bot movement.
    /// Every call to MoveTo is throttled to only occur when target changes or bot is stuck.
    /// No per-frame drift/jitter. All movement is agent and path-based.
    /// </summary>
    public sealed class BotMovementController
    {
        #region Constants

        private const float MoveTargetEpsilon = 0.22f;
        private const float MoveTimeCooldown = 1.15f;
        private const float MicroDriftMagnitude = 0.11f;
        private const float MinLookPause = 0.18f, MaxLookPause = 0.27f;
        private const float CoverCheckDist = 1.85f;
        private const float MaxGroupSpacing = 2.72f;
        private const float GroupSpacingForce = 0.42f;
        private const float FormationUpdateMin = 0.91f, FormationUpdateMax = 2.25f;
        private const float FormationHoldMin = 0.67f, FormationHoldMax = 1.8f;
        private const float HoldResumeDistance = 2.7f;
        private const float GroupTacticalPauseChance = 0.10f;
        private const float SquadCoverSpacing = 1.22f;
        private const float LookClampYMin = -24f, LookClampYMax = 38f;
        private const float FallbackBackoffDistance = 0.39f;
        private const float PathUncertaintyMagnitude = 0.17f;
        private const float MinSprintDistance = 11.7f, MaxSprintDistance = 24.5f;
        private const float SprintMinDuration = 1.35f, SprintMaxDuration = 2.87f;
        private const float StartlePause = 0.25f;

        private const float CombatStrafeBase = 1.10f;
        private const float CombatStrafeJitter = 0.08f;
        private const float CombatStrafeCooldownMin = 0.38f, CombatStrafeCooldownMax = 1.19f;
        private const float CombatStrafeSuppressedMul = 0.44f;
        private const float MaxStrafeAngle = 82f;

        private const float LeanCooldownMin = 0.85f, LeanCooldownMax = 1.41f, LeanLockoutSuppressed = 1.17f;
        private const float MinLeanHold = 1.05f, MaxLeanHold = 1.65f;
        private const float ObstaclePauseChance = 0.13f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;

        private Vector3 _lastMoveTarget = Vector3.zero;
        private float _lastMoveTime = -1000f;
        private float _lastScanTime, _nextLeanTime, _strafeTimer, _lastRandomPause, _nextRandomPause, _leanLockoutUntil, _lastFallbackOrSprint, _leanMissChance;
        private float _nextMicroDrift, _panicPathWobbleTimer, _startleUntil, _fallbackRetryTime;
        private bool _strafeRight, _lootingMode, _fallbackActive, _coverPauseActive, _shouldSprint;
        private Vector3 _microDriftOffset;
        private float _personalityScanDelay, _personalityStartleChance, _formationUpdateUntil, _coverPauseUntil, _formationTargetWeight;
        private bool _lastPanickingState, _inCover, _formationRolePriority;
        private float _sprintUntil;
        private bool _formationHold;
        private float _formationHoldUntil;
        private Vector3 _lastLeaderPos;
        private BotTiltType _currentLean;
        private float _leanHoldUntil;

        #endregion

        #region Properties

        public bool IsHoldingFormation => _formationHold && Time.time < _formationHoldUntil;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new InvalidOperationException("[BotMovementController] Invalid initialization.");

            _cache = cache;
            _bot = cache.Bot;

            _lastMoveTarget = Vector3.zero;
            _lastMoveTime = -1000f;

            _lastScanTime = Time.time;
            _nextLeanTime = Time.time;
            _strafeTimer = 0.51f;
            _lootingMode = false;
            _lastRandomPause = Time.time;
            _nextRandomPause = Time.time + UnityEngine.Random.Range(1.45f, 3.91f);
            _leanLockoutUntil = 0f;
            _lastFallbackOrSprint = 0f;
            _leanMissChance = (_cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f) * 0.048f;
            _nextMicroDrift = Time.time + UnityEngine.Random.Range(0.67f, 1.49f);
            _microDriftOffset = Vector3.zero;
            _panicPathWobbleTimer = 0f;
            _fallbackActive = false;
            _startleUntil = 0f;
            _fallbackRetryTime = 0f;
            _personalityScanDelay = UnityEngine.Random.Range(0.12f, 0.48f) * (_cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f);
            _personalityStartleChance = (_cache.AIRefactoredBotOwner?.PersonalityProfile?.AggressionLevel ?? 0.5f) < 0.33f ? 0.31f : 0.09f;
            _lastPanickingState = _cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking;
            _formationHold = false;
            _formationHoldUntil = 0f;
            _formationUpdateUntil = Time.time;
            _coverPauseActive = false;
            _coverPauseUntil = 0f;
            _formationTargetWeight = 0.52f;
            _formationRolePriority = false;
            _inCover = false;
            _shouldSprint = false;
            _sprintUntil = 0f;
            _lastLeaderPos = Vector3.zero;
            _currentLean = BotTiltType.right;
            _leanHoldUntil = 0f;

            BotMovementHelper.Reset(_bot);
        }

        #endregion

        #region Main Tick

        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead || _bot.Mover == null)
                    return;

                var player = _bot.GetPlayer;
                if (player == null || !player.IsAI)
                    return;

                UpdateStartlePause();
                if (Time.time < _startleUntil)
                    return;

                TrySquadSpacing(deltaTime);
                TryFormationFollow(deltaTime);
                TryFallbackPathCorrection();

                if (_cache?.Fallback != null && _cache.Fallback.IsActive())
                    _lastFallbackOrSprint = Time.time;

                if (player.IsSprintEnabled || _bot.Mover.Sprinting)
                    _lastFallbackOrSprint = Time.time;

                if (!_lootingMode)
                {
                    TryCombatStrafe(_bot.Mover, deltaTime);
                    TryLean();
                }

                TrySmoothLook(_bot.Mover, deltaTime);
                TryCoverPause();
                TryScan();
                TryPanicPathWobble(deltaTime);
                TryTacticalSprint(deltaTime);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] Tick error: " + ex);
            }
        }

        #endregion

        #region Move Issuer (Throttled)

        private void IssueMove(Vector3 target, bool slow = true, float cohesion = 1f)
        {
            if (_bot == null || _bot.Mover == null) return;

            if ((_lastMoveTarget - target).sqrMagnitude > MoveTargetEpsilon * MoveTargetEpsilon ||
                (Time.time - _lastMoveTime) > MoveTimeCooldown)
            {
                _lastMoveTarget = target;
                _lastMoveTime = Time.time;

                Vector3 drifted = target + UnityEngine.Random.insideUnitSphere * MicroDriftMagnitude;
                drifted.y = target.y;
                _bot.Mover.GoToPoint(drifted, slow, cohesion);
            }
        }

        #endregion

        #region Tactical Movement (Formation, Group, Spacing)

        private void TryFormationFollow(float deltaTime)
        {
            if (_bot.BotsGroup == null || _bot.BotsGroup.MembersCount < 2)
                return;
            if (Time.time < _formationUpdateUntil)
                return;

            int count = _bot.BotsGroup.MembersCount;
            BotOwner leader = null;

            for (int i = 0; i < count; i++)
            {
                BotOwner candidate = _bot.BotsGroup.Member(i);
                if (candidate != null && !candidate.IsDead && candidate != _bot)
                {
                    if (!_formationRolePriority || (candidate.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault)
                        < (_bot.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault))
                    {
                        leader = candidate;
                        break;
                    }
                }
            }

            if (leader == null)
                leader = _bot.BotsGroup.Member(0);

            if (leader != null && leader != _bot)
            {
                float distToLeader = (leader.Position - _bot.Position).sqrMagnitude;

                if (!_formationHold && distToLeader > 2.25f && UnityEngine.Random.value < GroupTacticalPauseChance)
                {
                    _formationHold = true;
                    _formationHoldUntil = Time.time + UnityEngine.Random.Range(FormationHoldMin, FormationHoldMax);
                    _lastLeaderPos = leader.Position;
                    return;
                }

                if (_formationHold)
                {
                    if (Time.time >= _formationHoldUntil ||
                        (leader.Position - _lastLeaderPos).sqrMagnitude > HoldResumeDistance * HoldResumeDistance)
                    {
                        _formationHold = false;
                        _formationHoldUntil = 0f;
                    }
                    else return;
                }

                if (distToLeader > 2.25f)
                {
                    Vector3 formationTarget = BotNavHelper.GetGroupFormationTarget(_bot, leader, _formationTargetWeight, SquadCoverSpacing);
                    Vector3 move = (formationTarget - _bot.Position) * deltaTime * 1.25f;
                    IssueMove(_bot.Position + move, false, _formationTargetWeight);
                }
            }

            _formationUpdateUntil = Time.time + UnityEngine.Random.Range(FormationUpdateMin, FormationUpdateMax);
        }

        private void TrySquadSpacing(float deltaTime)
        {
            if (_bot.BotsGroup == null || _bot.BotsGroup.MembersCount < 2)
                return;

            Vector3 myPos = _bot.Position;
            int count = _bot.BotsGroup.MembersCount;

            for (int i = 0; i < count; i++)
            {
                BotOwner mate = _bot.BotsGroup.Member(i);
                if (mate == null || mate == _bot || mate.IsDead)
                    continue;

                float dist = Vector3.Distance(myPos, mate.Position);
                if (dist < MaxGroupSpacing)
                {
                    Vector3 away = (myPos - mate.Position).normalized * GroupSpacingForce * (MaxGroupSpacing - dist);
                    IssueMove(_bot.Position + away, false, 0.6f);
                }
            }
        }

        private void TryCombatStrafe(BotMover mover, float deltaTime)
        {
            if (_bot == null || mover == null || _bot.Memory?.GoalEnemy == null)
                return;
            if (!mover.HasPathAndNoComplete || !_bot.Mover.IsMoving || _bot.Transform == null)
                return;

            float distToEnemy = Vector3.Distance(_bot.Position, _bot.Memory.GoalEnemy.CurrPosition);
            if (distToEnemy > 40f)
                return;

            _strafeTimer -= deltaTime;
            if (_strafeTimer <= 0f)
            {
                float suppressionFactor = 1f;
                if (_cache?.Suppression != null && _cache.Suppression.IsSuppressed())
                    suppressionFactor = CombatStrafeSuppressedMul;
                if (_cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                    suppressionFactor *= 0.71f;
                _strafeRight = UnityEngine.Random.value > 0.5f;
                _strafeTimer = UnityEngine.Random.Range(CombatStrafeCooldownMin, CombatStrafeCooldownMax) / suppressionFactor;
            }

            Vector3 toEnemy = _bot.Memory.GoalEnemy.CurrPosition - _bot.Position;
            float angle = Vector3.Angle(_bot.Transform.forward, toEnemy.normalized);
            if (angle > MaxStrafeAngle)
                return;

            Vector3 offset = _strafeRight ? _bot.Transform.right : -_bot.Transform.right;
            Vector3 jitter = UnityEngine.Random.insideUnitSphere * CombatStrafeJitter;
            Vector3 strafe = (offset + jitter).normalized * CombatStrafeBase;
            Vector3 navDir = mover.NormDirCurPoint;
            Vector3 blend = Vector3.Lerp(navDir, strafe, UnityEngine.Random.Range(0.18f, 0.33f)).normalized * deltaTime;

            if (_inCover)
                blend *= 0.55f;

            if (_cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                blend += UnityEngine.Random.insideUnitSphere * PathUncertaintyMagnitude * deltaTime;

            IssueMove(_bot.Position + blend, false, 0.43f);
        }
        private void TryLean()
        {
            if (_cache?.Tilt == null || _bot == null)
                return;

            float now = Time.time;

            if ((_cache.Suppression != null && _cache.Suppression.IsSuppressed()) ||
                (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking))
            {
                _leanLockoutUntil = now + LeanLockoutSuppressed;
                _cache.Tilt.Stop();
                return;
            }

            if (now < _leanLockoutUntil || now < _leanHoldUntil)
                return;

            if (now - _lastFallbackOrSprint < 1.19f)
            {
                _leanLockoutUntil = now + 0.62f;
                _cache.Tilt.Stop();
                return;
            }

            if (_cache.IsBlinded)
            {
                _cache.Tilt.Stop();
                return;
            }

            var memory = _bot.Memory;
            if (memory?.GoalEnemy == null || _bot.Transform == null)
            {
                _cache.Tilt.Stop();
                return;
            }

            var player = _bot.GetPlayer;
            if (player != null && (player.IsSprintEnabled || _bot.Mover.Sprinting || !_bot.Mover.IsMoving))
            {
                _cache.Tilt.Stop();
                return;
            }

            // Lean logic based on wall checks and squad
            bool wallLeft = Physics.Raycast(_bot.Position + Vector3.up * 1.53f, -_bot.Transform.right, CoverCheckDist, AIRefactoredLayerMasks.VisionBlockers);
            bool wallRight = Physics.Raycast(_bot.Position + Vector3.up * 1.53f, _bot.Transform.right, CoverCheckDist, AIRefactoredLayerMasks.VisionBlockers);

            BotTiltType nextLean = BotTiltType.right;

            if (wallLeft && !wallRight)
                nextLean = BotTiltType.right;
            else if (wallRight && !wallLeft)
                nextLean = BotTiltType.left;
            else
            {
                Vector3 toEnemy = memory.GoalEnemy.CurrPosition - _bot.Position;
                float dot = Vector3.Dot(toEnemy.normalized, _bot.Transform.right);
                nextLean = dot > 0f ? BotTiltType.right : BotTiltType.left;
            }

            if (_currentLean != nextLean || now >= _leanHoldUntil)
            {
                _currentLean = nextLean;
                _cache.Tilt.Set(nextLean);
                _leanHoldUntil = now + UnityEngine.Random.Range(MinLeanHold, MaxLeanHold);
            }

            if (UnityEngine.Random.value < _leanMissChance)
            {
                _nextLeanTime = now + UnityEngine.Random.Range(0.62f, 1.19f);
                _cache.Tilt.Stop();
                return;
            }

            if (now < _nextLeanTime)
                return;

            _nextLeanTime = now + UnityEngine.Random.Range(LeanCooldownMin, LeanCooldownMax);
            _leanLockoutUntil = now + UnityEngine.Random.Range(0.41f, 0.69f);
        }

        private void TrySmoothLook(BotMover mover, float deltaTime)
        {
            if (_bot?.Transform == null || mover == null)
                return;

            Vector3 target;
            try { target = mover._pathController.LastTargetPoint(1f); }
            catch { return; }

            if (!NavMesh.SamplePosition(target, out NavMeshHit navHit, 1.5f, NavMesh.AllAreas))
                return;

            Vector3 direction = navHit.position - _bot.Position;
            direction.y = 0f;
            if (direction.sqrMagnitude < 0.01f)
                return;

            Vector3 lookTarget = navHit.position;
            Vector3 botHead = _bot.Position + Vector3.up * 1.54f;
            Vector3 lookDir = (lookTarget - botHead).normalized;
            float yAngle = Mathf.Asin(lookDir.y) * Mathf.Rad2Deg;
            yAngle = Mathf.Clamp(yAngle, LookClampYMin, LookClampYMax);
            lookDir.y = Mathf.Sin(yAngle * Mathf.Deg2Rad);
            lookTarget = botHead + lookDir * (lookTarget - botHead).magnitude;

            BotMovementHelper.SmoothLookTo(_bot, lookTarget, 0.89f);
        }
        private void TryCoverPause()
        {
            if (_coverPauseActive && Time.time < _coverPauseUntil)
                return;

            _inCover = false;
            Vector3 head = _bot.Position + Vector3.up * 1.44f;
            if (Physics.Raycast(head, _bot.Transform.forward, CoverCheckDist, AIRefactoredLayerMasks.CoverRayMask))
            {
                _inCover = true;
                if (UnityEngine.Random.value < ObstaclePauseChance)
                {
                    _coverPauseActive = true;
                    _coverPauseUntil = Time.time + UnityEngine.Random.Range(0.16f, 0.41f);
                }
            }
            else
            {
                _coverPauseActive = false;
            }
        }

        private void TryTacticalSprint(float deltaTime)
        {
            if (_bot == null || _bot.Mover == null || _bot.IsDead)
                return;

            if (_shouldSprint && Time.time < _sprintUntil)
                return;

            if (_bot.Memory?.GoalEnemy != null ||
                _inCover ||
                (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking) ||
                (_cache.Suppression != null && _cache.Suppression.IsSuppressed()))
            {
                if (_shouldSprint)
                {
                    _bot.Mover.Sprint(false);
                    _shouldSprint = false;
                    _sprintUntil = 0f;
                }
                return;
            }

            if (!_shouldSprint &&
                _bot.Mover.IsMoving &&
                UnityEngine.Random.value < 0.13f)
            {
                Vector3 sprintTarget = Vector3.zero;
                bool validTarget = false;

                try
                {
                    if (_bot.Mover != null && _bot.Mover._pathController != null)
                    {
                        Vector3? tp = _bot.Mover._pathController.TargetPoint;
                        if (tp.HasValue)
                        {
                            sprintTarget = tp.Value;
                            validTarget = true;
                        }
                    }
                }
                catch { validTarget = false; }

                if (validTarget)
                {
                    float pathLen = (sprintTarget - _bot.Position).sqrMagnitude;
                    if (pathLen > MinSprintDistance * MinSprintDistance && pathLen < MaxSprintDistance * MaxSprintDistance)
                    {
                        if (!_bot.Mover.Sprinting)
                        {
                            _bot.Mover.Sprint(true);
                            _shouldSprint = true;
                            _sprintUntil = Time.time + UnityEngine.Random.Range(SprintMinDuration, SprintMaxDuration);
                        }
                    }
                }
            }

            if (_shouldSprint)
            {
                if (Time.time >= _sprintUntil || UnityEngine.Random.value < 0.13f)
                {
                    _bot.Mover.Sprint(false);
                    _shouldSprint = false;
                    _sprintUntil = 0f;
                }
            }
        }

        private void TryFallbackPathCorrection()
        {
            if (_fallbackActive && Time.time < _fallbackRetryTime)
                return;

            if (_fallbackActive)
            {
                Vector3 backoff = -_bot.Transform.forward * FallbackBackoffDistance;
                IssueMove(_bot.Position + backoff, false, 0.33f);
                _fallbackActive = false;
            }
        }

        private void TryPanicPathWobble(float deltaTime)
        {
            if (_cache?.PanicHandler == null || !_cache.PanicHandler.IsPanicking)
                return;

            _panicPathWobbleTimer -= deltaTime;
            if (_panicPathWobbleTimer > 0f)
                return;

            _panicPathWobbleTimer = UnityEngine.Random.Range(0.13f, 0.21f);
            Vector3 sidestep = UnityEngine.Random.insideUnitSphere * PathUncertaintyMagnitude;
            sidestep.y = 0f;
            IssueMove(_bot.Position + sidestep, false, 0.19f);
        }

        private void TryScan()
        {
            if (_bot?.Transform == null)
                return;

            if (Time.time - _lastScanTime < UnityEngine.Random.Range(1.10f, 1.47f) + _personalityScanDelay)
                return;

            Vector3 head = _bot.Position + Vector3.up * 1.52f;
            Vector3 dir = _bot.Transform.forward;
            if (Physics.SphereCast(head, 0.23f, dir, out _, 2.47f, AIRefactoredLayerMasks.VisionBlockers))
            {
                if (_bot.BotTalk != null && UnityEngine.Random.value < 0.19f)
                    _bot.BotTalk.TrySay(EPhraseTrigger.Look);
            }

            _lastScanTime = Time.time;
        }

        private void UpdateStartlePause()
        {
            if (_cache?.PanicHandler != null)
            {
                bool nowPanicking = _cache.PanicHandler.IsPanicking;
                if (!_lastPanickingState && nowPanicking)
                {
                    if (UnityEngine.Random.value < _personalityStartleChance)
                        _startleUntil = Time.time + StartlePause + UnityEngine.Random.Range(0.05f, 0.11f);
                }
                _lastPanickingState = nowPanicking;
            }
        }

        #endregion

        #region Mode Controls

        public void EnterLootingMode() => _lootingMode = true;
        public void ExitLootingMode() => _lootingMode = false;
        public bool IsInLootingMode() => _lootingMode;

        #endregion
    }
}

