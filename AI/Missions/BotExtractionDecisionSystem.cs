// <auto-generated>
//   AI-Refactored: BotExtractionDecisionSystem.cs (Ultimate Realism, Ultra-Final Beyond Diamond Edition)
//   Bulletproof, human-like extraction logic. All failures locally isolated.
//   No teleport, no fallback disables, FIKA/SPT/headless safe. Only executes safe nav-based movements.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using EFT;
    using EFT.HealthSystem;
    using EFT.Interactive;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using UnityEngine;
    using BepInEx.Logging;

    /// <summary>
    /// Handles human-like, bulletproof extraction/retreat for bots, squad- and context-aware.
    /// All logic is locally isolated, safe for FIKA/SPT/headless, only issues path-based nav moves.
    /// </summary>
    public sealed class BotExtractionDecisionSystem
    {
        #region Constants

        private const int MaxStuckRetries = 3;
        private const float MaxSearchDistance = 85f;
        private const float MinRaidTimeBeforeExtraction = 60f;
        private const float ExtractionCoolDown = 3f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotPersonalityProfile _profile;
        private readonly ManualLogSource _log;

        private float _lastMoveUpdateTime;
        private Vector3 _lastPosition;
        private int _stuckRetryCount;
        private bool _hasExtracted;
        private float _lastExtractDecisionTime;

        #endregion

        #region Constructor

        public BotExtractionDecisionSystem(BotOwner bot, BotComponentCache cache, BotPersonalityProfile profile)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotExtractionDecisionSystem] Invalid BotOwner.");

            _bot = bot;
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _profile = profile ?? throw new ArgumentNullException(nameof(profile));
            _log = Plugin.LoggerInstance;

            _lastPosition = EFTPlayerUtil.GetPosition(_bot);
            _lastMoveUpdateTime = Time.time;
            _stuckRetryCount = 0;
            _hasExtracted = false;
            _lastExtractDecisionTime = -100f;
        }

        #endregion

        #region Tick Logic

        public void Tick(float now)
        {
            if (_hasExtracted || !EFTPlayerUtil.IsValidBotOwner(_bot))
                return;

            try
            {
                if (now - _lastExtractDecisionTime < ExtractionCoolDown)
                    return;

                if (ShouldExtract(now))
                {
                    _lastExtractDecisionTime = now;
                    TriggerExtraction();
                    _hasExtracted = true;
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] Tick failed: {ex}");
            }
        }

        #endregion

        #region Decision Logic

        public bool ShouldExtract(float now)
        {
            try
            {
                if (_bot.IsDead || !EFTPlayerUtil.IsValidBotOwner(_bot))
                    return false;

                if (Time.timeSinceLevelLoad < MinRaidTimeBeforeExtraction)
                    return false;

                float composure = _cache?.PanicHandler?.GetComposureLevel() ?? 1f;
                float panicThreshold = Mathf.Lerp(0.35f, 0.15f, _profile.Caution);
                if (composure < panicThreshold)
                    return true;

                float lootValue = _cache?.LootScanner?.TotalLootValue ?? 0f;
                float lootThreshold = Mathf.Lerp(85000f, 50000f, _profile.Greed);
                if (lootValue >= lootThreshold)
                    return true;

                if (HasSquadWiped())
                    return true;

                float radius = Mathf.Lerp(35f, 60f, 1f - _profile.Cohesion);
                if (IsBotIsolated(radius))
                    return true;

                float stuckDelay = Mathf.Lerp(8f, 18f, 1f - _profile.Caution);
                if (IsBotStuck(now, stuckDelay))
                {
                    _stuckRetryCount++;
                    if (_stuckRetryCount >= MaxStuckRetries)
                        return true;

                    if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 retryTarget) &&
                        BotNavHelper.IsNavMeshPositionValid(retryTarget))
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, retryTarget, slow: true);
                    }
                }

                return false;
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] ShouldExtract failed: {ex}");
                return false;
            }
        }

        #endregion

        #region Execution Logic

        public void TriggerExtraction()
        {
            if (!EFTPlayerUtil.IsValidBotOwner(_bot)) return;

            try
            {
                _cache?.TacticalMemory?.MarkForcedExtract();

                Vector3 exfilTarget;
                if (TryFindNearbyExfil(out exfilTarget) && BotNavHelper.IsNavMeshPositionValid(exfilTarget))
                {
                    BotMovementHelper.SmoothMoveToSafeExit(_bot, exfilTarget);
                    _cache?.TacticalMemory?.MarkForcedExtract();
                    return;
                }

                if (BotNavHelper.TryGetSafeTarget(_bot, out Vector3 fallback) && BotNavHelper.IsNavMeshPositionValid(fallback))
                {
                    BotMovementHelper.SmoothMoveToSafeExit(_bot, fallback);
                    _cache?.TacticalMemory?.MarkForcedExtract();
                }
            }
            catch (Exception ex)
            {
                _log.LogError($"[BotExtractionDecisionSystem] TriggerExtraction failed: {ex}");
            }
        }

        #endregion

        #region Private Helpers

        private bool IsBotStuck(float now, float timeout)
        {
            Vector3 currentPos = EFTPlayerUtil.GetPosition(_bot);
            float moved = (currentPos - _lastPosition).sqrMagnitude;

            if (moved > 0.35f)
            {
                _lastPosition = currentPos;
                _lastMoveUpdateTime = now;
                _stuckRetryCount = 0;
                return false;
            }

            return (now - _lastMoveUpdateTime) >= timeout;
        }

        private bool HasSquadWiped()
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return false;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                    return false;
            }
            return true;
        }

        private bool IsBotIsolated(float radius)
        {
            BotsGroup group = _bot.BotsGroup;
            if (group == null || group.MembersCount <= 1) return true;

            Vector3 pos = EFTPlayerUtil.GetPosition(_bot);
            float radiusSqr = radius * radius;

            for (int i = 0; i < group.MembersCount; i++)
            {
                BotOwner mate = group.Member(i);
                if (mate != null && mate != _bot && !mate.IsDead)
                {
                    Vector3 matePos = EFTPlayerUtil.GetPosition(mate);
                    if ((matePos - pos).sqrMagnitude < radiusSqr)
                        return false;
                }
            }
            return true;
        }

        private bool TryFindNearbyExfil(out Vector3 exfil)
        {
            exfil = Vector3.zero;
            ExfiltrationPoint[] points = UnityEngine.Object.FindObjectsOfType<ExfiltrationPoint>();
            Vector3 botPos = EFTPlayerUtil.GetPosition(_bot);
            float bestDist = MaxSearchDistance * MaxSearchDistance + 1f;
            bool found = false;

            for (int i = 0; i < points.Length; i++)
            {
                ExfiltrationPoint p = points[i];
                if (p == null || !p.enabled) continue;

                float dist = (p.transform.position - botPos).sqrMagnitude;
                if (dist <= MaxSearchDistance * MaxSearchDistance && dist < bestDist)
                {
                    exfil = p.transform.position;
                    bestDist = dist;
                    found = true;
                }
            }
            return found && BotNavHelper.IsNavMeshPositionValid(exfil);
        }

        #endregion
    }
}
