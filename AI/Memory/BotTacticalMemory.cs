// <auto-generated>
//   AI-Refactored: BotTacticalMemory.cs (Beyond Diamond, BotBrain Edition)
//   All expiry/timer logic must be ticked by BotBrain. No self-tick. No fallback disables ever.
//   Bulletproof error isolation. Squad memory and danger logic fully resilient.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Memory
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Tactical enemy memory and zone clearing logic, bulletproof and BotBrain-driven.
    /// All expiry, zone, and sharing logic must be called via BotBrain.Tick().
    /// </summary>
    public sealed class BotTacticalMemory
    {
        #region Constants

        private const float ClearedMemoryDuration = 10f;
        private const float GridSnapSize = 0.5f;
        private const float MaxMemoryTime = 14f;
        private const float PositionToleranceSqr = 0.25f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly Dictionary<Vector3, float> _clearedSpots = new Dictionary<Vector3, float>(32, new Vector3EqualityComparer());
        private readonly Dictionary<string, SeenEnemyRecord> _enemyMemoryById = new Dictionary<string, SeenEnemyRecord>(4, StringComparer.OrdinalIgnoreCase);
        private readonly List<SeenEnemyRecord> _enemyMemoryList = new List<SeenEnemyRecord>(4);

        private BotComponentCache _cache;
        private bool _extractionStarted;

        #endregion

        #region Initialization

        /// <summary>
        /// Must be called at bot setup. Never self-initializes.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            try { _cache = cache; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] Initialize failed: {ex}"); }
        }

        #endregion

        #region BotBrain-Tick Management

        /// <summary>
        /// Tick expiry/cleanup logic; must be called from BotBrain every frame.
        /// </summary>
        public void Tick(float deltaTime)
        {
            CullExpired();
            CullClearedZones();
        }

        /// <summary>
        /// Cleans up expired enemy memory records (BotBrain-driven).
        /// </summary>
        private void CullExpired()
        {
            try
            {
                float now = Time.time;
                for (int i = _enemyMemoryList.Count - 1; i >= 0; i--)
                {
                    if (now - _enemyMemoryList[i].TimeSeen > MaxMemoryTime)
                        _enemyMemoryList.RemoveAt(i);
                }
                var expired = TempListPool.Rent<string>();
                foreach (var pair in _enemyMemoryById)
                {
                    if (now - pair.Value.TimeSeen > MaxMemoryTime)
                        expired.Add(pair.Key);
                }
                for (int i = 0; i < expired.Count; i++)
                    _enemyMemoryById.Remove(expired[i]);
                TempListPool.Return(expired);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] CullExpired failed: {ex}");
            }
        }

        /// <summary>
        /// Cleans up expired cleared zones (BotBrain-driven).
        /// </summary>
        private void CullClearedZones()
        {
            try
            {
                float now = Time.time;
                var expired = TempListPool.Rent<Vector3>();
                foreach (var kv in _clearedSpots)
                {
                    if (now - kv.Value > ClearedMemoryDuration)
                        expired.Add(kv.Key);
                }
                for (int i = 0; i < expired.Count; i++)
                    _clearedSpots.Remove(expired[i]);
                TempListPool.Return(expired);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] CullClearedZones failed: {ex}");
            }
        }

        #endregion

        #region Memory Management

        /// <summary>
        /// Clears all tactical memory and extracted zones.
        /// </summary>
        public void ClearAll()
        {
            try
            {
                _enemyMemoryList.Clear();
                _enemyMemoryById.Clear();
                _clearedSpots.Clear();
                _extractionStarted = false;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] ClearAll failed: {ex}");
            }
        }

        #endregion

        #region Enemy Recording

        /// <summary>
        /// Records a seen enemy at a position and time. All IDs/tags grid-snapped.
        /// </summary>
        public void RecordEnemyPosition(Vector3 position, string tag, string enemyId)
        {
            try
            {
                if (_cache == null || _cache.IsBlinded || (_cache.PanicHandler?.IsPanicking == true)) return;

                float now = Time.time;
                Vector3 gridPos = SnapToGrid(position);
                string finalTag = string.IsNullOrEmpty(tag) ? "Generic" : tag.Trim();

                if (!string.IsNullOrEmpty(enemyId))
                {
                    string cleanId = enemyId.Trim();
                    if (cleanId.Length > 0)
                        _enemyMemoryById[cleanId] = new SeenEnemyRecord(gridPos, now, finalTag);
                }

                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    if ((gridPos - _enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                    {
                        _enemyMemoryList[i] = new SeenEnemyRecord(gridPos, now, finalTag);
                        return;
                    }
                }
                _enemyMemoryList.Add(new SeenEnemyRecord(gridPos, now, finalTag));
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] RecordEnemyPosition failed: {ex}");
            }
        }

        /// <summary>
        /// Returns the most recently seen enemy position.
        /// </summary>
        public Vector3 GetRecentEnemyMemory()
        {
            try
            {
                float now = Time.time;
                float latest = -1f;
                Vector3 result = Vector3.zero;
                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    var record = _enemyMemoryList[i];
                    if (now - record.TimeSeen <= MaxMemoryTime && record.TimeSeen > latest)
                    {
                        latest = record.TimeSeen;
                        result = record.Position;
                    }
                }
                return result;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] GetRecentEnemyMemory failed: {ex}");
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Returns the most recently seen enemy's ID for fallback targeting.
        /// </summary>
        public string GetMostRecentEnemyId()
        {
            try
            {
                float now = Time.time;
                float latest = -1f;
                string result = string.Empty;
                foreach (var pair in _enemyMemoryById)
                {
                    if (now - pair.Value.TimeSeen <= MaxMemoryTime && pair.Value.TimeSeen > latest)
                    {
                        latest = pair.Value.TimeSeen;
                        result = pair.Key;
                    }
                }
                return result;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] GetMostRecentEnemyId failed: {ex}");
                return string.Empty;
            }
        }

        public List<SeenEnemyRecord> GetAllMemory()
        {
            return _enemyMemoryList;
        }

        public void SyncMemory(Vector3 position)
        {
            try { RecordEnemyPosition(position, "AllyEcho", string.Empty); }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] SyncMemory failed: {ex}"); }
        }

        public void ShareMemoryWith(List<BotComponentCache> teammates)
        {
            try
            {
                if (teammates == null || teammates.Count == 0 || _cache?.Bot == null)
                    return;

                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    var record = _enemyMemoryList[i];
                    for (int j = 0; j < teammates.Count; j++)
                    {
                        var mate = teammates[j];
                        if (mate?.Bot != null && mate.Bot != _cache.Bot)
                            mate.TacticalMemory?.SyncMemory(record.Position);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] ShareMemoryWith failed: {ex}");
            }
        }

        #endregion

        #region Tactical Evaluation

        /// <summary>
        /// Marks a grid-snapped spot as cleared. 
        /// </summary>
        public void MarkCleared(Vector3 position)
        {
            try { _clearedSpots[SnapToGrid(position)] = Time.time; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] MarkCleared failed: {ex}"); }
        }

        /// <summary>
        /// Returns true if this spot was recently cleared by the bot.
        /// </summary>
        public bool WasRecentlyCleared(Vector3 position)
        {
            try
            {
                Vector3 grid = SnapToGrid(position);
                return _clearedSpots.TryGetValue(grid, out float lastTime) && (Time.time - lastTime < ClearedMemoryDuration);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] WasRecentlyCleared failed: {ex}");
                return false;
            }
        }

        public bool IsZoneUnsafe(Vector3 position)
        {
            try
            {
                if (_cache?.Bot?.Profile == null) return false;
                float now = Time.time;
                Vector3 grid = SnapToGrid(position);
                for (int i = 0; i < _enemyMemoryList.Count; i++)
                {
                    if ((grid - _enemyMemoryList[i].Position).sqrMagnitude < PositionToleranceSqr)
                        return true;
                }
                foreach (var kv in _clearedSpots)
                {
                    if ((kv.Key - grid).sqrMagnitude < PositionToleranceSqr && (now - kv.Value) < ClearedMemoryDuration)
                        return true;
                }
                string mapId = GameWorldHandler.TryGetValidMapName();
                return mapId.Length > 0 && BotMemoryStore.IsPositionInDangerZone(mapId, position);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotTacticalMemory] IsZoneUnsafe failed: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Marks that extraction has been started (for bot extraction logic).
        /// </summary>
        public void MarkForcedExtract()
        {
            try { _extractionStarted = true; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] MarkForcedExtract failed: {ex}"); }
        }

        public bool IsExtracting()
        {
            try { return _extractionStarted; }
            catch (Exception ex) { Logger.LogError($"[BotTacticalMemory] IsExtracting failed: {ex}"); return false; }
        }

        #endregion

        #region Utilities

        private static Vector3 SnapToGrid(Vector3 pos)
        {
            return new Vector3(
                Mathf.Round(pos.x / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.y / GridSnapSize) * GridSnapSize,
                Mathf.Round(pos.z / GridSnapSize) * GridSnapSize);
        }

        #endregion

        #region Nested Types

        public struct SeenEnemyRecord
        {
            public Vector3 Position;
            public float TimeSeen;
            public string Tag;

            public SeenEnemyRecord(Vector3 position, float time, string tag)
            {
                Position = position;
                TimeSeen = time;
                Tag = tag;
            }
        }

        private sealed class Vector3EqualityComparer : IEqualityComparer<Vector3>
        {
            public bool Equals(Vector3 a, Vector3 b)
            {
                return (a - b).sqrMagnitude < PositionToleranceSqr;
            }

            public int GetHashCode(Vector3 v)
            {
                unchecked
                {
                    int hash = 17;
                    hash = (hash * 23) + Mathf.RoundToInt(v.x * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.y * 10f);
                    hash = (hash * 23) + Mathf.RoundToInt(v.z * 10f);
                    return hash;
                }
            }
        }

        #endregion
    }
}
