// <auto-generated>
//   AI-Refactored: BotBrainGuardian.cs (Final Enforcement Edition – June 2025)
//   Hardened conflict filtering, avoids false removals of safe components (e.g. CoopClientQuickGrenadeController).
//   Ensures AIRefactored owns full control of all bots; removes all injected AI logic.
//   Bulletproof across FIKA headless/client/host. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Threads
{
    using System;
    using System.Reflection;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using HarmonyLib;
    using UnityEngine;

    public static class BotBrainGuardian
    {
        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        /// <summary>
        /// Enforces AIRefactored logic-only bots by removing all foreign MonoBehaviours on the bot GameObject.
        /// </summary>
        public static void Enforce(GameObject botGameObject)
        {
            try
            {
                if (botGameObject == null || !GameWorldHandler.IsLocalHost())
                    return;

                MonoBehaviour[] components = botGameObject.GetComponents<MonoBehaviour>();
                if (components == null || components.Length == 0)
                    return;

                for (int i = 0; i < components.Length; i++)
                {
                    MonoBehaviour component = components[i];
                    if (component == null)
                        continue;

                    Type type = component.GetType();
                    if (type == typeof(BotBrain) || type == typeof(BotComponentCache))
                        continue;

                    string name = type.Name.ToLowerInvariant();
                    string ns = type.Namespace != null ? type.Namespace.ToLowerInvariant() : string.Empty;

                    if (IsUnityOrEftSafe(name, ns))
                        continue;

                    if (IsExplicitlySafe(name, ns))
                        continue;

                    if (IsConflictingBrain(name, ns) || IsHarmonyPatched(type) || HasSuspiciousMethods(type))
                    {
                        try
                        {
                            UnityEngine.Object.Destroy(component);
                            Logger.LogWarning("[BotBrainGuardian] ⚠ Removed unauthorized AI logic: " + type.FullName + " from: " + botGameObject.name);
                        }
                        catch (Exception destroyEx)
                        {
                            Logger.LogError("[BotBrainGuardian] Failed to remove " + type.FullName + ": " + destroyEx.Message);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotBrainGuardian] Global enforcement error: " + ex.Message);
            }
        }

        private static bool IsUnityOrEftSafe(string name, string ns)
        {
            return ns.StartsWith("unity") ||
                   ns.StartsWith("eft") ||
                   ns.Contains("comfort") ||
                   name.Contains("charactercontroller") ||
                   name.Contains("botfirearmcontroller") ||
                   name.Contains("triggercollidersearcher") ||
                   name.Contains("fullbodybipedik");
        }

        private static bool IsExplicitlySafe(string name, string ns)
        {
            // Protect FIKA internal logic not used for bot AI execution
            return name.Contains("coopclientquickgrenadecontroller") ||
                   name.Contains("freecameracontroller") ||
                   name.Contains("cooppatch") ||
                   name.Contains("headlessraidspectator") ||
                   ns.Contains("fika.core") ||
                   ns.Contains("acidphantasm") ||
                   ns.Contains("hk");
        }

        private static bool IsConflictingBrain(string name, string ns)
        {
            return name.Contains("brain") ||
                   name.StartsWith("pmc") ||
                   name.StartsWith("spt") ||
                   name.StartsWith("lua") ||
                   name.StartsWith("boss") ||
                   name.StartsWith("follower") ||
                   name.StartsWith("assault") ||
                   name.StartsWith("exusec") ||
                   ns.Contains("sain") ||
                   ns.Contains("mod") ||
                   ns.Contains("spt") ||
                   ns.Contains("lua") ||
                   (!ns.Contains("ai-refactored") && !ns.Contains("tarkov"));
        }

        private static bool IsHarmonyPatched(Type type)
        {
            try
            {
                MethodInfo method = type.GetMethod("Update", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                if (method == null)
                    return false;

                Patches patch = Harmony.GetPatchInfo(method);
                return patch != null && patch.Owners != null && patch.Owners.Count > 0;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotBrainGuardian] Harmony patch check failed: " + ex.Message);
                return false;
            }
        }

        private static bool HasSuspiciousMethods(Type type)
        {
            string[] methods = { "Update", "LateUpdate", "FixedUpdate", "Tick" };

            for (int i = 0; i < methods.Length; i++)
            {
                try
                {
                    MethodInfo method = type.GetMethod(methods[i], BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                    if (method != null && method.DeclaringType != typeof(MonoBehaviour))
                        return true;
                }
                catch (Exception ex)
                {
                    Logger.LogError("[BotBrainGuardian] Reflection error on method '" + methods[i] + "': " + ex.Message);
                }
            }

            return false;
        }
    }
}
