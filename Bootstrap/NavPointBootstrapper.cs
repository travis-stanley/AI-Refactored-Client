// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Runtime-safe, deferred bootstrap with cache support.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
	using System;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using AIRefactored.AI.Core;
	using AIRefactored.Core;
	using AIRefactored.Pools;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using Unity.AI.Navigation;
	using UnityEngine;
	using UnityEngine.AI;

	/// <summary>
	/// Dynamically scans valid AI navigation points including cover, rooftop, flank, and fallback zones.
	/// Headless-safe, memory-safe, and cache-enabled for runtime performance.
	/// </summary>
	public static class NavPointBootstrapper
	{
		#region Constants

		private const float ForwardCoverCheckDistance = 4.0f;
		private const float MaxSampleHeight = 4.0f; // Lowered for typical Tarkov maps, avoids overshooting floors
		private const float MinNavPointClearance = 1.6f;
		private const float RoofRaycastHeight = 12.0f;
		private const float ScanRadius = 80.0f;
		private const float ScanSpacing = 2.5f;
		private const float VerticalProbeMax = 24.0f;
		private const float VerticalStep = 2.0f;

		#endregion

		#region State

		private static readonly List<Vector3> BackgroundPending = new List<Vector3>(1024);
		private static readonly Queue<Vector3> ScanQueue = new Queue<Vector3>(2048);
		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static Vector3 _center = Vector3.zero;
		private static bool _isRunning;
		private static bool _isTaskRunning;
		private static int _registered;
		private static string _mapId = string.Empty;

		#endregion

		#region Public API

		public static void RegisterAll(string mapId)
		{
			Reset();
			_mapId = mapId;

			if (!GameWorldHandler.IsHost || !GameWorldHandler.IsInitialized)
			{
				Logger.LogWarning("[NavPointBootstrapper] Skipped — not host or world not initialized.");
				return;
			}

			if (NavPointCacheManager.TryLoad(mapId, out var cached))
			{
				for (int i = 0; i < cached.Count; i++)
				{
					var p = cached[i];
					NavPointRegistry.Register(p.Position, p.IsCover, p.Tag, p.Elevation, p.IsIndoor, p.IsJumpable, p.CoverAngle);
				}

				NavMeshStatus.SetReady();
				Logger.LogDebug("[NavPointBootstrapper] ✅ Loaded from cache: " + cached.Count + " points.");
				return;
			}

			_isRunning = true;
			_registered = 0;
			NavMeshStatus.Reset();

			// Attempt to find NavMeshSurface(s)
			NavMeshSurface[] surfaces = UnityEngine.Object.FindObjectsOfType<NavMeshSurface>();
			if (surfaces == null || surfaces.Length == 0)
			{
				Logger.LogWarning("[NavPointBootstrapper] No NavMeshSurface found.");
				_isRunning = false;
				return;
			}

			// Use the first surface as center reference
			_center = surfaces[0].transform.position;
			float half = ScanRadius * 0.5f;

			List<Vector3> pooled = TempListPool.Rent<Vector3>();
			try
			{
				for (float x = -half; x <= half; x += ScanSpacing)
				{
					for (float z = -half; z <= half; z += ScanSpacing)
					{
						pooled.Add(new Vector3(x, MaxSampleHeight, z) + _center);
					}
				}

				for (int i = 0; i < pooled.Count; i++)
				{
					ScanQueue.Enqueue(pooled[i]);
				}
			}
			finally
			{
				TempListPool.Return(pooled);
			}

			Logger.LogDebug("[NavPointBootstrapper] Queued " + ScanQueue.Count + " surface points.");

			if (!_isTaskRunning)
			{
				_isTaskRunning = true;
				Task.Run(() =>
				{
					try { PrequeueVerticalPoints(); }
					catch (Exception ex) { Logger.LogError("[NavPointBootstrapper] Vertical prequeue error: " + ex); }
					finally { _isTaskRunning = false; }
				});
			}
		}

		public static void Tick()
		{
			if (!_isRunning || !GameWorldHandler.IsHost)
			{
				return;
			}

			int maxPerFrame = FikaHeadlessDetector.IsHeadless ? 80 : 40;
			int processed = 0;
			int rejectedRaycast = 0, rejectedNavmesh = 0, rejectedClearance = 0, rejectedCheckSphere = 0;

			while (ScanQueue.Count > 0 && processed++ < maxPerFrame)
			{
				Vector3 probe = ScanQueue.Dequeue();

				if (!Physics.Raycast(probe, Vector3.down, out RaycastHit hit, MaxSampleHeight))
				{
					if (++rejectedRaycast <= 10)
						Logger.LogWarning("[NavPointBootstrapper] Point rejected (raycast miss): " + probe + " (y=" + probe.y + ")");
					continue;
				}

				Vector3 pos = hit.point;

				if (!NavMesh.SamplePosition(pos, out NavMeshHit navHit, 2.5f, NavMesh.AllAreas))
				{
					if (++rejectedNavmesh <= 10)
						Logger.LogWarning("[NavPointBootstrapper] Point rejected (NavMesh.SamplePosition fail): " + pos);
					continue;
				}

				if (Physics.Raycast(pos + Vector3.up * 0.5f, Vector3.up, MinNavPointClearance))
				{
					if (++rejectedClearance <= 10)
						Logger.LogWarning("[NavPointBootstrapper] Point rejected (blocked above): " + pos);
					continue;
				}

				Vector3 final = navHit.position;
				float elevation = final.y - _center.y;
				bool isCover = IsCoverPoint(final);
				bool isIndoor = IsIndoorPoint(final);
				string tag = ClassifyNavPoint(elevation, isCover, isIndoor);
				float coverAngle = CalculateCoverAngle(final);

				if (!Physics.CheckSphere(final, 0.2f, AIRefactoredLayerMasks.TerrainAndObstacles))
				{
					if (++rejectedCheckSphere <= 10)
						Logger.LogWarning("[NavPointBootstrapper] Point rejected (CheckSphere failed TerrainAndObstacles): " + final);
					continue;
				}

				NavPointRegistry.Register(final, isCover, tag, elevation, isIndoor, true, coverAngle);
				_registered++;
			}

			if (ScanQueue.Count == 0 && BackgroundPending.Count > 0)
			{
				lock (BackgroundPending)
				{
					for (int i = 0; i < BackgroundPending.Count; i++)
					{
						ScanQueue.Enqueue(BackgroundPending[i]);
					}
					BackgroundPending.Clear();
				}

				Logger.LogDebug("[NavPointBootstrapper] Queued vertical fallback points.");
			}

			if (ScanQueue.Count == 0 && !_isTaskRunning)
			{
				_isRunning = false;
				NavMeshStatus.SetReady();

				List<NavPointData> snapshot = NavPointRegistry.QueryNearby(_center, ScanRadius, null);
				NavPointCacheManager.Save(_mapId, snapshot);

				Logger.LogDebug("[NavPointBootstrapper] ✅ Completed scan and cached " + snapshot.Count + " nav points. Total registered: " + _registered);
			}
		}

		public static void Reset()
		{
			ScanQueue.Clear();
			BackgroundPending.Clear();
			_registered = 0;
			_isRunning = false;
			_isTaskRunning = false;
			NavMeshStatus.Reset();
			_mapId = string.Empty;
		}

		#endregion

		#region Internals

		private static void PrequeueVerticalPoints()
		{
			float half = ScanRadius * 0.5f;
			List<Vector3> tempList = TempListPool.Rent<Vector3>();

			try
			{
				for (float x = -half; x <= half; x += ScanSpacing)
				{
					for (float z = -half; z <= half; z += ScanSpacing)
					{
						for (float y = 5.0f; y <= VerticalProbeMax; y += VerticalStep)
						{
							tempList.Add(_center + new Vector3(x, y, z));
						}
					}
				}

				lock (BackgroundPending)
				{
					BackgroundPending.AddRange(tempList);
				}
			}
			finally
			{
				TempListPool.Return(tempList);
			}
		}

		private static bool IsCoverPoint(Vector3 pos)
		{
			Vector3 eye = pos + Vector3.up * 1.4f;
			for (float angle = -45f; angle <= 45f; angle += 15f)
			{
				Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;
				if (Physics.Raycast(eye, dir, ForwardCoverCheckDistance, AIRefactoredLayerMasks.HighPolyCollider))
				{
					return true;
				}
			}
			return false;
		}

		private static bool IsIndoorPoint(Vector3 pos)
		{
			return Physics.Raycast(pos + Vector3.up * 1.4f, Vector3.up, RoofRaycastHeight);
		}

		private static string ClassifyNavPoint(float elevation, bool isCover, bool isIndoor)
		{
			if (isIndoor) return "indoor";
			if (elevation > 6.0f) return "roof";
			return isCover ? "fallback" : "flank";
		}

		private static float CalculateCoverAngle(Vector3 pos)
		{
			Vector3 eye = pos + Vector3.up * 1.4f;
			for (float angle = -45f; angle <= 45f; angle += 15f)
			{
				Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;
				if (Physics.Raycast(eye, dir, ForwardCoverCheckDistance, AIRefactoredLayerMasks.HighPolyCollider))
				{
					return angle;
				}
			}
			return 0f;
		}

		#endregion
	}
}
