// <auto-generated>
//   AI-Refactored: BotGroupComms.cs (Beyond Diamond – Squad Realism, BotBrain-Ticked Edition)
//   Human-level squad comms: fallback shouts, frags, suppression, looting, VO cooldowns, squad anti-echo.
//   Centralized cooldown/timing owned only by BotBrain. Multiplayer/headless safe.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles squad-level voice and comms with human realism: fallback, frag, suppression, looting, echo guards.
    /// Driven 100% by BotBrain.Tick(); no self-tick or timing. All logic is null-guarded and headless-safe.
    /// </summary>
    public sealed class BotGroupComms
    {
        #region Constants

        private const float AllyRadius = 12f;
        private const float VoiceCooldownMin = 3.4f;
        private const float VoiceCooldownMax = 5.1f;
        private const float GroupEchoCooldown = 3.1f;
        private static readonly float AllyRadiusSqr = AllyRadius * AllyRadius;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private float _nextLocalVoiceTime;
        private float _nextGroupCommsAllowed;

        private static string _lastCommsPhrase = string.Empty;
        private static float _lastCommsTime = -99f;

        #endregion

        #region Properties

        public bool IsMuted { get; private set; }

        #endregion

        #region Constructor

        public BotGroupComms(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            IsMuted = _bot == null || _bot.BotTalk == null;
            _nextLocalVoiceTime = 0f;
            _nextGroupCommsAllowed = 0f;
        }

        #endregion

        #region Public Tick API

        /// <summary>
        /// Tick must be called from BotBrain to clear stale phrase tracking.
        /// </summary>
        public void Tick(float deltaTime)
        {
            if (Time.time - _lastCommsTime > 9.6f)
                _lastCommsPhrase = string.Empty;
        }

        #endregion

        #region Public Voice Triggers

        public void Say(EPhraseTrigger phrase) => TryTriggerVoice(phrase, 1f, false);

        public void SayFallback() => TryTriggerVoice(EPhraseTrigger.GetBack, 0.61f, true);

        public void SayFragOut() => TryTriggerVoice(EPhraseTrigger.OnEnemyGrenade, HasNearbyAlly() ? 0.82f : 0.0f, true);

        public void SayHit() => TryTriggerVoice(EPhraseTrigger.OnBeingHurt, UnityEngine.Random.Range(0.66f, 0.87f), true);

        public void SaySuppression() => TryTriggerVoice(EPhraseTrigger.Suppress, 0.69f, true);

        public void SayLootRequest() => TryTriggerVoice(EPhraseTrigger.GoLoot, 0.93f, true);

        public void SayScanArea() => TryTriggerVoice(EPhraseTrigger.Look, 0.86f, true);

        public void SayLootMove() => TryTriggerVoice(EPhraseTrigger.OnPosition, 0.82f, true);

        public void SayLootOpen() => TryTriggerVoice(EPhraseTrigger.OnLoot, 0.79f, true);

        public void SayLootSearch() => TryTriggerVoice(EPhraseTrigger.LootGeneric, 0.74f, true);

        public void SayLootTake() => TryTriggerVoice(EPhraseTrigger.LootContainer, 0.86f, true);

        public void SayLootDone() => TryTriggerVoice(EPhraseTrigger.GoodWork, 0.64f, true);

        public void SayLootGiveUp() => TryTriggerVoice(EPhraseTrigger.LootNothing, 0.81f, true);

        #endregion

        #region Group Loot Coordination API

        public bool TryRequestLootClaim(string profileId)
        {
            if (Time.time < _nextGroupCommsAllowed) return false;
            _nextGroupCommsAllowed = Time.time + GroupEchoCooldown;
            return true;
        }

        public void RegisterLootTaken(string lootId) { }

        public bool IsGroupLooting() => false;

        #endregion

        #region Internal

        private void TryTriggerVoice(EPhraseTrigger phrase, float chance, bool groupComms)
        {
            if (!IsEligible()) return;

            float now = Time.time;
            if (now < _nextLocalVoiceTime) return;

            if (groupComms && _lastCommsPhrase == phrase.ToString() && now - _lastCommsTime < GroupEchoCooldown)
                return;

            if (chance < 1f && UnityEngine.Random.value > chance)
                return;

            _nextLocalVoiceTime = now + UnityEngine.Random.Range(VoiceCooldownMin, VoiceCooldownMax);
            try
            {
                _bot.BotTalk.TrySay(phrase);
                if (groupComms)
                {
                    _lastCommsPhrase = phrase.ToString();
                    _lastCommsTime = now;
                }
            }
            catch
            {
                IsMuted = true;
            }
        }

        private bool IsEligible()
        {
            return !IsMuted &&
                   _bot != null &&
                   !_bot.IsDead &&
                   _bot.BotTalk != null &&
                   _bot.GetPlayer != null &&
                   _bot.GetPlayer.IsAI &&
                   !FikaHeadlessDetector.IsHeadless;
        }

        private bool HasNearbyAlly()
        {
            if (_bot?.Profile?.Info == null) return false;

            string groupId = _bot.Profile.Info.GroupId;
            if (string.IsNullOrEmpty(groupId)) return false;

            Vector3 pos = _bot.Position;
            foreach (var other in BotCacheUtility.AllActiveBots())
            {
                if (ReferenceEquals(other, _cache) || other?.Bot == null || other.Bot.IsDead) continue;
                if (other.Bot.Profile?.Info?.GroupId != groupId) continue;
                if ((other.Bot.Position - pos).sqrMagnitude <= AllyRadiusSqr)
                    return true;
            }

            return false;
        }

        #endregion
    }
}
