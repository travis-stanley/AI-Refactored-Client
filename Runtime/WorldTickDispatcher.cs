// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Ticking is retry-safe and non-terminal. All errors are isolated, no fallback logic is used.
// </auto-generated>

namespace AIRefactored.Runtime
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Bootstrap;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using UnityEngine;

    /// <summary>
    /// Globally ticks world systems post-initialization using a persistent MonoBehaviour.
    /// Handles world stabilization lifecycle and deferred updates.
    /// Bulletproof: All errors are strictly contained, global state is never at risk.
    /// </summary>
    public static class WorldTickDispatcher
    {
        private static GameObject _host;
        private static TickHost _monoHost;
        private static bool _isActive;
        private static bool _isQuitting;

        private static ManualLogSource Logger => Plugin.LoggerInstance;

        /// <summary>
        /// Initializes the tick dispatcher, ensuring a persistent host MonoBehaviour is active.
        /// </summary>
        public static void Initialize()
        {
            if (_isActive || _host != null || _monoHost != null || _isQuitting)
                return;

            try
            {
                _host = new GameObject("AIRefactored.WorldTickDispatcher");
                UnityEngine.Object.DontDestroyOnLoad(_host);

                _monoHost = _host.AddComponent<TickHost>();
                _isActive = true;

                LogDebug("[WorldTickDispatcher] ✅ Host attached and ticking.");
            }
            catch (Exception ex)
            {
                LogError("[WorldTickDispatcher] ❌ Initialization failed: " + ex);
            }
        }

        /// <summary>
        /// Shuts down and destroys the tick host and MonoBehaviour.
        /// </summary>
        public static void Reset()
        {
            if (!_isActive)
                return;

            _isActive = false;

            try
            {
                if (_monoHost != null)
                {
                    try { UnityEngine.Object.Destroy(_monoHost); }
                    catch (Exception ex) { LogError("[WorldTickDispatcher] ❌ Destroy _monoHost failed: " + ex); }
                }

                if (_host != null)
                {
                    try { UnityEngine.Object.Destroy(_host); }
                    catch (Exception ex) { LogError("[WorldTickDispatcher] ❌ Destroy _host failed: " + ex); }
                }

                LogDebug("[WorldTickDispatcher] 🧹 Shutdown complete.");
            }
            catch (Exception ex)
            {
                LogError("[WorldTickDispatcher] ❌ Error during host destroy: " + ex);
            }

            _monoHost = null;
            _host = null;
        }

        /// <summary>
        /// Ticks all world systems every frame; bulletproof to errors and host/teardown state.
        /// </summary>
        public static void Tick(float deltaTime)
        {
            if (!_isActive || _isQuitting || !GameWorldHandler.IsInitialized || !GameWorldHandler.IsHost)
                return;

            try
            {
                WorldBootstrapper.Tick(deltaTime);
            }
            catch (Exception ex)
            {
                LogError("[WorldTickDispatcher] ❌ Tick error: " + ex);
            }
        }

        /// <summary>
        /// MonoBehaviour tick host. Routes Unity lifecycle events to the static dispatcher.
        /// </summary>
        private sealed class TickHost : MonoBehaviour
        {
            private void Update()
            {
                try
                {
                    Tick(Time.deltaTime);
                }
                catch (Exception ex)
                {
                    LogError("[WorldTickDispatcher] ❌ Update exception: " + ex);
                }
            }

            private void OnDestroy()
            {
                try
                {
                    if (!_isQuitting)
                        Reset();
                }
                catch (Exception ex)
                {
                    LogError("[WorldTickDispatcher] ❌ OnDestroy failed: " + ex);
                }
            }

            private void OnApplicationQuit()
            {
                _isQuitting = true;
                Reset();
            }
        }

        private static void LogDebug(string msg)
        {
            if (!FikaHeadlessDetector.IsHeadless)
                Logger.LogDebug(msg);
        }

        private static void LogError(string msg)
        {
            if (!FikaHeadlessDetector.IsHeadless)
                Logger.LogError(msg);
        }
    }
}
