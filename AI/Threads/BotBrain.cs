// <auto-generated>
//   AI-Refactored: BotBrain.cs (Beyond Diamond – Ultimate Realism Edition)
//   Centralized per-bot AI tick controller. All logic is robust, atomic, and realism-maximized.
//   ALL per-bot systems tick ONLY from here. No subsystem self-tick, coroutine, or partial state.
//   Bulletproof: No terminal disables, never marks a bot as dead, all errors are logged only.
//   SPT, FIKA, headless/client parity. No Unity Debug.Log. Strict null safety throughout.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Threads
{
	using System;
	using AIRefactored.AI.Combat;
	using AIRefactored.AI.Combat.States;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Groups;
	using AIRefactored.AI.Looting;
	using AIRefactored.AI.Medical;
	using AIRefactored.AI.Memory;
	using AIRefactored.AI.Missions;
	using AIRefactored.AI.Movement;
	using AIRefactored.AI.Navigation;
	using AIRefactored.AI.Optimization;
	using AIRefactored.AI.Perception;
	using AIRefactored.AI.Reactions;
	using AIRefactored.Core;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using UnityEngine;

	/// <summary>
	/// Centralized, atomic, and bulletproof per-bot AI tick controller.
	/// No subsystem self-tick/coroutine allowed. All ticks and errors locally isolated.
	/// </summary>
	public sealed class BotBrain : MonoBehaviour
	{
		#region Fields

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private BotOwner _bot;
		private Player _player;
		private BotComponentCache _cache;

		// Major AI Subsystems (all wired from cache, bulletproof)
		private CombatStateMachine _combat;
		private BotMovementController _movement;
		private BotPoseController _pose;
		private BotLookController _look;
		private BotTilt _tilt;
		private BotCornerScanner _corner;
		private BotGroupBehavior _groupBehavior;
		private BotJumpController _jump;
		private BotVisionSystem _vision;
		private BotHearingSystem _hearing;
		private BotPerceptionSystem _perception;
		private HearingDamageComponent _hearingDamage;
		private FlashGrenadeComponent _flashDetector;
		private BotFlashReactionComponent _flashReaction;
		private BotTacticalDeviceController _tactical;
		private BotMissionController _mission;
		private BotGroupSyncCoordinator _groupSync;
		private BotTeamLogic _teamLogic;
		private BotAsyncProcessor _asyncProcessor;
		private BotThreatEscalationMonitor _threatEscalationMonitor;
		private BotInjurySystem _injury;
		private BotDeadBodyScanner _deadBodyScanner;
		private BotLootScanner _lootScanner;
		private BotLootDecisionSystem _lootDecisionSystem;
		private BotSuppressionReactionComponent _suppression;
		private BotPanicHandler _panic;
		private BotLastShotTracker _lastShotTracker;
		private BotGroupComms _groupComms;
		private FallbackHandler _fallbackHandler;
		private SquadPathCoordinator _squadPath;
		private BotOwnerPathfindingCache _pathing;
		private BotDoorInteractionSystem _doorInteraction;
		private BotTacticalMemory _tacticalMemory;
		private TrackedEnemyVisibility _trackedVisibility;

		// Tick timers and rates
		private float _nextPerceptionTick;
		private float _nextCombatTick;
		private float _nextLogicTick;
		private float _now;

		// Realism: User-adjustable tick rates with FIKA/host parity
		private const float DefaultPerceptionHz = 30f;
		private const float DefaultCombatHz = 30f;
		private const float DefaultLogicHz = 10f;

		private float PerceptionTickRate => 1f / (FikaHeadlessDetector.IsHeadless ? 60f : DefaultPerceptionHz);
		private float CombatTickRate => 1f / (FikaHeadlessDetector.IsHeadless ? 60f : DefaultCombatHz);
		private float LogicTickRate => 1f / (FikaHeadlessDetector.IsHeadless ? 20f : DefaultLogicHz);

		#endregion

		#region Initialization

		/// <summary>
		/// Must be called once per bot on spawn. Bulletproof: never disables bot, retries until ready.
		/// </summary>
		public void Initialize(BotOwner bot)
		{
			if (!GameWorldHandler.IsLocalHost())
			{
				LogWarn("[BotBrain] Initialization skipped: not authoritative host.");
				enabled = false;
				return;
			}

			if (bot == null)
			{
				LogError("[BotBrain] Initialization failed: null bot.");
				enabled = false;
				return;
			}

			_bot = bot;
			_player = bot.GetPlayer;

			if (_player == null || !_player.IsAI || _player.IsYourPlayer || bot.IsDead || _player.Profile?.Info == null)
			{
				LogWarn("[BotBrain] Initialization rejected: invalid or non-AI player.");
				enabled = false;
				return;
			}

			try
			{
				_cache = BotComponentCacheRegistry.GetOrCreate(bot);
				if (_cache == null)
				{
					LogError("[BotBrain] Initialization failed: cache could not be created.");
					enabled = false;
					return;
				}

				var owner = _cache.AIRefactoredBotOwner;
				if (owner == null)
				{
					LogError("[BotBrain] Initialization failed: owner not wired in cache.");
					enabled = false;
					return;
				}
				_cache.SetOwner(owner);

				// --- Atomic resolve: All subsystems from the cache (never left in partial state) ---
				_combat = _cache.Combat ?? new CombatStateMachine();
				_movement = _cache.Movement ?? new BotMovementController();
				_pose = _cache.PoseController ?? new BotPoseController(bot, _cache);
				_look = _cache.Look ?? new BotLookController(bot, _cache);
				_tilt = _cache.Tilt ?? new BotTilt(bot);
				_groupBehavior = _cache.GroupBehavior ?? new BotGroupBehavior();
				_corner = new BotCornerScanner(bot, _cache);
				_jump = new BotJumpController(bot, _cache);
				_vision = new BotVisionSystem(); _vision.Initialize(_cache);
				_hearing = new BotHearingSystem(); _hearing.Initialize(_cache);
				_perception = new BotPerceptionSystem(); _perception.Initialize(_cache);
				_flashReaction = new BotFlashReactionComponent(); _flashReaction.Initialize(_cache);
				_flashDetector = new FlashGrenadeComponent(); _flashDetector.Initialize(_cache);
				_hearingDamage = new HearingDamageComponent();
				_tactical = _cache.Tactical ?? new BotTacticalDeviceController();
				_mission = new BotMissionController(bot, _cache);
				_groupSync = new BotGroupSyncCoordinator(); _groupSync.Initialize(bot); _groupSync.InjectLocalCache(_cache);
				_teamLogic = new BotTeamLogic(bot);
				_asyncProcessor = new BotAsyncProcessor(); _asyncProcessor.Initialize(bot, _cache);
				_threatEscalationMonitor = new BotThreatEscalationMonitor(); _threatEscalationMonitor.Initialize(bot);

				// Additional realism: all loot/deadbody/comms/suppression/panic, always from cache
				_injury = _cache.InjurySystem;
				_deadBodyScanner = _cache.DeadBodyScanner;
				_lootScanner = _cache.LootScanner;
				_lootDecisionSystem = _cache.LootDecisionSystem;
				_suppression = _cache.Suppression;
				_panic = _cache.PanicHandler;
				_lastShotTracker = _cache.LastShotTracker;
				_groupComms = _cache.GroupComms;
				_fallbackHandler = _cache.Fallback;
				_squadPath = _cache.SquadPath;
				_pathing = _cache.Pathing;
				_doorInteraction = _cache.DoorInteraction;
				_tacticalMemory = _cache.TacticalMemory;
				_trackedVisibility = _cache.VisibilityTracker;

				// Timers set to now for frame-perfect startup
				_now = Time.time;
				_nextPerceptionTick = _now;
				_nextCombatTick = _now;
				_nextLogicTick = _now;

				BotBrainGuardian.Enforce(_player.gameObject);
				enabled = true;
				LogDebug("[BotBrain] ✅ AI initialized for: " + (_player.Profile.Info.Nickname ?? "Unnamed"));
			}
			catch (Exception ex)
			{
				LogError("[BotBrain] Initialization failed: " + ex);
				enabled = true; // Never disables bot permanently, must always retry until ready.
			}
		}

		#endregion

		#region Main Tick

		/// <summary>
		/// Centralized update loop for all AI logic. Ticks all per-bot systems at correct rates.
		/// </summary>
		public void Tick(float deltaTime)
		{
			try
			{
				if (!enabled || _bot == null || _player == null || _bot.IsDead)
					return;
				if (_player.HealthController == null || !_player.HealthController.IsAlive)
					return;

				_now = Time.time;

				// --- Real-time, frame-perfect systems: tick every frame for human realism ---
				SafeTick(_movement, m => m.Tick(deltaTime), "Movement", warn: true);
				SafeTick(_pose, p => p.Tick(_now), "Pose");
				SafeTick(_look, l => l.Tick(deltaTime), "Look");
				SafeTick(_jump, j => j.Tick(deltaTime), "Jump");
				SafeTick(_corner, c => c.Tick(_now), "CornerScanner");
				SafeTick(_tilt, t => t.ManualUpdate(), "Tilt");
				SafeTick(_groupBehavior, g => g.Tick(deltaTime), "GroupBehavior");

				// --- Perception/Combat/Logic, tick at realistic rates ---
				if (_now >= _nextPerceptionTick)
				{
					SafeTick(_vision, v => v.Tick(_now), "Vision");
					SafeTick(_hearing, h => h.Tick(_now), "Hearing");
					SafeTick(_perception, p => p.Tick(_now), "Perception");
					_nextPerceptionTick = _now + PerceptionTickRate;
				}
				if (_now >= _nextCombatTick)
				{
					SafeTick(_combat, c => c.Tick(_now), "Combat");
					SafeTick(_threatEscalationMonitor, e => e.Tick(_now), "Escalation");
					SafeTick(_flashReaction, f => f.Tick(_now), "FlashReaction");
					SafeTick(_flashDetector, f => f.Tick(_now), "FlashDetector");
					SafeTick(_groupSync, g => g.Tick(_now), "GroupSync");
					SafeTick(_teamLogic, t => t.CoordinateMovement(), "TeamLogic");
					_nextCombatTick = _now + CombatTickRate;
				}
				if (_now >= _nextLogicTick)
				{
					SafeTick(_mission, m => m.Tick(_now), "Mission");
					SafeTick(_hearingDamage, h => h.Tick(deltaTime), "HearingDamage");
					SafeTick(_tactical, t => t.Tick(), "Tactical");
					SafeTick(_injury, i => i.Tick(_now), "InjurySystem");
					SafeTick(_lootScanner, l => l.Tick(deltaTime), "LootScanner");
					SafeTick(_lootDecisionSystem, d => d.Tick(_now), "LootDecisionSystem");
					SafeTick(_deadBodyScanner, d => d.Tick(_now), "DeadBodyScanner");
					SafeTick(_asyncProcessor, a => a.Tick(_now), "AsyncProcessor");
					SafeTick(_doorInteraction, d => d.Tick(_now), "DoorInteraction");
					SafeTick(_squadPath, s => s.Tick(_now), "SquadPath");
					SafeTick(_pathing, p => p.Tick(_now), "Pathing");
					SafeTick(_tacticalMemory, t => t.Tick(_now), "TacticalMemory");
					_nextLogicTick = _now + LogicTickRate;
				}
				// --- Fallback handler ticked only during combat fallback ---
				if (_combat != null && _combat.IsInCombatState() && _fallbackHandler != null && _fallbackHandler.IsActive())
				{
					SafeTick(_fallbackHandler, f => f.Tick(deltaTime, _now, null), "FallbackHandler");
				}
			}
			catch (Exception ex)
			{
				LogError("[BotBrain] Tick error: " + ex);
			}
		}

		#endregion

		#region Safe Tick Helper

		/// <summary>
		/// Ticks a subsystem and swallows/logs all errors. Optionally warns if missing.
		/// </summary>
		private static void SafeTick<T>(T obj, Action<T> tick, string label, bool warn = false)
			where T : class
		{
			try
			{
				if (obj != null) tick(obj);
				else if (warn)
					Logger.LogWarning($"[BotBrain] {label} subsystem missing.");
			}
			catch (Exception ex)
			{
				Logger.LogWarning($"[BotBrain] {label} Tick failed: {ex}");
			}
		}

		#endregion

		#region Logging (headless safe)

		private static void LogDebug(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogDebug(msg);
		}
		private static void LogWarn(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogWarning(msg);
		}
		private static void LogError(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogError(msg);
		}

		#endregion
	}
}
