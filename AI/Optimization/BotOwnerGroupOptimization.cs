// <auto-generated>
//   AI-Refactored: BotOwnerGroupOptimization.cs (Beyond Diamond – Squad Personality, Human Realism, Bulletproof Edition)
//   All squad optimization logic is bulletproof, personality-synchronized, multiplayer/headless safe, and deeply humanized.
//   No dev/debug log calls, ever. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Applies advanced, squad-wide, personality-synchronized tuning for AIRefactored bots.
    /// All logic is strictly bulletproof and error-isolated. Features dynamic group psychology,
    /// authentic cohesion, and group-based perception/aggression scaling.
    /// Never breaks immersion; squad feels and reacts as real players do.
    /// </summary>
    public sealed class BotOwnerGroupOptimization
    {
        #region Static Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        #endregion

        #region Public Methods

        /// <summary>
        /// Applies group cohesion, perception, and aggression modifiers to all valid AI bots in a squad.
        /// Deeply humanized: every squad's behavior is unique, organic, and adapts to member losses.
        /// Bulletproof: all failures are isolated—never breaks squad or system.
        /// </summary>
        /// <param name="botOwners">Pooled list of squad bots.</param>
        public void OptimizeGroupAI(List<BotOwner> botOwners)
        {
            if (botOwners == null || botOwners.Count == 0)
                return;

            int aliveCount = 0;
            float totalCohesion = 0f, totalAggression = 0f;

            // Pass 1: Gather group personality metrics (never allocates)
            for (int i = 0, len = botOwners.Count; i < len; i++)
            {
                BotOwner bot = null;
                try
                {
                    bot = botOwners[i];
                    if (bot == null || bot.IsDead)
                        continue;

                    Profile profile = bot.Profile;
                    if (profile == null || string.IsNullOrEmpty(profile.Id))
                        continue;

                    var personality = BotRegistry.Get(profile.Id);
                    if (personality == null)
                        continue;

                    totalCohesion += Mathf.Clamp01(personality.Cohesion);
                    totalAggression += Mathf.Clamp01(personality.AggressionLevel);
                    aliveCount++;
                }
                catch { }
            }

            if (aliveCount == 0)
                return;

            float groupCohesion = totalCohesion / aliveCount;
            float groupAggression = totalAggression / aliveCount;
            int groupTotal = botOwners.Count;

            // Pass 2: Apply group/individual blending per bot
            for (int i = 0; i < groupTotal; i++)
            {
                BotOwner bot = null;
                try
                {
                    bot = botOwners[i];
                    if (bot == null || bot.IsDead)
                        continue;

                    Player player = bot.GetPlayer;
                    if (player == null || !player.IsAI || player.IsYourPlayer)
                        continue;

                    Profile profile = bot.Profile;
                    if (profile == null || string.IsNullOrEmpty(profile.Id))
                        continue;

                    BotSettingsComponents settings = null;
                    try { settings = bot.Settings != null ? bot.Settings.FileSettings : null; } catch { }
                    if (settings == null || settings.Mind == null)
                        continue;

                    BotGlobalsMindSettings mind = settings.Mind;
                    BotPersonalityProfile personality = null;
                    try { personality = BotRegistry.Get(profile.Id); } catch { }
                    if (personality == null)
                        continue;

                    ApplyModifiers(bot, personality, mind, groupCohesion, groupAggression, aliveCount, groupTotal);
                }
                catch (Exception ex)
                {
                    Logger.LogWarning("[GroupOpt] OptimizeGroupAI: Bot index " + i + " exception: " + ex);
                }
            }
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Blends group/individual values for realism and applies tactical modifiers to the bot mind.
        /// All logic is error-contained and non-allocating.
        /// </summary>
        private static void ApplyModifiers(
            BotOwner bot,
            BotPersonalityProfile personality,
            BotGlobalsMindSettings mind,
            float groupCohesion,
            float groupAggression,
            int groupAlive,
            int groupTotal)
        {
            try
            {
                // Blend individual personality towards squad mean for realism (35% weighting)
                float pCohesion = Mathf.Lerp(personality.Cohesion, groupCohesion, 0.35f);
                float pAggression = Mathf.Lerp(personality.AggressionLevel, groupAggression, 0.35f);

                // Squad size modulates risk-taking: larger squads act more cautiously in open, but retaliate harder on losses.
                float squadFactor = Mathf.Clamp01(groupTotal / 4f);
                float cohesionBonus = 1f - pCohesion * 0.6f * squadFactor;
                float aggressionBonus = pAggression * 0.2f + groupAggression * 0.15f;

                // Vision: tight squads rely more on group callouts; vision range shrinks as cohesion rises.
                mind.DIST_TO_FOUND_SQRT = Mathf.Lerp(400f, 700f, cohesionBonus);

                // Retaliation: if a squadmate is lost, aggression spikes.
                float casualtyPenalty = groupTotal > 1 ? (1f - (float)groupAlive / groupTotal) : 0f;
                mind.FRIEND_AGR_KILL = Mathf.Clamp(mind.FRIEND_AGR_KILL + aggressionBonus + casualtyPenalty * 0.45f, 0f, 1f);

                // Vision cone: narrows for close squads, wider if squad is scattered.
                mind.ENEMY_LOOK_AT_ME_ANG = Mathf.Clamp(30f - (pCohesion * 12.5f) + (1f - groupCohesion) * 7f, 5f, 40f);

                // Alertness/jitter: more twitchy if only a few alive, or squad is spread out.
                mind.MIN_DAMAGE_SCARE = Mathf.Lerp(20f, 6f, (1f - groupCohesion) + (groupAlive <= 2 ? 0.25f : 0f));
            }
            catch (Exception ex)
            {
                Logger.LogWarning("[GroupOpt] ApplyModifiers: Exception for bot " + (bot?.Profile?.Info?.Nickname ?? "Unknown") + ": " + ex);
            }
        }

        #endregion
    }
}
