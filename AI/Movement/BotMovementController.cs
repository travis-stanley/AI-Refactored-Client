// <auto-generated>
//   AI-Refactored: BotMovementController.cs (Ultimate Realism – Beyond Diamond Edition)
//   SYSTEMATICALLY MANAGED. 100% native EFT nav, advanced squad/cover/lean/anticipation/human error, helper-integrated.
//   All tick/interval logic owned by BotBrain. No disables, no allocations in hot paths, all failures locally isolated.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Ultra-Realistic movement, lean, squad, cover, anticipation, micro-jitter, fallback, and tactical sprint controller.
    /// All logic atomic, squad/personality/context driven, error-isolated, zero-allocation, and multiplayer/headless safe.
    /// Tick() ONLY by BotBrain. No fallback disables, no partial state.
    /// </summary>
    public sealed class BotMovementController
    {
        #region Constants

        private const float MicroDriftIntervalMin = 0.67f, MicroDriftIntervalMax = 1.49f, MicroDriftMagnitude = 0.11f;
        private const float CombatStrafeBase = 1.10f, CombatStrafeJitter = 0.08f;
        private const float CombatStrafeCooldownMin = 0.38f, CombatStrafeCooldownMax = 1.19f;
        private const float CombatStrafeSuppressedMul = 0.44f;
        private const float FallbackBackoffDistance = 0.39f;
        private const float LeanCooldownMin = 0.75f, LeanCooldownMax = 1.27f, LeanLockoutSuppressed = 1.11f;
        private const float MaxStrafeAngle = 82f, StartlePause = 0.25f;
        private const float PathUncertaintyMagnitude = 0.17f;
        private const float MinLookPause = 0.13f, MaxLookPause = 0.25f;
        private const float MaxGroupSpacing = 2.72f;
        private const float GroupSpacingForce = 0.42f;
        private const float FormationUpdateMin = 0.81f, FormationUpdateMax = 2.17f;
        private const float GroupTacticalPauseChance = 0.10f;
        private const float FormationHoldMin = 0.55f, FormationHoldMax = 1.6f;
        private const float HoldResumeDistance = 2.7f;
        private const float SquadCoverSpacing = 1.22f;
        private const float CoverCheckDist = 1.85f;
        private const float ObstaclePauseChance = 0.15f;
        private const float MinSprintDistance = 11.7f, MaxSprintDistance = 24.5f;
        private const float SprintMinDuration = 1.35f, SprintMaxDuration = 2.87f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private BotOwner _bot;
        private BotComponentCache _cache;

        // -- Timers/state for all movement features --
        private float _lastScanTime, _nextLeanTime, _strafeTimer, _lastRandomPause, _nextRandomPause, _leanLockoutUntil, _lastFallbackOrSprint, _leanMissChance;
        private float _nextMicroDrift, _panicPathWobbleTimer, _startleUntil, _fallbackRetryTime;
        private bool _strafeRight, _lootingMode, _fallbackActive, _coverPauseActive, _shouldSprint;
        private Vector3 _microDriftOffset;
        private float _personalityScanDelay, _personalityStartleChance, _formationUpdateUntil, _coverPauseUntil, _formationTargetWeight;
        private bool _lastPanickingState, _inCover, _formationRolePriority;
        private float _sprintUntil;
        private bool _formationHold;
        private float _formationHoldUntil;
        private Vector3 _lastLeaderPos;

        #endregion

        #region Properties

        public bool IsHoldingFormation => _formationHold && Time.time < _formationHoldUntil;

        #endregion

        #region Initialization

        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
                throw new InvalidOperationException("[BotMovementController] Invalid initialization.");

            _cache = cache;
            _bot = cache.Bot;

            _lastScanTime = Time.time;
            _nextLeanTime = Time.time;
            _strafeTimer = 0.51f;
            _lootingMode = false;
            _lastRandomPause = Time.time;
            _nextRandomPause = Time.time + UnityEngine.Random.Range(1.45f, 3.91f);
            _leanLockoutUntil = 0f;
            _lastFallbackOrSprint = 0f;
            _leanMissChance = (_cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f) * 0.065f;
            _nextMicroDrift = Time.time + UnityEngine.Random.Range(MicroDriftIntervalMin, MicroDriftIntervalMax);
            _microDriftOffset = Vector3.zero;
            _panicPathWobbleTimer = 0f;
            _fallbackActive = false;
            _startleUntil = 0f;
            _fallbackRetryTime = 0f;
            _personalityScanDelay = UnityEngine.Random.Range(0.16f, 0.52f) * (_cache.AIRefactoredBotOwner?.PersonalityProfile?.Caution ?? 0.5f);
            _personalityStartleChance = (_cache.AIRefactoredBotOwner?.PersonalityProfile?.AggressionLevel ?? 0.5f) < 0.33f ? 0.36f : 0.09f;
            _lastPanickingState = _cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking;
            _formationHold = false;
            _formationHoldUntil = 0f;
            _formationUpdateUntil = Time.time;
            _coverPauseActive = false;
            _coverPauseUntil = 0f;
            _formationTargetWeight = 0.52f;
            _formationRolePriority = false;
            _inCover = false;
            _shouldSprint = false;
            _sprintUntil = 0f;
            _lastLeaderPos = Vector3.zero;
            BotMovementHelper.Reset(_bot); // stutter cache reset
        }

        #endregion

        #region Main Tick

        public void Tick(float deltaTime)
        {
            try
            {
                if (_bot == null || _bot.IsDead || _bot.Mover == null)
                    return;
                var player = _bot.GetPlayer;
                if (player == null || !player.IsAI)
                    return;

                UpdateStartlePause();
                if (Time.time < _startleUntil)
                    return;

                TrySquadSpacing(deltaTime);
                TryFormationFollow(deltaTime);
                TryFallbackPathCorrection();

                if (_cache?.Fallback != null && _cache.Fallback.IsActive())
                    _lastFallbackOrSprint = Time.time;
                if (player.IsSprintEnabled || _bot.Mover.Sprinting)
                    _lastFallbackOrSprint = Time.time;

                if (!_lootingMode)
                {
                    TryCombatStrafe(_bot.Mover, deltaTime);
                    TryLean();
                }

                TrySmoothLook(_bot.Mover, deltaTime);
                TryCoverPause();
                TryScan();
                TryMicroDrift(deltaTime);
                TryPanicPathWobble(deltaTime);
                TryTacticalSprint(deltaTime);
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotMovementController] Tick error: " + ex);
            }
        }

        #endregion

        #region Advanced Humanized Movement Subsystems

        private void TryFormationFollow(float deltaTime)
        {
            if (_bot.BotsGroup == null || _bot.BotsGroup.MembersCount < 2)
                return;
            if (Time.time < _formationUpdateUntil)
                return;

            int count = _bot.BotsGroup.MembersCount;
            BotOwner leader = null;
            for (int i = 0; i < count; i++)
            {
                BotOwner candidate = _bot.BotsGroup.Member(i);
                if (candidate != null && !candidate.IsDead && candidate != _bot)
                {
                    if (!_formationRolePriority || (candidate.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault) < (_bot.Profile?.Info?.Settings?.Role ?? WildSpawnType.assault))
                    {
                        leader = candidate;
                        break;
                    }
                }
            }
            if (leader == null)
                leader = _bot.BotsGroup.Member(0);

            if (leader != null && leader != _bot)
            {
                float distToLeader = (leader.Position - _bot.Position).sqrMagnitude;

                if (!_formationHold && distToLeader > 2.25f && UnityEngine.Random.value < GroupTacticalPauseChance)
                {
                    _formationHold = true;
                    _formationHoldUntil = Time.time + UnityEngine.Random.Range(FormationHoldMin, FormationHoldMax);
                    _lastLeaderPos = leader.Position;
                    return;
                }

                if (_formationHold)
                {
                    if (Time.time >= _formationHoldUntil ||
                        (leader.Position - _lastLeaderPos).sqrMagnitude > HoldResumeDistance * HoldResumeDistance)
                    {
                        _formationHold = false;
                        _formationHoldUntil = 0f;
                    }
                    else
                    {
                        return;
                    }
                }

                if (distToLeader > 2.25f)
                {
                    Vector3 formationTarget = BotNavHelper.GetGroupFormationTarget(_bot, leader, _formationTargetWeight, SquadCoverSpacing);
                    Vector3 move = (formationTarget - _bot.Position) * deltaTime * 1.25f;
                    BotMovementHelper.SmoothMoveTo(_bot, _bot.Position + move, false, _formationTargetWeight);
                }
            }

            _formationUpdateUntil = Time.time + UnityEngine.Random.Range(FormationUpdateMin, FormationUpdateMax);
        }

        private void TrySquadSpacing(float deltaTime)
        {
            if (_bot.BotsGroup == null || _bot.BotsGroup.MembersCount < 2)
                return;
            Vector3 myPos = _bot.Position;
            int count = _bot.BotsGroup.MembersCount;
            for (int i = 0; i < count; i++)
            {
                BotOwner mate = _bot.BotsGroup.Member(i);
                if (mate == null || mate == _bot || mate.IsDead)
                    continue;

                float dist = Vector3.Distance(myPos, mate.Position);
                if (dist < MaxGroupSpacing)
                {
                    Vector3 away = (myPos - mate.Position).normalized * GroupSpacingForce * (MaxGroupSpacing - dist);
                    BotMovementHelper.SmoothMoveTo(_bot, _bot.Position + away, false, 0.6f);
                }
            }
        }

        private void TryMicroDrift(float deltaTime)
        {
            if (_bot == null || _bot.Transform == null || !_bot.Mover.IsMoving)
                return;
            if (Time.time < _nextMicroDrift)
                return;
            Vector3 randomOffset = UnityEngine.Random.insideUnitSphere * MicroDriftMagnitude;
            randomOffset.y = 0f;
            _microDriftOffset = randomOffset;
            BotMovementHelper.SmoothMoveTo(_bot, _bot.Position + _microDriftOffset, false, 0.42f);
            _nextMicroDrift = Time.time + UnityEngine.Random.Range(MicroDriftIntervalMin, MicroDriftIntervalMax);
        }

        private void TrySmoothLook(BotMover mover, float deltaTime)
        {
            if (_bot?.Transform == null || mover == null)
                return;

            Vector3 target;
            try { target = mover._pathController.LastTargetPoint(1f); }
            catch { return; }
            if (!NavMesh.SamplePosition(target, out NavMeshHit navHit, 1.5f, NavMesh.AllAreas))
                return;
            Vector3 direction = navHit.position - _bot.Position;
            direction.y = 0f;
            if (direction.sqrMagnitude < 0.01f)
                return;

            BotMovementHelper.SmoothLookTo(_bot, navHit.position, 0.89f);

            if (Time.time > _nextRandomPause)
            {
                _lastRandomPause = Time.time;
                _nextRandomPause = Time.time + UnityEngine.Random.Range(1.18f, 3.71f);
            }
            else if (Time.time < _lastRandomPause + UnityEngine.Random.Range(MinLookPause, MaxLookPause)
                     && UnityEngine.Random.value < 0.09f)
            {
                return;
            }
        }

        private void TryCombatStrafe(BotMover mover, float deltaTime)
        {
            if (_bot == null || mover == null || _bot.Memory?.GoalEnemy == null)
                return;
            if (!mover.HasPathAndNoComplete || !_bot.Mover.IsMoving || _bot.Transform == null)
                return;

            float distToEnemy = Vector3.Distance(_bot.Position, _bot.Memory.GoalEnemy.CurrPosition);
            if (distToEnemy > 40f)
                return;

            _strafeTimer -= deltaTime;
            if (_strafeTimer <= 0f)
            {
                float suppressionFactor = 1f;
                if (_cache?.Suppression != null && _cache.Suppression.IsSuppressed())
                    suppressionFactor = CombatStrafeSuppressedMul;
                if (_cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                    suppressionFactor *= 0.71f;
                _strafeRight = UnityEngine.Random.value > 0.5f;
                _strafeTimer = UnityEngine.Random.Range(CombatStrafeCooldownMin, CombatStrafeCooldownMax) / suppressionFactor;
            }

            Vector3 toEnemy = _bot.Memory.GoalEnemy.CurrPosition - _bot.Position;
            float angle = Vector3.Angle(_bot.Transform.forward, toEnemy.normalized);
            if (angle > MaxStrafeAngle)
                return;

            Vector3 offset = _strafeRight ? _bot.Transform.right : -_bot.Transform.right;
            Vector3 jitter = UnityEngine.Random.insideUnitSphere * CombatStrafeJitter;
            Vector3 strafe = (offset + jitter).normalized * CombatStrafeBase;
            Vector3 navDir = mover.NormDirCurPoint;
            Vector3 blend = Vector3.Lerp(navDir, strafe, UnityEngine.Random.Range(0.18f, 0.33f)).normalized * deltaTime;

            if (_inCover)
                blend *= 0.55f;

            if (_cache?.PanicHandler != null && _cache.PanicHandler.IsPanicking)
                blend += UnityEngine.Random.insideUnitSphere * PathUncertaintyMagnitude * deltaTime;

            BotMovementHelper.SmoothMoveTo(_bot, _bot.Position + blend, false, 0.43f);
        }

        private void TryLean()
        {
            if (_cache?.Tilt == null || _bot == null)
                return;
            float now = Time.time;
            if ((_cache.Suppression != null && _cache.Suppression.IsSuppressed()) ||
                (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking))
            {
                _leanLockoutUntil = now + LeanLockoutSuppressed;
                return;
            }
            if (now < _leanLockoutUntil)
                return;
            if (now - _lastFallbackOrSprint < 1.23f)
            {
                _leanLockoutUntil = now + 0.72f;
                return;
            }
            if (_cache.IsBlinded)
                return;

            var memory = _bot.Memory;
            if (memory?.GoalEnemy == null || _bot.Transform == null)
                return;
            var player = _bot.GetPlayer;
            if (player != null && (player.IsSprintEnabled || _bot.Mover.Sprinting || !_bot.Mover.IsMoving))
                return;

            bool leanLeft = false, leanRight = false;
            Vector3 head = _bot.Position + Vector3.up * 1.53f;

            if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
            {
                int myIndex = -1;
                for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                    if (_bot.BotsGroup.Member(i) == _bot) { myIndex = i; break; }
                if (myIndex >= 0 && myIndex % 2 == 0) leanLeft = true; else leanRight = true;
            }

            bool wallLeft = Physics.Raycast(head, -_bot.Transform.right, CoverCheckDist, AIRefactoredLayerMasks.VisionBlockers);
            bool wallRight = Physics.Raycast(head, _bot.Transform.right, CoverCheckDist, AIRefactoredLayerMasks.VisionBlockers);
            if (wallLeft && !wallRight)
                _cache.Tilt.Set(BotTiltType.right);
            else if (wallRight && !wallLeft)
                _cache.Tilt.Set(BotTiltType.left);
            else if (leanRight)
                _cache.Tilt.Set(BotTiltType.right);
            else if (leanLeft)
                _cache.Tilt.Set(BotTiltType.left);
            else
            {
                Vector3 toEnemy = memory.GoalEnemy.CurrPosition - _bot.Position;
                float dot = Vector3.Dot(toEnemy.normalized, _bot.Transform.right);
                bool tacticalLean = UnityEngine.Random.value < 0.85f;
                _cache.Tilt.Set(tacticalLean
                    ? (dot > 0f ? BotTiltType.right : BotTiltType.left)
                    : (dot > 0f ? BotTiltType.left : BotTiltType.right));
            }
            if (UnityEngine.Random.value < _leanMissChance)
            {
                _nextLeanTime = now + UnityEngine.Random.Range(0.62f, 1.19f);
                return;
            }
            if (now < _nextLeanTime)
                return;
            _nextLeanTime = now + UnityEngine.Random.Range(LeanCooldownMin, LeanCooldownMax);
            _leanLockoutUntil = now + UnityEngine.Random.Range(0.41f, 0.69f);
        }

        private void TryCoverPause()
        {
            if (_coverPauseActive && Time.time < _coverPauseUntil)
                return;

            _inCover = false;
            Vector3 head = _bot.Position + Vector3.up * 1.44f;
            if (Physics.Raycast(head, _bot.Transform.forward, CoverCheckDist, AIRefactoredLayerMasks.CoverRayMask))
            {
                _inCover = true;
                if (UnityEngine.Random.value < ObstaclePauseChance)
                {
                    _coverPauseActive = true;
                    _coverPauseUntil = Time.time + UnityEngine.Random.Range(0.16f, 0.41f);
                }
            }
            else
            {
                _coverPauseActive = false;
            }
        }

        private void TryTacticalSprint(float deltaTime)
        {
            if (_bot == null || _bot.Mover == null || _bot.IsDead)
                return;
            if (_shouldSprint && Time.time < _sprintUntil)
                return;

            if (_bot.Memory?.GoalEnemy != null ||
                _inCover ||
                (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking) ||
                (_cache.Suppression != null && _cache.Suppression.IsSuppressed()))
            {
                if (_shouldSprint)
                {
                    _bot.Mover.Sprint(false);
                    _shouldSprint = false;
                    _sprintUntil = 0f;
                }
                return;
            }

            if (!_shouldSprint &&
                _bot.Mover.IsMoving &&
                UnityEngine.Random.value < 0.13f)
            {
                Vector3 sprintTarget = Vector3.zero;
                bool validTarget = false;

                try
                {
                    if (_bot.Mover != null && _bot.Mover._pathController != null)
                    {
                        Vector3? tp = _bot.Mover._pathController.TargetPoint;
                        if (tp.HasValue)
                        {
                            sprintTarget = tp.Value;
                            validTarget = true;
                        }
                    }
                }
                catch { validTarget = false; }

                if (validTarget)
                {
                    float pathLen = (sprintTarget - _bot.Position).sqrMagnitude;
                    if (pathLen > MinSprintDistance * MinSprintDistance && pathLen < MaxSprintDistance * MaxSprintDistance)
                    {
                        if (!_bot.Mover.Sprinting)
                        {
                            _bot.Mover.Sprint(true);
                            _shouldSprint = true;
                            _sprintUntil = Time.time + UnityEngine.Random.Range(SprintMinDuration, SprintMaxDuration);
                        }
                    }
                }
            }

            if (_shouldSprint)
            {
                if (Time.time >= _sprintUntil || UnityEngine.Random.value < 0.13f)
                {
                    _bot.Mover.Sprint(false);
                    _shouldSprint = false;
                    _sprintUntil = 0f;
                }
            }
        }

        private void TryScan()
        {
            if (_bot?.Transform == null)
                return;
            if (Time.time - _lastScanTime < UnityEngine.Random.Range(1.10f, 1.47f) + _personalityScanDelay)
                return;
            Vector3 head = _bot.Position + Vector3.up * 1.52f;
            Vector3 dir = _bot.Transform.forward;
            if (Physics.SphereCast(head, 0.23f, dir, out _, 2.47f, AIRefactoredLayerMasks.VisionBlockers))
            {
                if (_bot.BotTalk != null && UnityEngine.Random.value < 0.19f)
                    _bot.BotTalk.TrySay(EPhraseTrigger.Look);
            }
            _lastScanTime = Time.time;
        }

        private void TryFallbackPathCorrection()
        {
            if (_fallbackActive && Time.time < _fallbackRetryTime)
                return;
            if (_fallbackActive)
            {
                Vector3 backoff = -_bot.Transform.forward * FallbackBackoffDistance;
                BotMovementHelper.SmoothMoveTo(_bot, _bot.Position + backoff, false, 0.33f);
                _fallbackActive = false;
            }
        }

        private void TryPanicPathWobble(float deltaTime)
        {
            if (_cache?.PanicHandler == null || !_cache.PanicHandler.IsPanicking)
                return;
            _panicPathWobbleTimer -= deltaTime;
            if (_panicPathWobbleTimer > 0f)
                return;
            _panicPathWobbleTimer = UnityEngine.Random.Range(0.13f, 0.21f);
            Vector3 sidestep = UnityEngine.Random.insideUnitSphere * PathUncertaintyMagnitude;
            sidestep.y = 0f;
            BotMovementHelper.SmoothMoveTo(_bot, _bot.Position + sidestep, false, 0.19f);
        }

        private void UpdateStartlePause()
        {
            if (_cache?.PanicHandler != null)
            {
                bool nowPanicking = _cache.PanicHandler.IsPanicking;
                if (!_lastPanickingState && nowPanicking)
                {
                    if (UnityEngine.Random.value < _personalityStartleChance)
                        _startleUntil = Time.time + StartlePause + UnityEngine.Random.Range(0.05f, 0.11f);
                }
                _lastPanickingState = nowPanicking;
            }
        }

        #endregion

        #region Mode Controls

        public void EnterLootingMode() => _lootingMode = true;
        public void ExitLootingMode() => _lootingMode = false;
        public bool IsInLootingMode() => _lootingMode;

        #endregion
    }
}
