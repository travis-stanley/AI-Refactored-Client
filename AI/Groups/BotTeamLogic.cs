// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Realism: Squad logic is human-like, staggered, never instant, and never disables itself or others.
//   Bulletproof: All errors are locally isolated, squad logic never breaks parent AI or the mod.
// </auto-generated>

namespace AIRefactored.AI.Groups
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using static AIRefactored.AI.Missions.BotMissionController;
    using Random = UnityEngine.Random;

    /// <summary>
    /// Coordinates squad-level tactical behavior: fallback, enemy sharing, organic regrouping.
    /// Bulletproof: All errors are locally isolated, squad logic never breaks parent AI or the mod.
    /// </summary>
    public sealed class BotTeamLogic
    {
        #region Constants

        private const float RegroupJitterRadius = 1.5f;
        private const float RegroupThresholdSqr = 6.25f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly Dictionary<BotOwner, CombatStateMachine> _combatMap = new Dictionary<BotOwner, CombatStateMachine>(8);
        private readonly List<BotOwner> _teammates = new List<BotOwner>(8);

        #endregion

        #region Constructor

        /// <summary>
        /// Constructs a BotTeamLogic instance for the given bot owner.
        /// </summary>
        /// <param name="bot">BotOwner to coordinate squad logic for.</param>
        public BotTeamLogic(BotOwner bot)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot))
                throw new ArgumentException("[BotTeamLogic] Invalid or non-AI bot owner.");
            _bot = bot;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Registers an enemy with all squadmates except the caller, with organic delay.
        /// </summary>
        public static void AddEnemy(BotOwner bot, IPlayer target)
        {
            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(bot) || target == null || bot.BotsGroup == null)
                    return;

                Player resolved = EFTPlayerUtil.ResolvePlayerById(target.ProfileId);
                if (!EFTPlayerUtil.IsValid(resolved))
                    return;

                IPlayer safe = EFTPlayerUtil.AsSafeIPlayer(resolved);
                int count = bot.BotsGroup.MembersCount;

                for (int i = 0; i < count; i++)
                {
                    BotOwner mate = bot.BotsGroup.Member(i);
                    if (EFTPlayerUtil.IsValidBotOwner(mate) && mate != bot)
                    {
                        float delay = Random.Range(0.07f, 0.27f);
                        TriggerDelayedRegisterEnemy(mate, safe, delay);
                    }
                }
            }
            catch { }
        }

        /// <summary>
        /// Broadcasts a mission type change to all squadmates except the caller, with VO and organic delay.
        /// </summary>
        public static void BroadcastMissionType(BotOwner bot, MissionType mission)
        {
            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(bot) || bot.BotsGroup == null)
                    return;

                int count = bot.BotsGroup.MembersCount;
                for (int i = 0; i < count; i++)
                {
                    BotOwner mate = bot.BotsGroup.Member(i);
                    if (EFTPlayerUtil.IsValidBotOwner(mate) && mate != bot && mate.BotTalk != null)
                    {
                        float delay = Random.Range(0.15f, 0.45f);
                        Task.Run(async () =>
                        {
                            try
                            {
                                await Task.Delay((int)(delay * 1000f));
                                if (Random.value < 0.7f)
                                    mate.BotTalk.TrySay(EPhraseTrigger.Cooperation);
                            }
                            catch { }
                        });
                    }
                }
            }
            catch { }
        }

        /// <summary>
        /// Orders all valid squadmates to fallback to the given point, with organic delay.
        /// </summary>
        public void BroadcastFallback(Vector3 retreatPoint)
        {
            foreach (var pair in _combatMap)
            {
                BotOwner mate = pair.Key;
                CombatStateMachine fsm = pair.Value;

                if (EFTPlayerUtil.IsValidBotOwner(mate) && mate != _bot && fsm != null)
                {
                    float delay = Random.Range(0.10f, 0.28f);
                    TriggerDelayedFallback(fsm, retreatPoint, delay);
                }
            }
        }

        /// <summary>
        /// Organically coordinates movement to keep squad grouped, using jitter and repulsion.
        /// </summary>
        public void CoordinateMovement()
        {
            try
            {
                if (_bot == null || _bot.IsDead || _teammates.Count == 0)
                    return;

                Vector3 center = Vector3.zero;
                int count = 0;

                for (int i = 0; i < _teammates.Count; i++)
                {
                    BotOwner mate = _teammates[i];
                    if (EFTPlayerUtil.IsValidBotOwner(mate))
                    {
                        center += mate.Position;
                        count++;
                    }
                }

                if (count == 0)
                    return;

                center /= count;
                Vector3 jitter = Random.insideUnitSphere * RegroupJitterRadius;
                jitter.y = 0f;

                Vector3 target = center + jitter;
                if ((_bot.Position - target).sqrMagnitude > RegroupThresholdSqr)
                {
                    BotMovementHelper.SmoothMoveTo(_bot, target, false);
                }
            }
            catch { }
        }

        /// <summary>
        /// Registers a CombatStateMachine for a given squadmate (never for self).
        /// </summary>
        public void InjectCombatState(BotOwner mate, CombatStateMachine fsm)
        {
            try
            {
                if (EFTPlayerUtil.IsValidBotOwner(mate) && fsm != null && mate != _bot && !_combatMap.ContainsKey(mate))
                {
                    _combatMap.Add(mate, fsm);
                }
            }
            catch { }
        }

        /// <summary>
        /// Sets squadmates using pooling, based on groupId (excludes self).
        /// </summary>
        public void SetTeammates(List<BotOwner> allBots)
        {
            _teammates.Clear();
            try
            {
                Player self = _bot.GetPlayer;
                if (self?.Profile?.Info == null)
                    return;

                string groupId = self.Profile.Info.GroupId;
                if (string.IsNullOrEmpty(groupId))
                    return;

                for (int i = 0; i < allBots.Count; i++)
                {
                    BotOwner other = allBots[i];
                    if (EFTPlayerUtil.IsValidBotOwner(other) &&
                        other != _bot &&
                        other.GetPlayer?.Profile?.Info?.GroupId == groupId)
                    {
                        _teammates.Add(other);
                    }
                }
            }
            catch { }
        }

        /// <summary>
        /// Shares an enemy target with all valid squadmates, using organic delay.
        /// </summary>
        public void ShareTarget(IPlayer enemy)
        {
            try
            {
                if (enemy == null || string.IsNullOrEmpty(enemy.ProfileId))
                    return;

                Player resolved = EFTPlayerUtil.ResolvePlayerById(enemy.ProfileId);
                if (!EFTPlayerUtil.IsValid(resolved))
                    return;

                IPlayer safe = EFTPlayerUtil.AsSafeIPlayer(resolved);
                for (int i = 0; i < _teammates.Count; i++)
                {
                    BotOwner mate = _teammates[i];
                    if (EFTPlayerUtil.IsValidBotOwner(mate))
                    {
                        float delay = Random.Range(0.07f, 0.25f);
                        TriggerDelayedRegisterEnemy(mate, safe, delay);
                    }
                }
            }
            catch { }
        }

        #endregion

        #region Internal Helpers

        private static void ForceRegisterEnemy(BotOwner receiver, IPlayer enemy)
        {
            try
            {
                if (receiver.BotsGroup != null && !receiver.BotsGroup.IsEnemy(enemy))
                {
                    receiver.BotsGroup.AddEnemy(enemy, EBotEnemyCause.zryachiyLogic);
                }

                if (!receiver.EnemiesController.EnemyInfos.ContainsKey(enemy))
                {
                    var settings = new BotSettingsClass((Player)enemy, receiver.BotsGroup, EBotEnemyCause.zryachiyLogic);
                    receiver.Memory?.AddEnemy(enemy, settings, false);
                }
            }
            catch { }
        }

        private static void TriggerDelayedRegisterEnemy(BotOwner receiver, IPlayer enemy, float delay)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(receiver) || enemy == null)
                return;

            Task.Run(async () =>
            {
                try
                {
                    await Task.Delay((int)(delay * 1000f));
                    ForceRegisterEnemy(receiver, enemy);
                }
                catch { }
            });
        }

        private static void TriggerDelayedFallback(CombatStateMachine fsm, Vector3 point, float delay)
        {
            if (fsm == null)
                return;

            Task.Run(async () =>
            {
                try
                {
                    await Task.Delay((int)(delay * 1000f));
                    fsm.TriggerFallback(point);
                }
                catch { }
            });
        }

        #endregion
    }
}
