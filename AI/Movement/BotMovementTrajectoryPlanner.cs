// <auto-generated>
//   AI-Refactored: BotMovementTrajectoryPlanner.cs (Beyond Diamond, Ultra-Realism & Squad Intelligence)
//   Full human-squad movement flow, anticipation, chaos, inertia, role offset, avoidance, cover adaptation.
//   SYSTEMATICALLY MANAGED. No allocations, no null leaks, bulletproof error isolation, squad-perfect.
//   MIT License.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Navigation;
    using AIRefactored.AI.Optimization;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Produces ultra-realistic, organic, context-aware bot movement vectors.
    /// All output is a safe, normalized, non-NaN vector. Never sets position directly.
    /// </summary>
    public sealed class BotMovementTrajectoryPlanner
    {
        #region Constants

        private const float AvoidanceRadius = 2.18f;
        private const float AvoidanceScale = 1.33f;
        private const float ChaosIntervalMin = 0.32f;
        private const float ChaosIntervalMax = 0.59f;
        private const float ChaosRadius = 0.58f;
        private const float PanicChaosRadius = 0.92f;
        private const float CoverChaosScale = 0.5f;
        private const float SquadOffsetScale = 0.84f;
        private const float RoleOffsetMul = 0.45f;
        private const float VelocityFactor = 1.38f;
        private const float MinMagnitude = 0.0001f;
        private const float ChaosLerpSpeed = 4.3f;
        private const float AvoidanceMissChance = 0.065f;
        private const float AnticipationInterval = 0.44f;
        private const float AnticipationMagnitude = 0.15f;
        private const float JitterMicro = 0.014f;
        private const float FormationEdgeBias = 0.19f;
        private const float SuppressedChaosBonus = 0.44f;
        private const float AggressionSprintBias = 0.21f;
        private const float CoverAlignmentWeight = 0.25f;
        private const float StuckWobbleMagnitude = 0.41f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _chaosOffset;
        private Vector3 _targetChaosOffset;
        private float _nextChaosUpdate;

        private Vector3 _anticipationDir;
        private float _nextAnticipationTime;

        private float _lastSquadBiasTime;
        private Vector3 _squadFormationBias;

        #endregion

        #region Constructor

        public BotMovementTrajectoryPlanner(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null || bot.GetPlayer == null)
                throw new ArgumentException("[BotMovementTrajectoryPlanner] invalid arguments.");

            _bot = bot;
            _cache = cache;
            _chaosOffset = Vector3.zero;
            _targetChaosOffset = Vector3.zero;
            _anticipationDir = Vector3.zero;
            _squadFormationBias = Vector3.zero;
        }

        #endregion

        #region Public API

        public Vector3 ModifyTrajectory(Vector3 targetDir, float deltaTime)
        {
            try
            {
                float now = Time.unscaledTime;
                var profile = _cache.PersonalityProfile ?? BotPersonalityProfile.Default;
                float personalityCaution = Mathf.Clamp01(profile.Caution);
                float personalityAggro = Mathf.Clamp01(profile.AggressionLevel);

                Vector3 baseDir = (targetDir.sqrMagnitude > MinMagnitude) ? targetDir.normalized : Vector3.forward;
                Vector3 adjusted = baseDir;

                if (now > _nextChaosUpdate)
                    UpdateTargetChaosOffset(now, profile);

                _chaosOffset = Vector3.Lerp(_chaosOffset, _targetChaosOffset, deltaTime * ChaosLerpSpeed);
                _chaosOffset.y = 0f;
                adjusted += _chaosOffset;

                TryAnticipation(baseDir, now, ref adjusted);

                if (_cache.SquadPath != null)
                {
                    Vector3 squadOffset = _cache.SquadPath.GetCurrentOffset();
                    if (squadOffset.sqrMagnitude > MinMagnitude)
                    {
                        squadOffset.y = 0f;
                        adjusted += squadOffset.normalized * SquadOffsetScale;
                    }

                    if (now - _lastSquadBiasTime > 1.45f)
                    {
                        _squadFormationBias = UnityEngine.Random.insideUnitSphere * FormationEdgeBias;
                        _squadFormationBias.y = 0f;
                        _lastSquadBiasTime = now;
                    }

                    adjusted += _squadFormationBias;
                }

                Vector3 avoidVector = ComputeAvoidance();
                if (avoidVector.sqrMagnitude > MinMagnitude)
                {
                    avoidVector.y = 0f;
                    adjusted += avoidVector.normalized * AvoidanceScale;
                }

                if (_bot.BotsGroup != null && _bot.BotsGroup.MembersCount > 1)
                {
                    int idx = -1;
                    for (int i = 0; i < _bot.BotsGroup.MembersCount; i++)
                        if (_bot.BotsGroup.Member(i) == _bot) { idx = i; break; }

                    if (idx >= 0)
                    {
                        float posBias = ((idx % 2 == 0) ? -1f : 1f) * RoleOffsetMul;
                        Vector3 roleOffset = Vector3.Cross(Vector3.up, baseDir) * posBias;
                        adjusted += roleOffset;
                    }
                }

                if (_cache.CoverPlanner != null && _cache.CoverPlanner.IsInCover)
                {
                    Vector3 coverNormal = _cache.CoverPlanner.CoverNormal;
                    if (coverNormal == Vector3.zero)
                        coverNormal = _bot.Transform != null ? _bot.Transform.right : Vector3.right;

                    Vector3 coverAlign = Vector3.ProjectOnPlane(coverNormal.normalized, Vector3.up) * CoverAlignmentWeight;
                    adjusted += coverAlign;
                }

                Vector3 velocity = _bot.GetPlayer != null ? _bot.GetPlayer.Velocity : Vector3.zero;
                if (velocity.sqrMagnitude > MinMagnitude)
                {
                    velocity.y = 0f;
                    adjusted += velocity.normalized * VelocityFactor;
                }

                if ((_cache.PanicHandler?.IsPanicking ?? false) || (_cache.Suppression?.IsSuppressed() ?? false))
                {
                    adjusted += UnityEngine.Random.insideUnitSphere * SuppressedChaosBonus;
                    adjusted.y = 0f;
                }

                if (personalityAggro > 0.65f && UnityEngine.Random.value < AggressionSprintBias)
                    adjusted += baseDir * 0.13f * personalityAggro;

                adjusted += UnityEngine.Random.insideUnitSphere * JitterMicro;
                adjusted.y = 0f;

                if (_bot.Mover?.Blocked ?? false)
                    adjusted += UnityEngine.Random.insideUnitSphere * StuckWobbleMagnitude;

                return float.IsNaN(adjusted.x) || float.IsNaN(adjusted.y) || float.IsNaN(adjusted.z) || adjusted.sqrMagnitude < MinMagnitude
                    ? baseDir
                    : adjusted.normalized;
            }
            catch
            {
                return Vector3.forward;
            }
        }

        #endregion

        #region Internal Helpers

        private void UpdateTargetChaosOffset(float now, BotPersonalityProfile profile)
        {
            try
            {
                float chaosBase = ChaosRadius * (1f - Mathf.Clamp01(profile.Caution));
                float chaos = chaosBase;

                if (_cache.PanicHandler?.IsPanicking == true)
                    chaos += PanicChaosRadius;
                if (_cache.Suppression?.IsSuppressed() == true)
                    chaos += SuppressedChaosBonus;
                if (_cache.CoverPlanner?.IsInCover == true)
                    chaos *= CoverChaosScale;

                chaos = Mathf.Clamp(chaos, 0.01f, 1.22f);

                float x = UnityEngine.Random.Range(-chaos * 0.5f, chaos * 0.5f);
                float z = UnityEngine.Random.Range(0.1f, chaos);
                _targetChaosOffset = new Vector3(x, 0f, z);

                _nextChaosUpdate = now + UnityEngine.Random.Range(ChaosIntervalMin, ChaosIntervalMax);
            }
            catch
            {
                _targetChaosOffset = Vector3.zero;
                _nextChaosUpdate = now + UnityEngine.Random.Range(ChaosIntervalMin, ChaosIntervalMax);
            }
        }

        private void TryAnticipation(Vector3 baseDir, float now, ref Vector3 adjusted)
        {
            if (now < _nextAnticipationTime)
            {
                adjusted += _anticipationDir * AnticipationMagnitude;
                return;
            }

            float angle = Vector3.Angle(adjusted, baseDir);
            if (angle > 29f && UnityEngine.Random.value < 0.21f)
            {
                _anticipationDir = Quaternion.AngleAxis(UnityEngine.Random.Range(-13f, 13f), Vector3.up) * baseDir;
                _nextAnticipationTime = now + AnticipationInterval;
                adjusted += _anticipationDir * AnticipationMagnitude;
            }
        }

        private Vector3 ComputeAvoidance()
        {
            try
            {
                if (UnityEngine.Random.value < AvoidanceMissChance)
                    return Vector3.zero;

                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1)
                    return Vector3.zero;

                Vector3 self = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                int count = 0;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner other = group.Member(i);
                    if (other == null || other == _bot || other.IsDead)
                        continue;

                    Vector3 offset = self - other.Position;
                    float dist = offset.magnitude;
                    if (dist < AvoidanceRadius && dist > 0.01f)
                    {
                        offset.y = 0f;
                        repulsion += offset.normalized / dist;
                        count++;
                    }
                }

                return count > 0 ? repulsion / count : Vector3.zero;
            }
            catch
            {
                return Vector3.zero;
            }
        }

        #endregion
    }
}
