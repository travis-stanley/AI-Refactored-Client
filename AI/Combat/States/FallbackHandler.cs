// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI, never enters terminal state.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using UnityEngine;
    using UnityEngine.AI;

    /// <summary>
    /// Handles suppression fallback, retreat routing, and cover movement during engagements.
    /// Bulletproof: All errors are locally isolated, never disables itself, never triggers fallback AI, never enters terminal state.
    /// </summary>
    public sealed class FallbackHandler : IDisposable
    {
        private const float MinArrivalDistance = 0.1f;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly List<Vector3> _currentFallbackPath;
        private Vector3 _fallbackTarget;

        public FallbackHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _fallbackTarget = _bot != null ? _bot.Position : Vector3.zero;
            _currentFallbackPath = TempListPool.Rent<Vector3>();
        }

        public Vector3 GetFallbackPosition() => _fallbackTarget;

        public Vector3 GetFallbackPositionOrDefault(Vector3 defaultPos)
        {
            return HasValidFallbackPath() ? _fallbackTarget : defaultPos;
        }

        public bool HasValidFallbackPath()
        {
            return _currentFallbackPath.Count >= 2 && IsVectorValid(_fallbackTarget);
        }

        public void SetFallbackTarget(Vector3 target)
        {
            if (!IsVectorValid(target))
            {
                Plugin.LoggerInstance.LogWarning("[FallbackHandler] Ignored fallback target with invalid vector.");
                return;
            }
            _fallbackTarget = target;
        }

        public void SetFallbackPath(List<Vector3> path)
        {
            // Silently ignore too-short or invalid paths
            if (path == null || path.Count < 2)
            {
                return;
            }

            _currentFallbackPath.Clear();
            for (int i = 0; i < path.Count; i++)
            {
                Vector3 point = path[i];
                if (IsVectorValid(point))
                    _currentFallbackPath.Add(point);
            }

            if (_currentFallbackPath.Count >= 2)
            {
                _fallbackTarget = _currentFallbackPath[_currentFallbackPath.Count - 1];
            }
            else
            {
                // Do not log: final fallback path was invalid
            }
        }

        public bool ShallUseNow(float time)
        {
            return _bot != null &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        public bool ShouldTriggerSuppressedFallback(float now, float lastStateChangeTime, float minStateDuration)
        {
            return _cache?.Suppression?.IsSuppressed() == true &&
                   (now - lastStateChangeTime) >= minStateDuration;
        }

        public void Tick(float time, Action<CombatState, float> forceState)
        {
            if (_bot == null || !IsVectorValid(_fallbackTarget))
                return;

            try
            {
                Player player = _bot.GetPlayer;
                if (!EFTPlayerUtil.IsValid(player))
                    return;

                Vector3 fallbackPoint = _fallbackTarget;
                if (!BotNavHelper.TryGetSafeTarget(_bot, out fallbackPoint) || !IsVectorValid(fallbackPoint))
                {
                    fallbackPoint = GetSafeRandomFallback(_bot.Position);
                }

                if (_bot.Mover != null)
                {
                    try
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, fallbackPoint);
                        BotCoverHelper.TrySetStanceFromNearbyCover(_cache, fallbackPoint);
                    }
                    catch (Exception ex)
                    {
                        Plugin.LoggerInstance.LogError($"[FallbackHandler] SmoothMoveTo/stance logic failed: {ex}");
                    }
                }

                if (Vector3.Distance(_bot.Position, fallbackPoint) < MinArrivalDistance)
                {
                    forceState?.Invoke(CombatState.Patrol, time);

                    if (!FikaHeadlessDetector.IsHeadless && _bot.BotTalk != null)
                    {
                        try { _bot.BotTalk.TrySay(EPhraseTrigger.NeedHelp); }
                        catch { }
                    }
                }
            }
            catch (Exception ex)
            {
                Plugin.LoggerInstance.LogError($"[FallbackHandler] General Tick exception: {ex}");
            }
        }

        public bool IsActive()
        {
            return _bot != null &&
                   EFTPlayerUtil.IsValid(_bot.GetPlayer) &&
                   IsVectorValid(_fallbackTarget) &&
                   Vector3.Distance(_bot.Position, _fallbackTarget) > MinArrivalDistance;
        }

        public void Cancel()
        {
            _fallbackTarget = _bot != null ? _bot.Position : Vector3.zero;
            _currentFallbackPath.Clear();
        }

        public void Dispose()
        {
            TempListPool.Return(_currentFallbackPath);
        }

        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) &&
                   !float.IsNaN(v.y) &&
                   !float.IsNaN(v.z) &&
                   v != Vector3.zero;
        }

        /// <summary>
        /// Returns a random valid fallback position using only internal EFT/Unity logic, never PathController.
        /// </summary>
        private Vector3 GetSafeRandomFallback(Vector3 origin)
        {
            // Use PatrollingData.CurTargetPoint if valid and not too close.
            if (_bot != null && _bot.PatrollingData != null)
            {
                Vector3 curPatrolTarget = _bot.PatrollingData.CurTargetPoint;
                if (IsVectorValid(curPatrolTarget) && Vector3.Distance(curPatrolTarget, origin) > 1.0f)
                    return curPatrolTarget;
            }

            // Otherwise, use NavMesh to sample a nearby point.
            Vector3 candidate = origin + UnityEngine.Random.onUnitSphere * 2.0f;
            candidate.y = origin.y;

            NavMeshHit hit;
            if (NavMesh.SamplePosition(candidate, out hit, 2.5f, NavMesh.AllAreas))
                candidate = hit.position;

            return IsVectorValid(candidate) ? candidate : origin + Vector3.forward * 0.25f;
        }
    }
}
