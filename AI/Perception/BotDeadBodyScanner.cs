// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Looting
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using AIRefactored.Pools;
    using EFT;
    using EFT.Interactive;
    using EFT.InventoryLogic;
    using UnityEngine;

    /// <summary>
    /// Opportunistically loots dead enemies by checking proximity, visibility, and internal corpse memory cache.
    /// Aligns with EFT's native BotDeadBodyWork and DeadBodiesController behavior.
    /// </summary>
    public sealed class BotDeadBodyScanner
    {
        private const float LootCooldown = 10f;
        private const float LootMemoryDuration = 15f;
        private const float MaxLootAngle = 120f;
        private const float RaycastPadding = 0.3f;
        private const float ScanRadius = 12f;
        private const float MaxContainerDistance = 0.75f;

        private static readonly Dictionary<string, float> LootTimestamps = new Dictionary<string, float>(32);
        private static readonly HashSet<string> RecentlyLooted = new HashSet<string>();

        private BotOwner _bot;
        private BotComponentCache _cache;
        private float _nextScanTime;

        /// <summary>
        /// One-time scan to pair dead players with nearby lootable containers.
        /// </summary>
        public static void ScanAll()
        {
            if (!GameWorldHandler.IsSafeToInitialize)
            {
                return;
            }

            List<LootableContainer> containers = LootRegistry.GetAllContainers();
            GameWorld world = GameWorldHandler.Get();
            if (world == null || world.RegisteredPlayers == null)
            {
                return;
            }

            List<IPlayer> rawPlayers = world.RegisteredPlayers;
            List<Player> deadPlayers = TempListPool.Rent<Player>();

            for (int i = 0; i < rawPlayers.Count; i++)
            {
                Player p = EFTPlayerUtil.AsEFTPlayer(rawPlayers[i]);
                if (p != null && !p.HealthController.IsAlive)
                {
                    deadPlayers.Add(p);
                }
            }

            for (int i = 0; i < containers.Count; i++)
            {
                LootableContainer container = containers[i];
                if (container == null)
                {
                    continue;
                }

                Vector3 containerPos = container.transform.position;

                for (int j = 0; j < deadPlayers.Count; j++)
                {
                    Player player = deadPlayers[j];
                    if (string.IsNullOrEmpty(player.ProfileId) || DeadBodyContainerCache.Contains(player.ProfileId))
                    {
                        continue;
                    }

                    float dist = Vector3.Distance(player.Transform.position, containerPos);
                    if (dist <= MaxContainerDistance)
                    {
                        DeadBodyContainerCache.Register(player, container);
                        break;
                    }
                }
            }

            TempListPool.Return(deadPlayers);
        }

        /// <summary>
        /// Clears all static loot/corpse memory caches. Should be called on world/raid end.
        /// </summary>
        public static void ClearStaticState()
        {
            LootTimestamps.Clear();
            RecentlyLooted.Clear();
        }

        /// <summary>
        /// Initializes the scanner for a specific bot and its cache.
        /// </summary>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null || cache.Bot == null)
            {
                return;
            }

            BotOwner resolved = cache.Bot.GetComponent<BotOwner>();
            if (resolved == null)
            {
                return;
            }

            _bot = resolved;
            _cache = cache;
        }

        /// <summary>
        /// Ticks looting logic. Called each frame with current time.
        /// </summary>
        public void Tick(float time)
        {
            if (time < _nextScanTime || !IsReady())
            {
                return;
            }

            _nextScanTime = time + LootCooldown;
            TryLootOnce();
        }

        /// <summary>
        /// Immediately attempts to loot a nearby corpse if ready.
        /// </summary>
        public void TryLootNearby()
        {
            if (IsReady())
            {
                TryLootOnce();
            }
        }

        private bool IsReady()
        {
            return _bot != null
                && !_bot.IsDead
                && EFTPlayerUtil.IsValid(_bot.GetPlayer)
                && _cache != null
                && _cache.PanicHandler != null
                && !_cache.PanicHandler.IsPanicking;
        }

        private void TryLootOnce()
        {
            Player corpse = FindLootableCorpse();
            if (!EFTPlayerUtil.IsValid(corpse))
            {
                return;
            }

            string profileId = corpse.ProfileId;
            if (string.IsNullOrEmpty(profileId))
            {
                return;
            }

            LootCorpse(corpse);
            RememberLooted(profileId);
        }

        private Player FindLootableCorpse()
        {
            if (_bot == null || _bot.Transform == null)
                return null;

            Vector3 origin = _bot.Transform.position;
            Vector3 forward = (_bot.WeaponRoot != null) ? _bot.WeaponRoot.forward : _bot.Transform.forward;

            List<Player> players = TempListPool.Rent<Player>();
            players.AddRange(GameWorldHandler.GetAllAlivePlayers());
            for (int i = 0; i < players.Count; i++)
            {
                Player candidate = players[i];
                if (!IsValidCorpse(candidate))
                {
                    continue;
                }

                Vector3 toCorpse = candidate.Transform.position - origin;
                float distance = toCorpse.magnitude;

                if (distance > ScanRadius || Vector3.Angle(forward, toCorpse.normalized) > MaxLootAngle)
                {
                    continue;
                }

                if (!HasLineOfSight(origin, toCorpse, distance, candidate))
                {
                    continue;
                }

                TempListPool.Return(players);
                return candidate;
            }

            TempListPool.Return(players);
            return null;
        }

        private bool IsValidCorpse(Player player)
        {
            return EFTPlayerUtil.IsValid(player)
                && !player.HealthController.IsAlive
                && player != _bot.GetPlayer
                && player.ProfileId.Length > 0
                && !WasLootedRecently(player.ProfileId);
        }

        private bool HasLineOfSight(Vector3 origin, Vector3 direction, float distance, Player corpse)
        {
            Ray ray = new Ray(origin, direction.normalized);
            if (!Physics.Raycast(ray, out RaycastHit hit, distance + RaycastPadding, AIRefactoredLayerMasks.HighPolyWithTerrainMaskAI))
            {
                return false;
            }

            Transform hitRoot = hit.collider.transform.root;
            Transform corpseRoot = corpse.Transform.Original.root;

            return hitRoot == corpseRoot;
        }

        private void LootCorpse(Player corpse)
        {
            InventoryController source = corpse.InventoryController;
            InventoryController target = _bot.GetPlayer.InventoryController;

            if (source == null || target == null)
            {
                return;
            }

            LootableContainer container = DeadBodyContainerCache.Get(corpse.ProfileId);
            if (container != null && container.enabled)
            {
                container.Interact(new InteractionResult(EInteractionType.Open));
                return;
            }

            TryStealBestItem(source, target);
        }

        private void TryStealBestItem(InventoryController source, InventoryController target)
        {
            EquipmentSlot[] prioritySlots =
            {
                EquipmentSlot.FirstPrimaryWeapon,
                EquipmentSlot.SecondPrimaryWeapon,
                EquipmentSlot.Holster,
                EquipmentSlot.TacticalVest,
                EquipmentSlot.Backpack,
                EquipmentSlot.Pockets
            };

            for (int i = 0; i < prioritySlots.Length; i++)
            {
                Item item = source.Inventory.Equipment.GetSlot(prioritySlots[i]).ContainedItem;
                if (item == null)
                {
                    continue;
                }

                ItemAddress destination = target.FindSlotToPickUp(item);
                if (destination == null)
                {
                    continue;
                }

                if (InteractionsHandlerClass.Move(item, destination, target, true).Succeeded)
                {
                    return;
                }
            }
        }

        private void RememberLooted(string profileId)
        {
            RecentlyLooted.Add(profileId);
            LootTimestamps[profileId] = Time.time;
        }

        private bool WasLootedRecently(string profileId)
        {
            float lastTime;
            return LootTimestamps.TryGetValue(profileId, out lastTime)
                && (Time.time - lastTime < LootMemoryDuration);
        }
    }
}
