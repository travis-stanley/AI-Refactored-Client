// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Bulletproof: All failures are locally contained, never break other subsystems, and always trigger fallback isolation.
//   See: AIRefactored “Bulletproof Fallback & Isolation Safety Rule Set” for audit compliance.
// </auto-generated>

namespace AIRefactored.Bootstrap
{
    using System;

    /// <summary>
    /// Tracks the phased lifecycle of world initialization.
    /// Allows AI systems to branch logic based on current state.
    /// Fully bulletproof: no invalid state transitions or exceptions allowed.
    /// </summary>
    public static class WorldInitState
    {
        private static WorldPhase _phase = WorldPhase.None;

        /// <summary>
        /// Gets the current world initialization phase.
        /// </summary>
        public static WorldPhase Current => _phase;

        /// <summary>
        /// Sets the current initialization phase.
        /// Bulletproof: Logs and ignores invalid transitions.
        /// </summary>
        /// <param name="phase">The phase to assign.</param>
        public static void SetPhase(WorldPhase phase)
        {
            if (phase < WorldPhase.None || phase > WorldPhase.PostInit)
            {
                Plugin.LoggerInstance.LogWarning("[WorldInitState] Invalid phase assignment attempt: " + phase);
                return;
            }

            // Optionally: Prevent backwards transitions unless explicitly Reset()
            if (phase < _phase && phase != WorldPhase.None)
            {
                Plugin.LoggerInstance.LogWarning("[WorldInitState] Ignored backward phase transition: " + _phase + " -> " + phase);
                return;
            }

            _phase = phase;
        }

        /// <summary>
        /// Returns true if the current world phase is equal to or beyond the specified phase.
        /// </summary>
        /// <param name="phase">The phase to compare against.</param>
        /// <returns>True if the current phase is equal or greater than the specified phase.</returns>
        public static bool IsInPhase(WorldPhase phase)
        {
            return _phase >= phase;
        }

        /// <summary>
        /// Returns true if the world has completed all initialization phases.
        /// </summary>
        public static bool IsInitialized => _phase == WorldPhase.PostInit;

        /// <summary>
        /// Resets the phase tracker to its default uninitialized state.
        /// </summary>
        public static void Reset()
        {
            _phase = WorldPhase.None;
        }
    }

    /// <summary>
    /// Represents the current stage in the world initialization lifecycle.
    /// Used to coordinate system boot timing and enforce safe init entry points.
    /// </summary>
    public enum WorldPhase
    {
        /// <summary>
        /// Startup has not begun.
        /// </summary>
        None = 0,

        /// <summary>
        /// Pre-initialization logic is running (before GameWorld detection).
        /// </summary>
        PreInit = 1,

        /// <summary>
        /// Awaiting GameWorld readiness or player presence.
        /// </summary>
        AwaitWorld = 2,

        /// <summary>
        /// GameWorld is ready and world systems may begin setup.
        /// </summary>
        WorldReady = 3,

        /// <summary>
        /// All systems are fully initialized and the game is in active runtime state.
        /// </summary>
        PostInit = 4
    }
}
