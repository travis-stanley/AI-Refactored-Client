// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI, never break the stack.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Reactions
{
    using System;
    using AIRefactored.AI.Combat;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles bot reactions to intense light exposure (e.g., flashlights or flashbangs).
    /// Applies suppression, triggers scored fallback movement, and panic if threshold reached.
    /// </summary>
    public sealed class BotFlashReactionComponent
    {
        #region Constants

        private const float FallbackDistance = 5f;
        private const float FallbackJitter = 1.25f;
        private const float MaxSuppressionDuration = 5f;
        private const float MinSuppressionDuration = 1f;
        private const float ReactionCooldown = 0.5f;
        private const float TriggerIntensityThreshold = 0.35f;

        #endregion

        #region Fields

        private BotComponentCache _cache;
        private float _lastTriggerTime = -1f;
        private float _suppressedUntil = -1f;
        private bool _failed;

        #endregion

        #region Initialization

        /// <summary>
        /// Links this flash reaction handler to the active bot's shared component cache.
        /// </summary>
        /// <param name="cache">Bot component cache for this bot (never null).</param>
        public void Initialize(BotComponentCache cache)
        {
            try
            {
                _cache = cache ?? throw new ArgumentNullException(nameof(cache));
                _failed = false;
            }
            catch (Exception ex)
            {
                _cache = null;
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotFlashReactionComponent] Initialize exception: {ex}");
            }
        }

        #endregion

        #region Runtime

        /// <summary>
        /// Returns true if the bot is still suppressed from a flash reaction.
        /// </summary>
        public bool IsSuppressed()
        {
            return !_failed && Time.time < _suppressedUntil;
        }

        /// <summary>
        /// Called every frame from BotBrain. Updates suppression state and performs exposure checks.
        /// </summary>
        /// <param name="time">Current time value from caller.</param>
        public void Tick(float time)
        {
            if (_failed || _cache == null || _cache.Bot == null)
            {
                return;
            }

            try
            {
                if (time >= _suppressedUntil)
                {
                    _suppressedUntil = -1f;
                }

                Transform head = BotCacheUtility.Head(_cache);
                if (head == null)
                {
                    return;
                }

                var lights = FlashlightRegistry.GetLastKnownFlashlightPositions();
                for (int i = 0, count = lights.Count; i < count; i++)
                {
                    if (FlashlightRegistry.IsExposingBot(head, out Light light) && light != null)
                    {
                        float score = FlashLightUtils.CalculateFlashScore(light.transform, head, 20f);
                        if (score >= TriggerIntensityThreshold)
                        {
                            TriggerSuppression(score);
                            return;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotFlashReactionComponent] Tick exception: {ex}");
            }
        }

        /// <summary>
        /// Triggers suppression, fallback, and panic based on light strength and composure.
        /// </summary>
        /// <param name="strength">Intensity of the flash, [0,1] range is normal.</param>
        public void TriggerSuppression(float strength = 0.6f)
        {
            if (_failed || _cache == null || _cache.Bot == null)
            {
                return;
            }

            try
            {
                BotOwner bot = _cache.Bot;
                if (bot.IsDead)
                {
                    return;
                }

                Player player = bot.GetPlayer;
                if (player == null || !player.IsAI || player.IsYourPlayer)
                {
                    return;
                }

                float now = Time.time;
                if (now - _lastTriggerTime < ReactionCooldown)
                {
                    return;
                }

                _lastTriggerTime = now;

                float composure = 1f;
                if (_cache.PanicHandler != null)
                {
                    composure = _cache.PanicHandler.GetComposureLevel();
                }

                float scaled = Mathf.Clamp01(strength) * composure;
                float duration = Mathf.Lerp(MinSuppressionDuration, MaxSuppressionDuration, scaled);
                _suppressedUntil = now + duration;

                TriggerFallback(bot);
                TriggerPanic(_cache);
            }
            catch (Exception ex)
            {
                _failed = true;
                Plugin.LoggerInstance.LogError($"[BotFlashReactionComponent] TriggerSuppression exception: {ex}");
            }
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Calculates and executes bot fallback movement due to flash suppression.
        /// Uses only EFT-native navigation; falls back to vanilla AI if path fails.
        /// </summary>
        private static void TriggerFallback(BotOwner bot)
        {
            try
            {
                if (bot == null)
                    return;

                Vector3 dir = bot.LookDirection;
                Vector3 fallback = bot.Position - dir.normalized * FallbackDistance;
                fallback += UnityEngine.Random.insideUnitSphere * FallbackJitter;
                fallback.y = bot.Position.y;

                if (!BotMovementHelper.SmoothMoveToSafe(bot, fallback))
                {
                    BotFallbackUtility.FallbackToEFTLogic(bot);
                }
            }
            catch
            {
                if (bot != null)
                    BotFallbackUtility.FallbackToEFTLogic(bot);
            }
        }

        /// <summary>
        /// Triggers bot panic event if a valid panic handler is present.
        /// </summary>
        private static void TriggerPanic(BotComponentCache cache)
        {
            try
            {
                if (BotPanicUtility.TryGetPanicComponent(cache, out BotPanicHandler panic))
                {
                    panic.TriggerPanic();
                }
            }
            catch { }
        }

        #endregion
    }
}
