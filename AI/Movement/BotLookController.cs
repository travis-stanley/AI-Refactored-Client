// <auto-generated>
//   AI-Refactored. Human-Like Look/Aim Controller. MIT License.
//   SYSTEMATICALLY MANAGED. No fallback logic, no direct transform assignment outside controlled tick.
//   Realism: multi-frame inertia, anticipation/overshoot, micro-jitter, environmental fidget, squad integration.
//   100% BotBrain managed. Multiplayer, headless, bulletproof.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Perception;
    using AIRefactored.Core;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles all look/aim logic: multi-frame, inertia, fidget, group/squad context.
    /// Bulletproof: no fallback, all errors are isolated and never break bot/squad.
    /// </summary>
    public sealed class BotLookController
    {
        #region Constants

        private const float MaxTurnSpeed = 8.4f;           // Degrees/ms
        private const float MaxAnglePerFrame = 42f;        // Yaw per frame
        private const float MinLookDistanceSqr = 0.22f;
        private const float BlindLookRadius = 4.15f;
        private const float HeardDirectionWeight = 7.1f;
        private const float SoundMemoryDuration = 3.7f;
        private const float IdleScanInterval = 2.65f;
        private const float IdleScanAngleMax = 65.5f;
        private const float IdleScanJitter = 7.6f;
        private const float IdleMissChance = 0.032f;
        private const float MissAngleMax = 8.5f;
        private const float InertiaAcceleration = 0.15f;
        private const float AnticipationFactor = 0.21f;
        private const float HesitationDuration = 0.13f;
        private const float FidgetPauseChance = 0.07f;
        private const float FidgetDurationMin = 0.10f, FidgetDurationMax = 0.21f;
        private const float OvershootDecay = 0.78f;
        private const float ScanResetChance = 0.12f;
        private const float LootingHeadSweepMax = 19.5f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotGroupComms _groupComms;

        private Vector3 _fallbackLookTarget;
        private bool _frozen;

        private float _currentYaw;
        private float _lookVelocity;
        private float _lastYawSign;
        private float _nextHesitateTime;

        private float _nextIdleScanTime;
        private float _currentIdleAngle;
        private int _idleScanDirection;
        private float _idleJitterOffset;

        private bool _inFidgetPause;
        private float _fidgetPauseUntil;

        private float _overshootAngle;
        private float _overshootDecayRate;

        // Looting/scan
        private float _nextLootSweepTime;
        private float _lootingSweepAngle;

        #endregion

        #region Constructor

        public BotLookController(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null)
            {
                Logger.LogError("[BotLookController] Constructor failed — null bot or cache.");
                throw new ArgumentException("Invalid BotLookController parameters.");
            }

            _bot = bot;
            _cache = cache;
            _groupComms = cache.GroupComms;

            _fallbackLookTarget = bot.Position + bot.LookDirection;

            var player = EFTPlayerUtil.ResolvePlayer(bot);
            var body = EFTPlayerUtil.GetTransform(player);
            _currentYaw = (body != null) ? body.rotation.eulerAngles.y : 0f;
            _lookVelocity = 0f;
            _lastYawSign = 0f;
            _nextHesitateTime = 0f;
            _nextIdleScanTime = Time.time + UnityEngine.Random.Range(0.8f, 2.5f);
            _currentIdleAngle = 0f;
            _idleScanDirection = UnityEngine.Random.value > 0.5f ? 1 : -1;
            _idleJitterOffset = UnityEngine.Random.Range(-IdleScanJitter, IdleScanJitter);
            _inFidgetPause = false;
            _fidgetPauseUntil = 0f;
            _overshootAngle = 0f;
            _overshootDecayRate = 0f;

            _nextLootSweepTime = 0f;
            _lootingSweepAngle = 0f;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Main tick: handles look inertia, anticipation, fidget, idle/looting scanning.
        /// </summary>
        public void Tick(float deltaTime)
        {
            try
            {
                if (_frozen || _bot == null || _cache == null || _bot.IsDead || !GameWorldHandler.IsSafeToInitialize)
                    return;

                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (!EFTPlayerUtil.IsValid(player))
                    return;

                Transform body = EFTPlayerUtil.GetTransform(player);
                if (body == null)
                    return;

                Vector3 origin = body.position;
                Vector3 lookTarget = ResolveLookTarget(origin, deltaTime);

                Vector3 lookDir = lookTarget - origin;
                lookDir.y = 0f;
                if (lookDir.sqrMagnitude < MinLookDistanceSqr)
                    return;

                float actualYaw = body.rotation.eulerAngles.y;
                _currentYaw = actualYaw;

                float targetYaw = Mathf.Atan2(lookDir.x, lookDir.z) * Mathf.Rad2Deg;
                float yawDiff = Mathf.DeltaAngle(_currentYaw, targetYaw);
                float desiredSign = Mathf.Sign(yawDiff);

                // Anticipation/overshoot when changing directions
                if (_lastYawSign != 0f && Mathf.Sign(_lastYawSign) != desiredSign && Mathf.Abs(yawDiff) > 18f)
                {
                    if (Time.time < _nextHesitateTime)
                        return;
                    _nextHesitateTime = Time.time + HesitationDuration + UnityEngine.Random.Range(0.04f, 0.10f);
                    _overshootAngle = AnticipationFactor * desiredSign * Mathf.Min(Mathf.Abs(yawDiff), 31f);
                    _overshootDecayRate = OvershootDecay;
                }

                _lastYawSign = desiredSign;

                // Random micro-pauses/fidget
                if (!_inFidgetPause && UnityEngine.Random.value < FidgetPauseChance)
                {
                    _fidgetPauseUntil = Time.time + UnityEngine.Random.Range(FidgetDurationMin, FidgetDurationMax);
                    _inFidgetPause = true;
                    if (UnityEngine.Random.value < 0.12f)
                        _groupComms?.Say(EPhraseTrigger.Look);
                }
                if (_inFidgetPause)
                {
                    if (Time.time < _fidgetPauseUntil) return;
                    _inFidgetPause = false;
                }

                // Overshoot
                if (_overshootAngle != 0f)
                {
                    yawDiff += _overshootAngle;
                    _overshootAngle *= _overshootDecayRate;
                    if (Mathf.Abs(_overshootAngle) < 1.2f)
                        _overshootAngle = 0f;
                }

                // Inertia (multi-frame angular acceleration)
                _lookVelocity += yawDiff * InertiaAcceleration * deltaTime;
                _lookVelocity = Mathf.Clamp(_lookVelocity, -MaxTurnSpeed, MaxTurnSpeed);

                float deltaYaw = _lookVelocity * deltaTime * 60f;
                float clampedDeltaYaw = Mathf.Clamp(deltaYaw, -MaxAnglePerFrame, MaxAnglePerFrame);
                float newYaw = Mathf.Repeat(_currentYaw + clampedDeltaYaw, 360f);
                _currentYaw = newYaw;

                // Final application
                Quaternion targetRotation = Quaternion.Euler(0f, _currentYaw, 0f);
                body.rotation = targetRotation;
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotLookController] Tick failed: " + ex);
            }
        }

        /// <summary>
        /// Sets fallback look target, used when no explicit target.
        /// </summary>
        public void SetLookTarget(Vector3 worldPos)
        {
            try
            {
                if (IsValid(worldPos))
                {
                    _fallbackLookTarget = worldPos;
                }
            }
            catch (Exception ex)
            {
                Logger.LogError("[BotLookController] SetLookTarget failed: " + ex);
            }
        }

        public void FreezeLook() { _frozen = true; }
        public void ResumeLook() { _frozen = false; }

        public Vector3 GetLookDirection()
        {
            try
            {
                return _bot != null ? _bot.LookDirection : Vector3.forward;
            }
            catch { return Vector3.forward; }
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Determines what the bot should be looking at, depending on tactical/loot context.
        /// </summary>
        private Vector3 ResolveLookTarget(Vector3 origin, float deltaTime)
        {
            float now = Time.time;

            // 1. Blinded: random scan
            if (_cache != null && _cache.IsBlinded && now < _cache.BlindUntilTime)
            {
                Vector3 offset = UnityEngine.Random.insideUnitSphere;
                offset.y = 0f;
                return origin + offset.normalized * BlindLookRadius;
            }

            // 2. Panic: look at last heard sound or default forward
            if (_cache?.Panic?.IsPanicking == true)
            {
                if (_cache.HasHeardDirection)
                    return origin + _cache.LastHeardDirection.normalized * HeardDirectionWeight;
                return origin + _bot.LookDirection;
            }

            // 3. Combat/Target: look at enemy, with micro-miss
            if (_cache?.ThreatSelector != null && _cache.VisibilityTracker != null)
            {
                string id = _cache.ThreatSelector.GetTargetProfileId();
                if (!string.IsNullOrEmpty(id))
                {
                    Player enemy = EFTPlayerUtil.ResolvePlayerById(id);
                    if (EFTPlayerUtil.IsValid(enemy) && _cache.VisibilityTracker.CanSeeAny())
                    {
                        Vector3 pos = EFTPlayerUtil.GetPosition(enemy);
                        if (UnityEngine.Random.value < 0.32f)
                        {
                            float miss = UnityEngine.Random.Range(-MissAngleMax, MissAngleMax);
                            Quaternion missQ = Quaternion.AngleAxis(miss, Vector3.up);
                            Vector3 fwd = pos - origin; fwd.y = 0f;
                            pos = origin + (missQ * fwd.normalized) * (fwd.magnitude);
                        }
                        return pos;
                    }
                }
            }

            // 4. Heard sound: look at recent sound direction
            if (_cache != null && _cache.HasHeardDirection && now - _cache.LastHeardTime < SoundMemoryDuration)
            {
                return origin + _cache.LastHeardDirection.normalized * HeardDirectionWeight;
            }

            // 5. Looting: sweep head left/right at loot point, then pause and fidget
            if (_cache.LootScanner != null && _cache.Movement != null && _cache.Movement.IsInLootingMode())
            {
                if (now > _nextLootSweepTime)
                {
                    float sweep = UnityEngine.Random.Range(-LootingHeadSweepMax, LootingHeadSweepMax);
                    _lootingSweepAngle = sweep;
                    _nextLootSweepTime = now + UnityEngine.Random.Range(0.6f, 1.3f);
                }

                Quaternion lootYaw = Quaternion.AngleAxis(_lootingSweepAngle, Vector3.up);
                Vector3 lootLook = lootYaw * _bot.LookDirection.normalized;
                return origin + lootLook * 2.2f;
            }

            // 6. Idle/scan: smooth head scanning with jitter and organic reset
            if (now > _nextIdleScanTime || UnityEngine.Random.value < ScanResetChance)
            {
                _idleScanDirection = UnityEngine.Random.value > 0.5f ? 1 : -1;
                _nextIdleScanTime = now + IdleScanInterval + UnityEngine.Random.Range(-0.7f, 0.9f);
                _idleJitterOffset = UnityEngine.Random.Range(-IdleScanJitter, IdleScanJitter);
                if (UnityEngine.Random.value < 0.16f)
                    _currentIdleAngle = 0f; // Snap reset for realism
            }
            if (UnityEngine.Random.value < IdleMissChance)
                _currentIdleAngle += UnityEngine.Random.Range(-5.8f, 6.1f);

            float baseAngle = IdleScanAngleMax * _idleScanDirection * deltaTime * 0.48f;
            _currentIdleAngle = Mathf.Clamp(_currentIdleAngle + baseAngle + _idleJitterOffset * deltaTime * 0.12f, -IdleScanAngleMax, IdleScanAngleMax);

            Vector3 fwdDir = _bot.LookDirection.sqrMagnitude > 0.5f ? _bot.LookDirection.normalized : Vector3.forward;
            Quaternion idleYaw = Quaternion.AngleAxis(_currentIdleAngle, Vector3.up);
            Vector3 idleLook = idleYaw * fwdDir;

            return origin + idleLook * BlindLookRadius;
        }

        private static bool IsValid(Vector3 pos)
        {
            return !float.IsNaN(pos.x) && !float.IsNaN(pos.y) && !float.IsNaN(pos.z);
        }

        #endregion
    }
}
