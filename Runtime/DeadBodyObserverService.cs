// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   All errors are strictly contained, never cascade or break the mod. No fallback/terminal bot logic.
// </auto-generated>

namespace AIRefactored.Runtime
{
	using System;
	using System.Collections.Generic;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Looting;
	using AIRefactored.AI.Navigation;
	using AIRefactored.Bootstrap;
	using AIRefactored.Core;
	using AIRefactored.Pools;
	using BepInEx.Logging;
	using EFT;
	using EFT.Interactive;
	using UnityEngine;

	/// <summary>
	/// Observes dead players and ensures their lootable containers are associated in DeadBodyContainerCache.
	/// All errors are contained; never breaks the mod; never triggers fallback or terminal bot logic.
	/// </summary>
	public sealed class DeadBodyObserverService : IAIWorldSystemBootstrapper
	{
		private const float ScanIntervalSeconds = 1.0f;
		private const float AssociationRadius = 1.5f;

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static float _nextScanTime = -1f;
		private static bool _hasLoggedReset;

		public void Initialize()
		{
			try
			{
				Reset();
				_hasLoggedReset = false;
				LogDebug("[DeadBodyObserver] ✅ Initialized.");
			}
			catch (Exception ex)
			{
				LogError("[DeadBodyObserver] ❌ Initialize failed: " + ex);
			}
		}

		public void OnRaidEnd()
		{
			try
			{
				Reset();
				LogDebug("[DeadBodyObserver] 🧹 Reset after raid.");
			}
			catch (Exception ex)
			{
				LogError("[DeadBodyObserver] ❌ OnRaidEnd error: " + ex);
			}
		}

		public bool IsReady() => true;

		public WorldPhase RequiredPhase() => WorldPhase.WorldReady;

		public static void Reset()
		{
			if (_hasLoggedReset)
				return;

			_nextScanTime = -1f;
			_hasLoggedReset = true;

			try
			{
				LogDebug("[DeadBodyObserver] 🔄 Reset complete.");
			}
			catch { }
		}

		public void Tick(float deltaTime)
		{
			try
			{
				if (!Application.isPlaying || !GameWorldHandler.IsInitialized || !GameWorldHandler.IsHost || !GameWorldHandler.IsReady())
					return;

				float now = Time.time;
				if (now < _nextScanTime)
					return;

				_nextScanTime = now + ScanIntervalSeconds;

				GameWorld world = GameWorldHandler.Get();
				if (world == null || world.RegisteredPlayers == null || world.RegisteredPlayers.Count == 0)
					return;

				LootableContainer[] containers = UnityEngine.Object.FindObjectsOfType<LootableContainer>();
				if (containers == null || containers.Length == 0)
					return;

				List<IPlayer> rawPlayers = world.RegisteredPlayers;
				List<Player> deadPlayers = TempListPool.Rent<Player>();

				try
				{
					for (int i = 0; i < rawPlayers.Count; i++)
					{
						Player player = EFTPlayerUtil.AsEFTPlayer(rawPlayers[i]);
						if (player == null || player.HealthController == null || player.HealthController.IsAlive)
							continue;

						string profileId = player.ProfileId;
						if (string.IsNullOrEmpty(profileId) || DeadBodyContainerCache.Contains(profileId))
							continue;

						deadPlayers.Add(player);
					}

					for (int i = 0; i < deadPlayers.Count; i++)
					{
						Player player = deadPlayers[i];
						string profileId = player.ProfileId;
						if (string.IsNullOrEmpty(profileId) || DeadBodyContainerCache.Contains(profileId))
							continue;

						Transform root = player.Transform?.Original?.root;
						if (root == null)
							continue;

						Vector3 corpsePos = EFTPlayerUtil.GetPosition(player);

						for (int j = 0; j < containers.Length; j++)
						{
							LootableContainer container = containers[j];
							if (container == null || !container.enabled || container.transform == null)
								continue;

							bool sameRoot = container.transform.root == root;
							bool closeEnough = Vector3.Distance(container.transform.position, corpsePos) <= AssociationRadius;

							if (sameRoot || closeEnough)
							{
								try
								{
									DeadBodyContainerCache.Register(player, container);
									LootRuntimeWatcher.Register(container.gameObject);

									string nickname = player.Profile?.Info?.Nickname ?? "Unnamed";
									LogDebug("[DeadBodyObserver] ✅ Associated container with corpse: " + nickname);
								}
								catch (Exception ex)
								{
									LogError("[DeadBodyObserver] Register association failed: " + ex);
								}
								break;
							}
						}
					}
				}
				catch (Exception ex)
				{
					LogError("[DeadBodyObserver] Dead player scan failed: " + ex);
				}
				finally
				{
					TempListPool.Return(deadPlayers);
				}
			}
			catch (Exception ex)
			{
				LogError("[DeadBodyObserver] ❌ Tick error: " + ex);
			}
		}

		private static void LogDebug(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogDebug(msg);
		}

		private static void LogError(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogError(msg);
		}
	}
}
