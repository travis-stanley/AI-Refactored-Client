// <auto-generated>
//   Part of AI-Refactored: Realistic AI for Escape from Tarkov.
//   SYSTEMATICALLY MANAGED: Only uses EFT internal navigation; zero custom nav fallback.
//   All movement/tactical queries rely strictly on PathControllerClass, BotMover, and native EFT nav.
//   Bulletproof: Fallback to vanilla EFT AI on failure.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Canonical wrapper for all AIRefactored navigation queries.
    /// Strictly uses EFT's internal navigation: BotMover and PathControllerClass.
    /// No registry, cache, or spatial query logic allowed.
    /// </summary>
    public static class BotNavHelper
    {
        /// <summary>
        /// Attempts to resolve the next safe movement target using EFT's internal path system.
        /// Returns true if a valid target point is available.
        /// </summary>
        public static bool TryGetSafeTarget(BotOwner bot, out Vector3 target)
        {
            target = Vector3.zero;
            if (bot == null || bot.Mover == null)
                return false;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
            {
                Vector3 pt = pathController.LastTargetPoint(1.0f);
                if (IsValid(pt))
                {
                    target = pt;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Gets the current EFT path waypoints as a Vector3 array.
        /// Returns null if unavailable.
        /// </summary>
        public static Vector3[] GetCurrentPathPoints(BotOwner bot, int maxPoints = 16)
        {
            if (bot == null || bot.Mover == null)
                return null;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
                return pathController.GetWayPoints(maxPoints);

            return null;
        }

        /// <summary>
        /// Gets the current "corner" (next turn) on the active path, if available.
        /// </summary>
        public static bool TryGetCurrentCorner(BotOwner bot, out Vector3 corner)
        {
            corner = Vector3.zero;
            if (bot == null || bot.Mover == null)
                return false;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
            {
                corner = pathController.CurrentCorner();
                return IsValid(corner);
            }
            return false;
        }

        /// <summary>
        /// Gets the remaining distance to the destination, or float.MaxValue if unavailable.
        /// </summary>
        public static float GetRemainingDistance(BotOwner bot)
        {
            if (bot == null || bot.Mover == null)
                return float.MaxValue;

            var pathController = bot.Mover._pathController;
            if (IsPathValid(pathController))
                return pathController.PlayerRemainingDist;

            return float.MaxValue;
        }

        /// <summary>
        /// Returns true if a given point is on the bot's current path within maxDist.
        /// </summary>
        public static bool IsPointOnCurrentPath(BotOwner bot, Vector3 point, float maxDist)
        {
            if (bot == null || bot.Mover == null)
                return false;

            var pathController = bot.Mover._pathController;
            return IsPathValid(pathController) && pathController.IsPointOnCurrentWay(point, maxDist);
        }

        #region Internal Helpers

        private static bool IsPathValid(PathControllerClass pathController)
        {
            return pathController != null &&
                pathController.HavePath &&
                pathController.CurPath != null &&
                pathController.CurPath.Length > 0;
        }

        private static bool IsValid(Vector3 pt)
        {
            return !float.IsNaN(pt.x) && !float.IsNaN(pt.y) && !float.IsNaN(pt.z) &&
                   Mathf.Abs(pt.x) < 10000f && Mathf.Abs(pt.y) < 10000f && Mathf.Abs(pt.z) < 10000f;
        }

        #endregion
    }
}
