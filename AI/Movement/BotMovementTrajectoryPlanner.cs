// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Movement
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Modifies a bot’s movement vector by applying chaos wobble, squad staggering offsets,
    /// and teammate collision avoidance. Produces natural movement flow and reduces clustering.
    /// All failures are locally isolated; cannot break or cascade into other systems.
    /// </summary>
    public sealed class BotMovementTrajectoryPlanner
    {
        #region Constants

        private const float AvoidanceRadius = 2.0f;
        private const float AvoidanceScale = 1.25f;
        private const float ChaosInterval = 0.4f;
        private const float ChaosRadius = 0.65f;
        private const float SquadOffsetScale = 0.75f;
        private const float VelocityFactor = 1.5f;
        private const float MinMagnitude = 0.0001f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;

        private Vector3 _chaosOffset;
        private float _nextChaosUpdate;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new BotMovementTrajectoryPlanner with full null-safety and validation.
        /// </summary>
        public BotMovementTrajectoryPlanner(BotOwner bot, BotComponentCache cache)
        {
            if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null || bot.GetPlayer == null)
                throw new ArgumentException("[BotMovementTrajectoryPlanner] bot, player, or cache is null.");

            _bot = bot;
            _cache = cache;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Computes the adjusted trajectory vector with chaos, offset, avoidance, and velocity blending.
        /// Bulletproof against nulls, clustering, and ensures human-like randomness.
        /// </summary>
        public Vector3 ModifyTrajectory(Vector3 targetDir, float deltaTime)
        {
            try
            {
                float now = Time.unscaledTime;

                if (now >= _nextChaosUpdate)
                {
                    UpdateChaosOffset(now);
                }

                Vector3 baseDir = targetDir.sqrMagnitude > MinMagnitude ? targetDir.normalized : Vector3.forward;
                Vector3 adjusted = baseDir;

                if (_chaosOffset.sqrMagnitude > MinMagnitude)
                {
                    adjusted += _chaosOffset;
                }

                if (_cache.SquadPath != null)
                {
                    Vector3 squadOffset = _cache.SquadPath.GetCurrentOffset();
                    if (squadOffset.sqrMagnitude > MinMagnitude)
                    {
                        adjusted += squadOffset.normalized * SquadOffsetScale;
                    }
                }

                Vector3 avoidVector = ComputeAvoidance();
                if (avoidVector.sqrMagnitude > MinMagnitude)
                {
                    adjusted += avoidVector.normalized * AvoidanceScale;
                }

                Vector3 velocity = Vector3.zero;
                try
                {
                    velocity = _bot.GetPlayer?.Velocity ?? Vector3.zero;
                }
                catch { }

                if (velocity.sqrMagnitude > MinMagnitude)
                {
                    adjusted += velocity.normalized * VelocityFactor;
                }

                adjusted.y = 0f;
                return adjusted.sqrMagnitude > MinMagnitude ? adjusted.normalized : baseDir;
            }
            catch (Exception)
            {
                return Vector3.forward;
            }
        }

        #endregion

        #region Internal Logic

        /// <summary>
        /// Computes avoidance vector from nearby squadmates to prevent clustering/collisions.
        /// </summary>
        private Vector3 ComputeAvoidance()
        {
            try
            {
                BotsGroup group = _bot.BotsGroup;
                if (group == null || group.MembersCount <= 1)
                {
                    return Vector3.zero;
                }

                Vector3 self = _bot.Position;
                Vector3 repulsion = Vector3.zero;
                int count = 0;

                for (int i = 0; i < group.MembersCount; i++)
                {
                    BotOwner other = group.Member(i);
                    if (other == null || other == _bot || other.IsDead)
                    {
                        continue;
                    }

                    Vector3 offset = self - other.Position;
                    float dist = offset.magnitude;
                    if (dist < AvoidanceRadius && dist > 0.01f)
                    {
                        repulsion += offset.normalized / dist;
                        count++;
                    }
                }

                return count > 0 ? repulsion / count : Vector3.zero;
            }
            catch
            {
                return Vector3.zero;
            }
        }

        /// <summary>
        /// Periodically updates a chaos wobble offset to keep movement non-robotic.
        /// Wobble is personality caution-dependent and forward-biased for realism.
        /// </summary>
        private void UpdateChaosOffset(float now)
        {
            try
            {
                AIRefactoredBotOwner owner = _cache.AIRefactoredBotOwner;
                if (owner == null || owner.PersonalityProfile == null)
                {
                    _chaosOffset = Vector3.zero;
                    _nextChaosUpdate = now + ChaosInterval;
                    return;
                }

                float caution = Mathf.Clamp01(owner.PersonalityProfile.Caution);
                float chaosRange = ChaosRadius * (1f - caution);

                float x = UnityEngine.Random.Range(-chaosRange * 0.5f, chaosRange * 0.5f);
                float z = UnityEngine.Random.Range(0.05f, chaosRange); // forward-biased

                _chaosOffset = new Vector3(x, 0f, z);
                _nextChaosUpdate = now + ChaosInterval;
            }
            catch
            {
                _chaosOffset = Vector3.zero;
                _nextChaosUpdate = now + ChaosInterval;
            }
        }

        #endregion
    }
}
