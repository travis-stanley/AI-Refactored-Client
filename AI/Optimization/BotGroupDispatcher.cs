// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
//   All threading and background logic is bulletproof and fully isolated.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
	using System;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using AIRefactored.Core;
	using AIRefactored.Pools;
	using AIRefactored.Runtime;
	using BepInEx.Logging;
	using EFT;
	using UnityEngine;

	/// <summary>
	/// Schedules and dispatches thread-safe bot workloads during headless or client-hosted execution.
	/// All failures are strictly isolated to the affected job; the system cannot break, hang, or leak.
	/// </summary>
	public static class BotWorkGroupDispatcher
	{
		#region Constants

		private const int MaxWorkPerTick = 256;
		private const int MaxThreads = 16;

		#endregion

		#region Fields

		private static readonly object Sync = new object();
		private static readonly ManualLogSource Log = Plugin.LoggerInstance;
		private static readonly List<IBotWorkload> WorkQueue = new List<IBotWorkload>(MaxWorkPerTick);
		private static readonly int ThreadCount = Mathf.Clamp(Environment.ProcessorCount, 1, MaxThreads);

		#endregion

		#region Public API

		/// <summary>
		/// Queues a bot workload for background execution.
		/// Errors in queueing never break dispatcher.
		/// </summary>
		/// <param name="workload">The workload to execute.</param>
		public static void Schedule(IBotWorkload workload)
		{
			try
			{
				if (workload == null)
				{
					return;
				}

				lock (Sync)
				{
					if (WorkQueue.Count >= MaxWorkPerTick)
					{
						Log.LogWarning("[BotWorkGroupDispatcher] Max queue capacity reached. Dropping workload.");
						return;
					}

					WorkQueue.Add(workload);
				}
			}
			catch (Exception ex)
			{
				Log.LogError("[BotWorkGroupDispatcher] Schedule() error: " + ex);
			}
		}

		/// <summary>
		/// Executes queued workloads in thread batches. Call from Update().
		/// All errors are contained and never propagate.
		/// </summary>
		public static void Tick()
		{
			try
			{
				if (!GameWorldHandler.IsLocalHost())
				{
					return;
				}

				List<IBotWorkload> batch = null;

				lock (Sync)
				{
					if (WorkQueue.Count == 0)
					{
						return;
					}

					int count = Mathf.Min(WorkQueue.Count, MaxWorkPerTick);
					batch = TempListPool.Rent<IBotWorkload>();

					for (int i = 0; i < count; i++)
					{
						batch.Add(WorkQueue[i]);
					}

					WorkQueue.RemoveRange(0, count);
				}

				try
				{
					Dispatch(batch);
				}
				catch (Exception ex)
				{
					Log.LogError("[BotWorkGroupDispatcher] Dispatch() error: " + ex);
				}
				finally
				{
					TempListPool.Return(batch);
				}
			}
			catch (Exception ex)
			{
				Log.LogError("[BotWorkGroupDispatcher] Tick() error: " + ex);
			}
		}

		#endregion

		#region Dispatch

		private static void Dispatch(List<IBotWorkload> batch)
		{
			if (batch == null || batch.Count == 0)
			{
				return;
			}

			try
			{
				int total = batch.Count;
				int threads = Mathf.Clamp(ThreadCount, 1, total);
				int blockSize = Mathf.CeilToInt(total / (float)threads);

				for (int t = 0; t < threads; t++)
				{
					int start = t * blockSize;
					if (start >= total)
					{
						break;
					}

					int end = Mathf.Min(start + blockSize, total);

					// Local copy for closure safety
					int localStart = start;
					int localEnd = end;

					Task.Run(() =>
					{
						for (int i = localStart; i < localEnd; i++)
						{
							IBotWorkload job = null;
							try
							{
								job = batch[i];
							}
							catch { /* Defensive: batch access error, skip */ }

							if (job == null)
							{
								continue;
							}

							try
							{
								job.RunBackgroundWork();
							}
							catch (Exception ex)
							{
								Log.LogWarning("[BotWorkGroupDispatcher] Background workload exception:\n" + ex);
							}
						}
					});
				}
			}
			catch (Exception ex)
			{
				Log.LogError("[BotWorkGroupDispatcher] Dispatch() error: " + ex);
			}
		}

		#endregion
	}

	/// <summary>
	/// Background-safe interface for threaded bot logic. Must not use Unity APIs.
	/// </summary>
	public interface IBotWorkload
	{
		/// <summary>
		/// Executes the workload from a thread pool context.
		/// All errors are strictly isolated to this job instance.
		/// </summary>
		void RunBackgroundWork();
	}
}
