// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Reactions
{
    using System.Collections.Generic;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.Core;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Detects sudden bright light exposure from flashlights or flashbangs.
    /// Simulates temporary blindness and optionally applies suppression/fallback.
    /// </summary>
    public sealed class FlashGrenadeComponent
    {
        #region Constants

        private const float BaseBlindDuration = 4.5f;
        private const float TriggerScoreThreshold = 0.35f;

        #endregion

        #region State

        private BotOwner _bot;
        private BotComponentCache _cache;
        private bool _isBlinded;
        private float _lastFlashTime = -999f;

        #endregion

        #region Initialization

        /// <summary>
        /// Initializes the flash component with the bot's runtime cache.
        /// </summary>
        /// <param name="cache">The shared bot component cache. Must not be null and must have a Bot.</param>
        public void Initialize(BotComponentCache cache)
        {
            if (cache == null)
            {
                throw new System.ArgumentNullException(nameof(cache));
            }

            _cache = cache;
            _bot = cache.Bot ?? throw new System.ArgumentException("Bot reference is null.");
            _isBlinded = false;
            _lastFlashTime = -999f;
        }

        #endregion

        #region Runtime

        /// <summary>
        /// Returns true if the bot is still considered blinded.
        /// </summary>
        public bool IsFlashed()
        {
            return _isBlinded;
        }

        /// <summary>
        /// Forces the bot into a blind state, optionally triggering suppression logic.
        /// </summary>
        /// <param name="duration">Duration of blindness, in seconds.</param>
        /// <param name="source">Optional: world-space position of the flash source.</param>
        public void ForceBlind(float duration = BaseBlindDuration, Vector3? source = null)
        {
            if (_bot == null || _bot.IsDead)
            {
                return;
            }

            _lastFlashTime = Time.time;
            _isBlinded = true;

            if (source.HasValue)
            {
                Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                if (player != null)
                {
                    BotSuppressionHelper.TrySuppressBot(player, source.Value);
                }
            }
        }

        /// <summary>
        /// Evaluates exposure to light and clears blindness after recovery.
        /// </summary>
        /// <param name="time">Current time value.</param>
        public void Tick(float time)
        {
            if (_cache == null || _bot == null || _bot.IsDead)
            {
                return;
            }

            Player player = EFTPlayerUtil.ResolvePlayer(_bot);
            if (player == null || !player.IsAI || player.IsYourPlayer)
            {
                return;
            }

            CheckFlashlightExposure();

            if (_isBlinded && (time - _lastFlashTime) > GetBlindRecoveryTime())
            {
                _isBlinded = false;
            }
        }

        #endregion

        #region Internal

        /// <summary>
        /// Checks if the bot's head is currently being exposed by any intense flashlight sources.
        /// If exposure is detected, sets blind state and triggers suppression logic.
        /// </summary>
        private void CheckFlashlightExposure()
        {
            Transform head = BotCacheUtility.Head(_cache);
            if (head == null)
            {
                return;
            }

            IReadOnlyList<Vector3> sources = FlashlightRegistry.GetLastKnownFlashlightPositions();
            for (int i = 0, count = sources.Count; i < count; i++)
            {
                if (FlashlightRegistry.IsExposingBot(head, out Light light) && light != null)
                {
                    float score = FlashLightUtils.CalculateFlashScore(light.transform, head, 20f);
                    if (score >= TriggerScoreThreshold)
                    {
                        _lastFlashTime = Time.time;
                        _isBlinded = true;

                        Player player = EFTPlayerUtil.ResolvePlayer(_bot);
                        if (player != null)
                        {
                            BotSuppressionHelper.TrySuppressBot(player, light.transform.position);
                        }

                        return;
                    }
                }
            }
        }

        /// <summary>
        /// Returns blind recovery time based on bot composure (panic handler).
        /// </summary>
        private float GetBlindRecoveryTime()
        {
            float composure = 1f;
            if (_cache != null && _cache.PanicHandler != null)
            {
                composure = _cache.PanicHandler.GetComposureLevel();
            }

            return Mathf.Lerp(2f, BaseBlindDuration, 1f - composure);
        }

        #endregion
    }
}
