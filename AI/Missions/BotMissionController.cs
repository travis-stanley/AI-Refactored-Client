// <auto-generated>
//   AI-Refactored: BotMissionController.cs (Beyond Diamond – BotBrain Edition)
//   All mission, objective, squad, and extraction logic is bulletproof, squad-aligned, and 100% BotBrain-ticked.
//   No self-tick, no side-effects, all failures locally isolated. MIT License.
// </auto-generated>

namespace AIRefactored.AI.Missions
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.AI.Missions.Subsystems;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using EFT.HealthSystem;
    using UnityEngine;
    using Random = UnityEngine.Random;

    public sealed class BotMissionController
    {
        private const float GroupRejoinTimeout = 20f;
        private const float LootSyncDistance = 7f;
        private const float MaxMissionCooldown = 16f;
        private const float MinMissionCooldown = 7f;
        private const float CombatPauseDuration = 4.5f;

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly MissionEvaluator _evaluator;
        private readonly ObjectiveController _objectives;
        private readonly MissionSwitcher _switcher;
        private readonly MissionVoiceCoordinator _voice;
        private readonly BotExtractionDecisionSystem _extraction;

        private MissionType _missionType;
        private bool _forcedMission;
        private bool _inCombatPause;
        private float _groupWaitStart = -1f;
        private float _lastCombatTime;
        private float _lastUpdateTime;
        private float _missionCooldown;

        public enum MissionType
        {
            Loot,
            Fight,
            Quest
        }

        public BotMissionController(BotOwner bot, BotComponentCache cache)
        {
            try
            {
                if (!EFTPlayerUtil.IsValidBotOwner(bot) || cache == null)
                    throw new ArgumentException("[BotMissionController] Invalid bot or cache reference.");

                _bot = bot;
                _cache = cache;

                _switcher = new MissionSwitcher(bot, cache);
                _objectives = new ObjectiveController(bot, cache);
                _evaluator = new MissionEvaluator(bot, cache);
                _voice = new MissionVoiceCoordinator(bot);

                BotPersonalityProfile profile = cache.AIRefactoredBotOwner != null
                    ? cache.AIRefactoredBotOwner.PersonalityProfile
                    : new BotPersonalityProfile();

                _extraction = new BotExtractionDecisionSystem(bot, cache, profile);

                GroupMissionCoordinator.RegisterFromBot(bot);
                _missionType = GroupMissionCoordinator.GetMissionForGroup(bot);
                _objectives.SetInitialObjective(_missionType);

                cache.AIRefactoredBotOwner?.SetMissionController(this);

                _missionCooldown = GetNextCooldown();

                Logger.LogDebug("[BotMissionController] Assigned mission: " + _missionType + " for bot " + (bot.Profile?.Info?.Nickname ?? "Unknown"));
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMissionController] Constructor failed: {ex}");
            }
        }

        public void Tick(float time)
        {
            try
            {
                Player player = _bot.GetPlayer;
                IHealthController health = player?.HealthController;

                if (_bot.IsDead || player == null || health == null || !health.IsAlive)
                    return;

                if (_cache.IsBlinded || (_cache.PanicHandler != null && _cache.PanicHandler.IsPanicking))
                    return;

                _evaluator.UpdateStuckCheck(time);

                if (!_forcedMission)
                {
                    _switcher.Evaluate(
                        ref _missionType,
                        time,
                        SwitchToFight,
                        _objectives.ResumeQuesting,
                        _evaluator.IsGroupAligned
                    );
                }

                if (_cache.Combat != null && _cache.Combat.IsInCombatState())
                {
                    _lastCombatTime = time;
                    if (_missionType == MissionType.Quest)
                        _inCombatPause = true;
                }

                if (_inCombatPause && time - _lastCombatTime > CombatPauseDuration)
                {
                    _inCombatPause = false;
                    _objectives.ResumeQuesting();
                }

                _extraction.Tick(time);

                if (!_evaluator.IsGroupAligned() && _missionType != MissionType.Fight)
                {
                    if (_groupWaitStart < 0f)
                        _groupWaitStart = time;

                    if (time - _groupWaitStart < GroupRejoinTimeout)
                        return;

                    _groupWaitStart = -1f;
                }
                else
                {
                    _groupWaitStart = -1f;
                }

                if (time - _lastUpdateTime > _missionCooldown)
                {
                    _objectives.OnObjectiveReached(_missionType);
                    _lastUpdateTime = time;
                    _missionCooldown = GetNextCooldown();
                }

                if (!_inCombatPause &&
                    _missionType == MissionType.Loot &&
                    _cache.LootScanner != null &&
                    Vector3.Distance(_bot.Position, _objectives.CurrentObjective) < LootSyncDistance)
                {
                    OnObjectiveReached(time);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMissionController] Tick failed: {ex}");
            }
        }

        public void SetForcedMission(MissionType mission)
        {
            try
            {
                _missionType = mission;
                _forcedMission = true;
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMissionController] SetForcedMission failed: {ex}");
            }
        }

        private void OnObjectiveReached(float now)
        {
            try
            {
                if (_missionType == MissionType.Loot &&
                    _cache.LootScanner != null &&
                    _cache.GroupBehavior != null &&
                    _cache.GroupBehavior.GroupSync != null)
                {
                    Vector3 myPos = _bot.Position;

                    if (_cache.GroupBehavior.GroupSync.SupportsLootPoint)
                        _cache.GroupBehavior.GroupSync.ShareLootToSquad(myPos);

                    Vector3? fallback = _cache.GroupBehavior.GroupSync.GetSharedFallbackTarget();
                    if (fallback.HasValue && Vector3.Distance(myPos, fallback.Value) > 4f)
                    {
                        Logger.LogDebug("[BotMissionController] Loot canceled — squad fallback active.");
                        return;
                    }

                    _cache.Movement?.EnterLootingMode();
                    _cache.PoseController?.LockCrouchPose();
                    _cache.DeadBodyScanner?.Tick(now);
                    _cache.Movement?.ExitLootingMode();
                    _voice.OnLoot();
                }

                _objectives.OnObjectiveReached(_missionType);
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMissionController] OnObjectiveReached failed: {ex}");
            }
        }

        private void SwitchToFight()
        {
            try
            {
                _missionType = MissionType.Fight;
                _objectives.SetInitialObjective(_missionType);
                _voice.OnMissionSwitch();

                string groupId = _bot.Profile?.Info?.GroupId;
                if (!string.IsNullOrEmpty(groupId))
                {
                    GroupMissionCoordinator.ForceMissionForGroup(groupId, MissionType.Fight);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"[BotMissionController] SwitchToFight failed: {ex}");
            }
        }

        private float GetNextCooldown()
        {
            try
            {
                return MinMissionCooldown + Random.Range(0f, MaxMissionCooldown - MinMissionCooldown);
            }
            catch
            {
                return 11f;
            }
        }
    }
}
