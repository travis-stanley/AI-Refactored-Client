// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe retry and recovery. No fallback or terminal state.
//   Bulletproof: All failures are strictly localized and cannot break the mod. Atomic bot brain/owner/cache recovery logic.
// </auto-generated>

namespace AIRefactored.Runtime
{
	using System;
	using System.Collections.Generic;
	using AIRefactored.AI.Core;
	using AIRefactored.AI.Hotspots;
	using AIRefactored.AI.Looting;
	using AIRefactored.AI.Navigation;
	using AIRefactored.AI.Threads;
	using AIRefactored.Bootstrap;
	using AIRefactored.Core;
	using BepInEx.Logging;
	using Comfort.Common;
	using EFT;
	using EFT.Game.Spawning;
	using UnityEngine;

	/// <summary>
	/// Monolithic bot lifecycle, cache, and owner/brain recovery watchdog.
	/// All failures are contained; no fallback or terminal disable, always retry on incomplete state.
	/// </summary>
	public sealed class BotRecoveryService : IAIWorldSystemBootstrapper
	{
		private const float TickInterval = 5f;

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

		private static float _nextTickTime = -1f;
		private static bool _hasWarned;
		private static bool _hasRescanned;
		private static bool _hasInitialized;
		private static bool _hookedSpawner;

		public static BotRecoveryService Instance { get; } = new BotRecoveryService();

		/// <summary>
		/// Initializes the recovery service and resets state.
		/// </summary>
		public void Initialize()
		{
			try
			{
				Reset();
				_hasInitialized = true;
				LogDebug("[BotRecoveryService] ✅ Initialized.");
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ Initialize failed: " + ex);
			}
		}

		/// <summary>
		/// Called on raid end or teardown to reset and detach hooks.
		/// </summary>
		public void OnRaidEnd()
		{
			try
			{
				if (_hookedSpawner && Singleton<BotSpawner>.Instantiated)
				{
					Singleton<BotSpawner>.Instance.OnBotCreated -= GameWorldHandler.TryAttachBotBrain;
					_hookedSpawner = false;
				}

				Reset();
				_hasInitialized = false;
				LogDebug("[BotRecoveryService] 🧹 Reset on raid end.");
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ OnRaidEnd error: " + ex);
			}
		}

		/// <summary>
		/// Returns true if initialized and GameWorldHandler is ready.
		/// </summary>
		public bool IsReady() => _hasInitialized && GameWorldHandler.IsReady();

		/// <summary>
		/// The required phase for this system (always WorldReady).
		/// </summary>
		public WorldPhase RequiredPhase() => WorldPhase.WorldReady;

		/// <summary>
		/// Resets all internal static state.
		/// </summary>
		public static void Reset()
		{
			_nextTickTime = -1f;
			_hasWarned = false;
			_hasRescanned = false;
			_hookedSpawner = false;
		}

		/// <summary>
		/// Ticks the recovery service to ensure all bots, owners, and caches are wired and running.
		/// </summary>
		public void Tick(float deltaTime)
		{
			try
			{
				if (!_hasInitialized || !GameWorldHandler.IsHost || !GameWorldHandler.IsReady())
					return;

				float now = Time.time;
				if (now < _nextTickTime)
					return;

				_nextTickTime = now + TickInterval;

				GameWorld world = GameWorldHandler.Get();
				if (world == null || world.AllAlivePlayersList == null)
				{
					if (!_hasWarned)
					{
						LogWarn("[BotRecoveryService] ⚠ GameWorld not ready.");
						_hasWarned = true;
					}
					return;
				}

				if (_hasWarned)
				{
					_hasWarned = false;
					LogDebug("[BotRecoveryService] ✅ GameWorld recovered.");
				}

				EnsureSpawnHook();
				ValidateBotBrains(world.AllAlivePlayersList);
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ Tick error: " + ex);
			}
		}

		/// <summary>
		/// Ensures the BotSpawner event hook is attached for runtime bot injection.
		/// </summary>
		private static void EnsureSpawnHook()
		{
			try
			{
				if (_hookedSpawner || !Singleton<BotSpawner>.Instantiated)
					return;

				Singleton<BotSpawner>.Instance.OnBotCreated += GameWorldHandler.TryAttachBotBrain;
				_hookedSpawner = true;
				LogDebug("[BotRecoveryService] ✅ BotSpawner hook attached.");
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ EnsureSpawnHook error: " + ex);
			}
		}

		/// <summary>
		/// Iterates all living AI players and ensures full owner/cache/brain wiring, recovering any missing subsystems.
		/// </summary>
		private static void ValidateBotBrains(List<Player> players)
		{
			for (int i = 0; i < players.Count; i++)
			{
				try
				{
					Player player = players[i];
					if (!EFTPlayerUtil.IsValid(player) || !player.IsAI || player.gameObject == null || player.HealthController == null || !player.HealthController.IsAlive)
						continue;

					string profileId = player.ProfileId ?? player.Profile?.Id;
					if (string.IsNullOrEmpty(profileId))
						continue;

					if (player.gameObject.GetComponent<BotBrain>() != null)
						continue;

					if (player.AIData?.BotOwner == null)
						continue;

					var botOwner = player.AIData.BotOwner;
					var cache = BotComponentCacheRegistry.GetOrCreate(botOwner);
					if (cache == null)
					{
						LogWarn("[BotRecoveryService] Cache was null for bot. Will retry.");
						continue;
					}

					if (cache.Bot == null || cache.AIRefactoredBotOwner == null)
					{
						LogWarn($"[BotRecoveryService] Incomplete cache for bot {profileId} — waiting for next tick.");
						continue;
					}

					if (!cache.AIRefactoredBotOwner.HasPersonality())
					{
						// Only allowed logic: assign default personality
						cache.AIRefactoredBotOwner.InitProfile(cache.AIRefactoredBotOwner.PersonalityProfile, cache.AIRefactoredBotOwner.PersonalityName);
					}

					GameWorldHandler.TryAttachBotBrain(botOwner);
					LogWarn("[BotRecoveryService] ⚠ BotBrain missing — injected late for: " + (player.Profile?.Info?.Nickname ?? "Unknown"));

					if (!_hasRescanned && GameWorldHandler.IsReady() && WorldInitState.IsInPhase(WorldPhase.WorldReady))
					{
						_hasRescanned = true;
						RescanWorld();
					}
				}
				catch (Exception ex)
				{
					LogError("[BotRecoveryService] ValidateBotBrains() error: " + ex);
				}
			}
		}

		/// <summary>
		/// Re-initializes world systems (hotspot, loot, corpse) for full recovery after late boot.
		/// </summary>
		private static void RescanWorld()
		{
			try
			{
				if (!GameWorldHandler.IsReady() || !WorldInitState.IsInPhase(WorldPhase.WorldReady))
				{
					LogWarn("[BotRecoveryService] ❌ Rescan aborted — world or phase not ready.");
					return;
				}

				string mapId = GameWorldHandler.TryGetValidMapName();
				if (string.IsNullOrEmpty(mapId))
				{
					LogWarn("[BotRecoveryService] ❌ Rescan aborted — mapId missing or invalid.");
					return;
				}

				LogDebug("[BotRecoveryService] 🔄 Rescanning world systems for map: " + mapId);

				HotspotRegistry.Clear();
				HotspotRegistry.Initialize(mapId);

				LootRegistry.Clear();
				LootBootstrapper.RegisterAllLoot();
				BotDeadBodyScanner.ScanAll();

				LogDebug("[BotRecoveryService] ✅ World rescan complete.");
			}
			catch (Exception ex)
			{
				LogError("[BotRecoveryService] ❌ RescanWorld error: " + ex);
			}
		}

		#region Logging

		private static void LogDebug(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogDebug(msg);
		}

		private static void LogWarn(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogWarning(msg);
		}

		private static void LogError(string msg)
		{
			if (!FikaHeadlessDetector.IsHeadless)
				Logger.LogError(msg);
		}

		#endregion
	}
}
