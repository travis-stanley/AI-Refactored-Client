// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Please follow strict StyleCop, ReSharper, and AI-Refactored code standards for all modifications.
// </auto-generated>

namespace AIRefactored.AI.Optimization
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Groups;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using BepInEx.Logging;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Handles asynchronous low-frequency logic for bot behavior tuning and squad optimization.
    /// Supports thread-based workloads in headless environments.
    /// Runs only on the authoritative host (headless or client-host).
    /// </summary>
    public sealed class BotAsyncProcessor
    {
        #region Constants

        private const float InitDelaySeconds = 0.5f;
        private const float ThinkCooldownHeadless = 1.5f;
        private const float ThinkCooldownNormal = 3.5f;

        #endregion

        #region Fields

        private static readonly ManualLogSource Logger = Plugin.LoggerInstance;

        private readonly BotOwnerGroupOptimization _groupOptimizer = new BotOwnerGroupOptimization();

        private BotOwner _bot;
        private BotComponentCache _cache;
        private BotOwnerStateCache _stateCache;

        private bool _hasInitialized;
        private float _lastThinkTime;

        #endregion

        #region Public API

        /// <summary>
        /// Initializes the async processor for the specified bot.
        /// </summary>
        /// <param name="botOwner">The bot owner to initialize for.</param>
        /// <param name="cache">The shared bot component cache.</param>
        public void Initialize(BotOwner botOwner, BotComponentCache cache)
        {
            if (!GameWorldHandler.IsLocalHost() || botOwner == null || cache == null)
            {
                return;
            }

            _bot = botOwner;
            _cache = cache;
            _stateCache = new BotOwnerStateCache();
            _hasInitialized = false;
            _lastThinkTime = 0f;

            Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromSeconds(InitDelaySeconds));
                    if (!_hasInitialized)
                    {
                        await ApplyInitialPersonalityAsync(botOwner);
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogWarning("[BotAsyncProcessor] Async init failed: " + ex.Message);
                }
            });
        }

        /// <summary>
        /// Updates bot async logic based on timing and environment.
        /// </summary>
        /// <param name="time">Current time (from main game loop).</param>
        public void Tick(float time)
        {
            if (!GameWorldHandler.IsLocalHost() || !_hasInitialized || _bot == null || _bot.IsDead)
            {
                return;
            }

            _stateCache.UpdateBotOwnerStateIfNeeded(_bot);
            TryOptimizeGroup();

            float cooldown = FikaHeadlessDetector.IsHeadless ? ThinkCooldownHeadless : ThinkCooldownNormal;
            if (time - _lastThinkTime < cooldown)
            {
                return;
            }

            _lastThinkTime = time;

            if (FikaHeadlessDetector.IsHeadless)
            {
                ThreadPool.QueueUserWorkItem(_ =>
                {
                    try { Think(); }
                    catch (Exception ex) { Logger.LogWarning("[BotAsyncProcessor] Async headless think failed: " + ex.Message); }
                });
            }
            else
            {
                try { Think(); }
                catch (Exception ex) { Logger.LogWarning("[BotAsyncProcessor] Think execution failed: " + ex.Message); }
            }
        }

        #endregion

        #region Internal Logic

        private async Task ApplyInitialPersonalityAsync(BotOwner bot)
        {
            if (_hasInitialized || bot == null || bot.Profile == null || bot.Settings == null || bot.Settings.FileSettings == null)
            {
                return;
            }

            await Task.Yield();

            string profileId = bot.Profile.Id;
            if (string.IsNullOrEmpty(profileId))
            {
                return;
            }

            BotGlobalsMindSettings mind = bot.Settings.FileSettings.Mind;
            if (mind == null)
            {
                return;
            }

            BotPersonalityProfile personality = BotRegistry.Get(profileId);
            if (personality == null)
            {
                return;
            }

            mind.PANIC_RUN_WEIGHT = Mathf.Lerp(0.5f, 2.0f, personality.RiskTolerance);
            mind.PANIC_SIT_WEIGHT = Mathf.Lerp(10.0f, 80.0f, 1f - personality.RiskTolerance);
            mind.DIST_TO_FOUND_SQRT = Mathf.Lerp(200f, 600f, 1f - personality.Cohesion);
            mind.FRIEND_AGR_KILL = Mathf.Lerp(0f, 0.4f, personality.AggressionLevel);

            Logger.LogDebug("[BotAsyncProcessor] ✅ Personality initialized for bot: " + (bot.Profile.Info?.Nickname ?? "Unknown"));
            _hasInitialized = true;
        }

        private void Think()
        {
            if (_bot == null || _bot.IsDead)
            {
                return;
            }

            // Mumble phrase simulation with ultra-low random chance.
            if (UnityEngine.Random.value < 0.008f)
            {
                BotWorkScheduler.EnqueueToMainThread(() =>
                {
                    try
                    {
                        EFT.Player p = _bot.GetPlayer;
                        if (p != null)
                        {
                            p.Say(EPhraseTrigger.MumblePhrase);
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning("[BotAsyncProcessor] Mumble dispatch failed: " + ex.Message);
                    }
                });
            }
        }

        private void TryOptimizeGroup()
        {
            if (_bot == null || _bot.Profile == null || _bot.Profile.Info == null)
            {
                return;
            }

            string groupId = _bot.Profile.Info.GroupId;
            if (string.IsNullOrEmpty(groupId))
            {
                return;
            }

            List<BotOwner> squad = BotTeamTracker.GetGroup(groupId);
            if (squad != null && squad.Count > 0)
            {
                _groupOptimizer.OptimizeGroupAI(squad);
            }
        }

        #endregion
    }
}
