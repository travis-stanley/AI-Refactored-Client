// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Failures in AIRefactored logic must always trigger safe fallback to EFT base AI.
// </auto-generated>

namespace AIRefactored.AI.Combat.States
{
    using System;
    using AIRefactored.AI.Core;
    using AIRefactored.AI.Helpers;
    using AIRefactored.AI.Memory;
    using AIRefactored.AI.Navigation;
    using AIRefactored.Core;
    using AIRefactored.Runtime;
    using EFT;
    using UnityEngine;

    /// <summary>
    /// Manages bot investigation behavior when sound or memory suggest enemy presence.
    /// Guides cautious, reactive movement toward enemy vicinity with adaptive stance.
    /// Bulletproof: All failures are isolated; only this handler disables itself and triggers vanilla fallback if required.
    /// </summary>
    public sealed class InvestigateHandler
    {
        #region Constants

        private const float InvestigateCooldown = 10.0f;
        private const float ScanRadius = 4.0f;
        private const float SoundReactTime = 1.0f;
        private const float MaxInvestigateTime = 15.0f;
        private const float MinCaution = 0.3f;
        private const float ExitDelayBuffer = 1.25f;
        private const float ActiveWindow = 5.0f;

        #endregion

        #region Fields

        private readonly BotOwner _bot;
        private readonly BotComponentCache _cache;
        private readonly BotTacticalMemory _memory;
        private bool _isFallbackMode;

        #endregion

        #region Constructor

        public InvestigateHandler(BotComponentCache cache)
        {
            _cache = cache;
            _bot = cache?.Bot;
            _memory = cache?.TacticalMemory;

            if (_cache == null || _bot == null || _memory == null)
            {
                BotFallbackUtility.Trigger(this, _bot, "Constructor failed: Cache, Bot, or TacticalMemory is null.");
                _isFallbackMode = true;
            }
            else
            {
                _isFallbackMode = false;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Resolves a safe target for investigation from visual memory, tactical memory, or randomized fallback.
        /// </summary>
        public Vector3 GetInvestigateTarget(Vector3 visualLastKnown)
        {
            if (_isFallbackMode)
                return _bot != null ? _bot.Position : Vector3.zero;

            try
            {
                if (IsVectorValid(visualLastKnown))
                    return visualLastKnown;

                if (TryGetMemoryEnemyPosition(out Vector3 memoryPos))
                    return memoryPos;

                Vector3 fallback = RandomNearbyPosition();
                return BotNavValidator.Validate(_bot, "InvestigateRandomFallback")
                    ? fallback
                    : FallbackNavPointProvider.GetSafePoint(_bot != null ? _bot.Position : Vector3.zero);
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "Exception in GetInvestigateTarget.", ex);
                _isFallbackMode = true;
                return _bot != null ? _bot.Position : Vector3.zero;
            }
        }

        /// <summary>
        /// Moves bot toward the investigation target and clears the tactical memory entry.
        /// </summary>
        public void Investigate(Vector3 target)
        {
            if (_isFallbackMode || _cache == null || _bot == null)
                return;

            try
            {
                Vector3 destination = _cache.SquadPath != null
                    ? _cache.SquadPath.ApplyOffsetTo(target)
                    : target;

                bool navValid = false;
                if (!IsVectorValid(destination))
                {
                    navValid = false;
                }
                else
                {
                    try
                    {
                        navValid = BotNavValidator.Validate(_bot, "InvestigateDestination");
                    }
                    catch (Exception ex)
                    {
                        BotFallbackUtility.Trigger(this, _bot, "NavValidator exception in Investigate.", ex);
                        navValid = false;
                    }
                }

                if (!navValid)
                {
                    destination = FallbackNavPointProvider.GetSafePoint(_bot.Position);
                }

                if (_bot.Mover != null)
                {
                    try
                    {
                        BotMovementHelper.SmoothMoveTo(_bot, destination);
                        _memory.MarkCleared(destination);
                        _cache.Combat?.TrySetStanceFromNearbyCover(destination);
                    }
                    catch (Exception ex)
                    {
                        BotFallbackUtility.Trigger(this, _bot, "Exception in SmoothMoveTo/MarkCleared.", ex);
                        _isFallbackMode = true;
                        BotFallbackUtility.FallbackToEFTLogic(_bot);
                    }
                }
                else
                {
                    BotFallbackUtility.Trigger(this, _bot, "BotMover missing. Fallback to EFT AI.");
                    _isFallbackMode = true;
                    BotFallbackUtility.FallbackToEFTLogic(_bot);
                }
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "General exception in Investigate.", ex);
                _isFallbackMode = true;
            }
        }

        /// <summary>
        /// Determines whether the bot should enter investigation state based on caution and sound memory.
        /// </summary>
        public bool ShallUseNow(float time, float lastTransition)
        {
            if (_isFallbackMode || _cache == null || _cache.AIRefactoredBotOwner?.PersonalityProfile == null)
                return false;

            try
            {
                if (_cache.AIRefactoredBotOwner.PersonalityProfile.Caution < MinCaution)
                    return false;

                float heardTime = _cache.LastHeardTime;
                return (heardTime + SoundReactTime) > time && (time - lastTransition) > ExitDelayBuffer;
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "Exception in ShallUseNow.", ex);
                _isFallbackMode = true;
                return false;
            }
        }

        /// <summary>
        /// Determines if bot has exceeded its investigation time or cooldown.
        /// </summary>
        public bool ShouldExit(float now, float lastHitTime, float cooldown)
        {
            if (_isFallbackMode)
                return true;

            try
            {
                float elapsed = now - lastHitTime;
                return elapsed > cooldown || elapsed > MaxInvestigateTime;
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "Exception in ShouldExit.", ex);
                _isFallbackMode = true;
                return true;
            }
        }

        /// <summary>
        /// Returns true if the bot is actively investigating a recent stimulus.
        /// </summary>
        public bool IsInvestigating()
        {
            if (_isFallbackMode || _cache == null)
                return false;

            try
            {
                return (Time.time - _cache.LastHeardTime) <= ActiveWindow;
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "Exception in IsInvestigating.", ex);
                _isFallbackMode = true;
                return false;
            }
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Attempts to retrieve a valid enemy position from tactical memory.
        /// </summary>
        private bool TryGetMemoryEnemyPosition(out Vector3 result)
        {
            result = Vector3.zero;
            if (_memory == null)
                return false;

            try
            {
                Vector3? memory = _memory.GetRecentEnemyMemory();
                if (memory.HasValue && IsVectorValid(memory.Value))
                {
                    result = memory.Value;
                    return true;
                }
            }
            catch (Exception ex)
            {
                BotFallbackUtility.Trigger(this, _bot, "Exception in TryGetMemoryEnemyPosition.", ex);
                _isFallbackMode = true;
            }
            return false;
        }

        /// <summary>
        /// Generates a random offset near the bot for fallback investigation.
        /// </summary>
        private Vector3 RandomNearbyPosition()
        {
            Vector3 basePos = _bot != null ? _bot.Position : Vector3.zero;
            Vector3 offset = UnityEngine.Random.insideUnitSphere * ScanRadius;
            offset.y = 0f;
            return basePos + offset;
        }

        /// <summary>
        /// Verifies a vector is usable (non-NaN, non-zero).
        /// </summary>
        private static bool IsVectorValid(Vector3 v)
        {
            return !float.IsNaN(v.x) && !float.IsNaN(v.y) && !float.IsNaN(v.z) && v != Vector3.zero;
        }

        #endregion
    }
}
