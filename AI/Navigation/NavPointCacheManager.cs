// <auto-generated>
//   This file is part of AI-Refactored, an open-source project focused on realistic AI behavior in Escape from Tarkov.
//   Licensed under the MIT License. See LICENSE in the repository root for more information.
//
//   THIS FILE IS SYSTEMATICALLY MANAGED.
//   Do not modify without verifying the NavPointRegistry binary format.
// </auto-generated>

namespace AIRefactored.AI.Navigation
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using AIRefactored.Core;
	using BepInEx.Logging;
	using UnityEngine;

	/// <summary>
	/// Handles persistent caching of NavPointData for faster warmup and reduced runtime cost.
	/// </summary>
	public static class NavPointCacheManager
	{
		#region Constants

		private const string FolderName = "AI-Refactored";
		private const string CacheDirName = "Cache";
		private const string CacheExt = ".navcache";
		private const string MetaExt = ".meta";

		#endregion

		#region Static

		private static readonly ManualLogSource Logger = Plugin.LoggerInstance;
		private static readonly string CacheDirPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "BepInEx", FolderName, CacheDirName);

		#endregion

		#region Public API

		/// <summary>
		/// Attempts to load cached navpoints from disk.
		/// </summary>
		public static bool TryLoad(string mapId, out List<NavPointData> navPoints)
		{
			navPoints = null;
			if (string.IsNullOrEmpty(mapId))
			{
				return false;
			}

			try
			{
				string file = GetCacheFilePath(mapId);
				string meta = GetMetaFilePath(mapId);

				if (!File.Exists(file) || !File.Exists(meta) || !VerifyChecksum(meta, mapId))
				{
					return false;
				}

				using (var stream = File.OpenRead(file))
				using (var reader = new BinaryReader(stream))
				{
					int count = reader.ReadInt32();
					navPoints = new List<NavPointData>(count);

					for (int i = 0; i < count; i++)
					{
						Vector3 position = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
						bool isCover = reader.ReadBoolean();
						string tag = reader.ReadString();
						float elevation = reader.ReadSingle();
						bool isIndoor = reader.ReadBoolean();
						bool isJumpable = reader.ReadBoolean();
						float coverAngle = reader.ReadSingle();
						string zone = reader.ReadString();
						string elevationBand = reader.ReadString();

						navPoints.Add(new NavPointData(position, isCover, tag, elevation, isIndoor, isJumpable, coverAngle, zone, elevationBand));
					}
				}

				Logger.LogInfo("[NavPointCacheManager] ✅ Loaded cached navpoints for map: " + mapId);
				return true;
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointCacheManager] ❌ Failed to load cache: " + ex);
				return false;
			}
		}

		/// <summary>
		/// Saves the current navpoint registry state to disk.
		/// </summary>
		public static void Save(string mapId, List<NavPointData> navPoints)
		{
			if (string.IsNullOrEmpty(mapId) || navPoints == null || navPoints.Count == 0)
			{
				return;
			}

			try
			{
				try
				{
					Directory.CreateDirectory(CacheDirPath);
				}
				catch (Exception exDir)
				{
					Logger.LogWarning("[NavPointCacheManager] Directory creation failed: " + exDir);
				}

				string file = GetCacheFilePath(mapId);
				string meta = GetMetaFilePath(mapId);

				using (var stream = File.Create(file))
				using (var writer = new BinaryWriter(stream))
				{
					writer.Write(navPoints.Count);

					foreach (var point in navPoints)
					{
						writer.Write(point.Position.x);
						writer.Write(point.Position.y);
						writer.Write(point.Position.z);

						writer.Write(point.IsCover);
						writer.Write(point.Tag);
						writer.Write(point.Elevation);
						writer.Write(point.IsIndoor);
						writer.Write(point.IsJumpable);
						writer.Write(point.CoverAngle);
						writer.Write(point.Zone);
						writer.Write(point.ElevationBand);
					}
				}

				File.WriteAllText(meta, GenerateChecksum(mapId, navPoints.Count));
				Logger.LogInfo($"[NavPointCacheManager] 💾 Saved navpoint cache for map: {mapId} ({navPoints.Count} points)");
			}
			catch (Exception ex)
			{
				Logger.LogError("[NavPointCacheManager] ❌ Failed to save navpoint cache: " + ex);
			}
		}

		#endregion

		#region Internal Helpers

		private static string GetCacheFilePath(string mapId)
			=> Path.Combine(CacheDirPath, mapId + CacheExt);

		private static string GetMetaFilePath(string mapId)
			=> Path.Combine(CacheDirPath, mapId + CacheExt + MetaExt);

		private static string GenerateChecksum(string mapId, int count)
			=> $"{mapId}:{count}";

		private static bool VerifyChecksum(string metaPath, string mapId)
		{
			try
			{
				if (!File.Exists(metaPath))
				{
					return false;
				}

				string content = File.ReadAllText(metaPath);
				var parts = content.Split(':');
				return parts.Length == 2 && parts[0] == mapId && int.TryParse(parts[1], out _);
			}
			catch
			{
				return false;
			}
		}

		#endregion
	}
}
